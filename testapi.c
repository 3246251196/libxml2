/*
 * testapi.c: libxml2 API tester program.
 *
 * Automatically generated by gentest.py from libxml2-api.xml
 *
 * See Copyright for the status of this software.
 *
 * daniel@veillard.com
 */

#include <stdio.h>
#include <string.h>
#include <libxml/xmlerror.h>
#include <libxml/relaxng.h>

static int testlibxml2(void);
static int test_module(const char *module);

static int generic_errors = 0;
static int call_tests = 0;
static int function_tests = 0;

static xmlChar chartab[1024] = "  chartab\n";
static int inttab[1024];
#if 0
static unsigned long longtab[1024];
#endif

static xmlDocPtr api_doc = NULL;
static xmlNodePtr api_root = NULL;
static xmlAttrPtr api_attr = NULL;

static void
structured_errors(void *userData ATTRIBUTE_UNUSED,
                  xmlErrorPtr error ATTRIBUTE_UNUSED) {
    generic_errors++;
}

static void
free_api_doc(void) {
    xmlFreeDoc(api_doc);
    api_doc = NULL;
    api_root = NULL;
    api_attr = NULL;
}

static xmlDocPtr
get_api_doc(void) {
    if (api_doc == NULL) {
        api_doc = xmlReadMemory("<root xmlns:h='http://example.com/' h:foo='bar'/>", 49, "root_test", NULL, 0);
	api_root = NULL;
	api_attr = NULL;
    }
    return(api_doc);
}

static xmlNodePtr
get_api_root(void) {
    if ((api_root == NULL) || (api_root->type != XML_ELEMENT_NODE)) {
        get_api_doc();
	if ((api_doc != NULL) && (api_doc->children != NULL) &&
	    (api_doc->children->type == XML_ELEMENT_NODE))
	    api_root = api_doc->children;
    }
    return(api_root);
}

static xmlAttrPtr
get_api_attr(void) {
    static int nr = 0;
    xmlChar name[20];

    if ((api_root == NULL) || (api_root->type != XML_ELEMENT_NODE)) {
        get_api_root();
    }
    if (api_root == NULL) 
        return(NULL);
    if (api_root->properties != NULL) {
        api_attr = api_root->properties;
        return(api_root->properties);
    }
    snprintf((char *) name, 20, "foo%d", nr++);
    api_attr = xmlSetProp(api_root, name, (const xmlChar *) "bar");
    return(api_attr);
}

int main(int argc, char **argv) {
    int ret;
    int blocks, mem;

    xmlInitParser();
#ifdef LIBXML_SCHEMAS_ENABLED
    xmlRelaxNGInitTypes();
#endif

    LIBXML_TEST_VERSION

    xmlSetStructuredErrorFunc(NULL, structured_errors);

    if (argc == 2)
        ret = test_module(argv[1]);
    else
	ret = testlibxml2();

    xmlCleanupParser();
    blocks = xmlMemBlocks();
    mem = xmlMemUsed();
    if ((blocks != 0) || (mem != 0)) {
        printf("testapi leaked %d bytes in %d blocks\n", mem, blocks);
    }
    xmlMemoryDump();

    return (ret != 0);
}

#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/catalog.h>
#include <libxml/chvalid.h>
#include <libxml/dict.h>
#include <libxml/encoding.h>
#include <libxml/entities.h>
#include <libxml/hash.h>
#include <libxml/list.h>
#include <libxml/nanoftp.h>
#include <libxml/nanohttp.h>
#include <libxml/parser.h>
#include <libxml/pattern.h>
#include <libxml/relaxng.h>
#include <libxml/schemasInternals.h>
#include <libxml/tree.h>
#include <libxml/uri.h>
#include <libxml/valid.h>
#include <libxml/xinclude.h>
#include <libxml/xmlIO.h>
#include <libxml/xmlerror.h>
#include <libxml/xmlreader.h>
#include <libxml/xmlsave.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>
#include <libxml/xmlstring.h>
#include <libxml/xmlwriter.h>
#include <libxml/xpath.h>
#include <libxml/xpointer.h>

#define gen_nb_void_ptr 2

static void *gen_void_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_void_ptr(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#if 0
#define gen_nb_const_void_ptr 2

static const void *gen_const_void_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((const void *) "immutable string");
    return(NULL);
}
static void des_const_void_ptr(int no ATTRIBUTE_UNUSED, const void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
#endif

#define gen_nb_userdata 3

static void *gen_userdata(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((void *) &call_tests);
    if (no == 1) return((void *) -1);
    return(NULL);
}
static void des_userdata(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}


#define gen_nb_int 4

static int gen_int(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 1) return(-1);
    if (no == 2) return(122);
    return(-1);
}

static void des_int(int no ATTRIBUTE_UNUSED, int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#if 0
#define gen_nb_long 4

static long gen_long(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 1) return(-1);
    if (no == 2) return(122);
    return(-1);
}

static void des_long(int no ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
#endif

#define gen_nb_unsigned_int 3

static unsigned int gen_unsigned_int(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return(-1);
}

static void des_unsigned_int(int no ATTRIBUTE_UNUSED, unsigned int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#if 0
#define gen_nb_unsigned_long 3

static unsigned long gen_unsigned_long(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return(-1);
}

static void des_unsigned_long(int no ATTRIBUTE_UNUSED, unsigned long val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_unsigned_long_ptr 2

static unsigned long *gen_unsigned_long_ptr(int no, int nr) {
    if (no == 0) return(&longtab[nr]);
    return(NULL);
}

static void des_unsigned_long_ptr(int no ATTRIBUTE_UNUSED, unsigned long *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
#endif

#define gen_nb_int_ptr 2

static int *gen_int_ptr(int no, int nr) {
    if (no == 0) return(&inttab[nr]);
    return(NULL);
}

static void des_int_ptr(int no ATTRIBUTE_UNUSED, int *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_const_char_ptr 4

static const char *gen_const_char_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("foo");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    return(NULL);
}
static void des_const_char_ptr(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlChar_ptr 2

static xmlChar *gen_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(&chartab[0]);
    return(NULL);
}
static void des_xmlChar_ptr(int no ATTRIBUTE_UNUSED, xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_FILE_ptr 2

static FILE *gen_FILE_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(fopen("test.out", "a+"));
    return(NULL);
}
static void des_FILE_ptr(int no ATTRIBUTE_UNUSED, FILE *val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) fclose(val);
}

#define gen_nb_const_xmlChar_ptr 5

static const xmlChar *gen_const_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((const xmlChar *) "foo");
    if (no == 1) return((const xmlChar *) "<foo/>");
    if (no == 2) return((const xmlChar *) "nøne");
    if (no == 3) return((const xmlChar *) " 2ab ");
    return(NULL);
}
static void des_const_xmlChar_ptr(int no ATTRIBUTE_UNUSED, const xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_filepath 8

static const char *gen_filepath(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    if (no == 3) return("test/valid/REC-xml-19980210.xml");
    if (no == 4) return("test/valid/dtds/xhtml1-strict.dtd");
    if (no == 5) return("http://missing.example.org/");
    if (no == 6) return("http://missing. example.org/");
    return(NULL);
}
static void des_filepath(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_fileoutput 6

static const char *gen_fileoutput(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("/missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("ftp://missing.example.org/foo");
    if (no == 3) return("http://missing.example.org/");
    if (no == 4) return("http://missing. example.org/");
    return(NULL);
}
static void des_fileoutput(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserCtxtPtr 2
static xmlParserCtxtPtr gen_xmlParserCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewParserCtxt());
    return(NULL);
}
static void des_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlParserCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlFreeParserCtxt(val);
}

#define gen_nb_xmlSAXHandlerPtr 2
static xmlSAXHandlerPtr gen_xmlSAXHandlerPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((xmlSAXHandlerPtr) &xmlDefaultSAXHandler);
    return(NULL);
}
static void des_xmlSAXHandlerPtr(int no ATTRIBUTE_UNUSED, xmlSAXHandlerPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlValidCtxtPtr 2
static xmlValidCtxtPtr gen_xmlValidCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewValidCtxt());
    return(NULL);
}
static void des_xmlValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlValidCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlFreeValidCtxt(val);
}

#define gen_nb_xmlParserInputBufferPtr 8

static xmlParserInputBufferPtr gen_xmlParserInputBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlParserInputBufferCreateFilename("missing.xml", XML_CHAR_ENCODING_NONE));
    if (no == 1) return(xmlParserInputBufferCreateFilename("<foo/>", XML_CHAR_ENCODING_NONE));
    if (no == 2) return(xmlParserInputBufferCreateFilename("test/ent2", XML_CHAR_ENCODING_NONE));
    if (no == 3) return(xmlParserInputBufferCreateFilename("test/valid/REC-xml-19980210.xml", XML_CHAR_ENCODING_NONE));
    if (no == 4) return(xmlParserInputBufferCreateFilename("test/valid/dtds/xhtml1-strict.dtd", XML_CHAR_ENCODING_NONE));
    if (no == 5) return(xmlParserInputBufferCreateFilename("http://missing.example.org/", XML_CHAR_ENCODING_NONE));
    if (no == 6) return(xmlParserInputBufferCreateFilename("http://missing. example.org/", XML_CHAR_ENCODING_NONE));
    return(NULL);
}
static void des_xmlParserInputBufferPtr(int no ATTRIBUTE_UNUSED, xmlParserInputBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    xmlFreeParserInputBuffer(val);
}

#define gen_nb_xmlDocPtr 3
static xmlDocPtr gen_xmlDocPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewDoc(BAD_CAST "1.0"));
    if (no == 1) return(xmlReadMemory("<foo/>", 6, "test", NULL, 0));
    return(NULL);
}
static void des_xmlDocPtr(int no ATTRIBUTE_UNUSED, xmlDocPtr val, int nr ATTRIBUTE_UNUSED) {
    if ((val != NULL) && (val != api_doc) && (val->doc != api_doc))
        xmlFreeDoc(val);
}

#define gen_nb_xmlAttrPtr 2
static xmlAttrPtr gen_xmlAttrPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(get_api_attr());
    return(NULL);
}
static void des_xmlAttrPtr(int no, xmlAttrPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) free_api_doc();
}

#define gen_nb_xmlDictPtr 2
static xmlDictPtr gen_xmlDictPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlDictCreate());
    return(NULL);
}
static void des_xmlDictPtr(int no ATTRIBUTE_UNUSED, xmlDictPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlDictFree(val);
}

#define gen_nb_xmlNodePtr 3
static xmlNodePtr gen_xmlNodePtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    if (no == 1) return(get_api_root());
    return(NULL);
/*     if (no == 2) return((xmlNodePtr) get_api_doc()); */
}
static void des_xmlNodePtr(int no ATTRIBUTE_UNUSED, xmlNodePtr val, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) free_api_doc();
    else if (val != NULL) {
        xmlUnlinkNode(val);
        xmlFreeNode(val);
    }
}

#define gen_nb_xmlNodePtr_in 3
static xmlNodePtr gen_xmlNodePtr_in(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    if (no == 0) return(xmlNewText(BAD_CAST "text"));
    return(NULL);
}
static void des_xmlNodePtr_in(int no ATTRIBUTE_UNUSED, xmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlTextWriterPtr 2
static xmlTextWriterPtr gen_xmlTextWriterPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewTextWriterFilename("test.out", 0));
    return(NULL);
}
static void des_xmlTextWriterPtr(int no ATTRIBUTE_UNUSED, xmlTextWriterPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) xmlFreeTextWriter(val);
}

#define gen_nb_xmlTextReaderPtr 4
static xmlTextReaderPtr gen_xmlTextReaderPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewTextReaderFilename("test/ent2"));
    if (no == 1) return(xmlNewTextReaderFilename("test/valid/REC-xml-19980210.xml"));
    if (no == 2) return(xmlNewTextReaderFilename("test/valid/dtds/xhtml1-strict.dtd"));
    return(NULL);
}
static void des_xmlTextReaderPtr(int no ATTRIBUTE_UNUSED, xmlTextReaderPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) xmlFreeTextReader(val);
}

#define gen_nb_xmlBufferPtr 3
static xmlBufferPtr gen_xmlBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlBufferCreate());
    if (no == 1) return(xmlBufferCreateStatic((void *)"a static buffer", 13));
    return(NULL);
}
static void des_xmlBufferPtr(int no ATTRIBUTE_UNUSED, xmlBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlBufferFree(val);
    }
}

#define gen_nb_xmlListPtr 2
static xmlListPtr gen_xmlListPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlListCreate(NULL, NULL));
    return(NULL);
}
static void des_xmlListPtr(int no ATTRIBUTE_UNUSED, xmlListPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlListDelete(val);
    }
}

#define gen_nb_xmlHashTablePtr 2
static xmlHashTablePtr gen_xmlHashTablePtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlHashCreate(10));
    return(NULL);
}
static void des_xmlHashTablePtr(int no ATTRIBUTE_UNUSED, xmlHashTablePtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlHashFree(val, NULL);
    }
}

#include <libxml/xpathInternals.h>

#define gen_nb_xmlXPathObjectPtr 5
static xmlXPathObjectPtr gen_xmlXPathObjectPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlXPathNewString(BAD_CAST "string object"));
    if (no == 1) return(xmlXPathNewFloat(1.1));
    if (no == 2) return(xmlXPathNewBoolean(1));
    if (no == 3) return(xmlXPathNewNodeSet(NULL));
    return(NULL);
}
static void des_xmlXPathObjectPtr(int no ATTRIBUTE_UNUSED, xmlXPathObjectPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlXPathFreeObject(val);
    }
}

#define gen_nb_xmlOutputBufferPtr 2
static xmlOutputBufferPtr gen_xmlOutputBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlOutputBufferCreateFilename("test.out", NULL, 0));
    return(NULL);
}
static void des_xmlOutputBufferPtr(int no ATTRIBUTE_UNUSED, xmlOutputBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlOutputBufferClose(val);
    }
}

#define gen_nb_xmlCharEncoding 4
static xmlCharEncoding gen_xmlCharEncoding(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(XML_CHAR_ENCODING_UTF8);
    if (no == 1) return(XML_CHAR_ENCODING_NONE);
    if (no == 0) return(XML_CHAR_ENCODING_8859_1);
    return(XML_CHAR_ENCODING_ERROR);
}
static void des_xmlCharEncoding(int no ATTRIBUTE_UNUSED, xmlCharEncoding val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}


static void desret_int(int val ATTRIBUTE_UNUSED) {
}
static void desret_long(long val ATTRIBUTE_UNUSED) {
}
static void desret_double(double val ATTRIBUTE_UNUSED) {
}
static void desret_xmlCharEncoding(xmlCharEncoding val ATTRIBUTE_UNUSED) {
}
#if 0
static void desret_const_void_ptr(void *val ATTRIBUTE_UNUSED) {
}
#endif
static void desret_void_ptr(void *val ATTRIBUTE_UNUSED) {
}
static void desret_const_char_ptr(const char *val ATTRIBUTE_UNUSED) {
}
static void desret_const_xmlChar_ptr(const xmlChar *val ATTRIBUTE_UNUSED) {
}
static void desret_xmlChar_ptr(xmlChar *val) {
    if (val != NULL)
	xmlFree(val);
}
static void desret_xmlDocPtr(xmlDocPtr val) {
    if (val != api_doc)
	xmlFreeDoc(val);
}
static void desret_xmlDictPtr(xmlDictPtr val) {
    xmlDictFree(val);
}
static void desret_xmlTextReaderPtr(xmlTextReaderPtr val) {
    xmlFreeTextReader(val);
}
static void desret_xmlNodePtr(xmlNodePtr val) {
    if ((val != NULL) && (val != api_root) && (val != (xmlNodePtr) api_doc)) {
	xmlUnlinkNode(val);
	xmlFreeNode(val);
    }
}
static void desret_xmlDtdPtr(xmlDtdPtr val) {
    desret_xmlNodePtr((xmlNodePtr)val);
}
static void desret_xmlXPathObjectPtr(xmlXPathObjectPtr val) {
    xmlXPathFreeObject(val);
}
static void desret_xmlParserCtxtPtr(xmlParserCtxtPtr val) {
    xmlFreeParserCtxt(val);
}

/* CUT HERE: everything below that line is generated */
#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/catalog.h>
#include <libxml/chvalid.h>
#include <libxml/dict.h>
#include <libxml/encoding.h>
#include <libxml/entities.h>
#include <libxml/hash.h>
#include <libxml/list.h>
#include <libxml/nanoftp.h>
#include <libxml/nanohttp.h>
#include <libxml/parser.h>
#include <libxml/pattern.h>
#include <libxml/relaxng.h>
#include <libxml/schemasInternals.h>
#include <libxml/tree.h>
#include <libxml/uri.h>
#include <libxml/valid.h>
#include <libxml/xinclude.h>
#include <libxml/xmlIO.h>
#include <libxml/xmlerror.h>
#include <libxml/xmlreader.h>
#include <libxml/xmlsave.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>
#include <libxml/xmlstring.h>
#include <libxml/xmlwriter.h>
#include <libxml/xpath.h>
#include <libxml/xpointer.h>
static int test_HTMLparser(void);
static int test_HTMLtree(void);
static int test_catalog(void);
static int test_chvalid(void);
static int test_dict(void);
static int test_encoding(void);
static int test_entities(void);
static int test_hash(void);
static int test_list(void);
static int test_nanoftp(void);
static int test_nanohttp(void);
static int test_parser(void);
static int test_pattern(void);
static int test_relaxng(void);
static int test_schemasInternals(void);
static int test_tree(void);
static int test_uri(void);
static int test_valid(void);
static int test_xinclude(void);
static int test_xmlIO(void);
static int test_xmlerror(void);
static int test_xmlreader(void);
static int test_xmlsave(void);
static int test_xmlschemas(void);
static int test_xmlschemastypes(void);
static int test_xmlstring(void);
static int test_xmlwriter(void);
static int test_xpath(void);
static int test_xpointer(void);

/**
 * testlibxml2:
 *
 * Main entry point of the tester for the full libxml2 module,
 * it calls all the tester entry point for each module.
 *
 * Returns the number of error found
 */
static int
testlibxml2(void)
{
    int ret = 0;

    ret += test_HTMLparser();
    ret += test_HTMLtree();
    ret += test_catalog();
    ret += test_chvalid();
    ret += test_dict();
    ret += test_encoding();
    ret += test_entities();
    ret += test_hash();
    ret += test_list();
    ret += test_nanoftp();
    ret += test_nanohttp();
    ret += test_parser();
    ret += test_pattern();
    ret += test_relaxng();
    ret += test_schemasInternals();
    ret += test_tree();
    ret += test_uri();
    ret += test_valid();
    ret += test_xinclude();
    ret += test_xmlIO();
    ret += test_xmlerror();
    ret += test_xmlreader();
    ret += test_xmlsave();
    ret += test_xmlschemas();
    ret += test_xmlschemastypes();
    ret += test_xmlstring();
    ret += test_xmlwriter();
    ret += test_xpath();
    ret += test_xpointer();

    printf("Total: %d functions, %d tests, %d errors\n",
           function_tests, call_tests, ret);
    return(ret);
}


static int
test_UTF8ToHtml(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlAttrAllowed(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlAutoCloseTag(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the HTML document */
    int n_doc;
    const xmlChar * name; /* The tag name */
    int n_name;
    htmlNodePtr elem; /* the HTML element */
    int n_elem;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = htmlAutoCloseTag(doc, name, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlAutoCloseTag",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCreateMemoryParserCtxt(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ret_val;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = htmlCreateMemoryParserCtxt(buffer, size);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCreateMemoryParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCreatePushParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlCtxtReadDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = htmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_cur, cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtReadFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = htmlCtxtReadFile(ctxt, filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtReadMemory(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_int(n_options, 5);

        ret_val = htmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtReset(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        htmlCtxtReset(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtUseOptions(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        options = gen_int(n_options, 1);

        ret_val = htmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtUseOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlElementAllowedHere(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlElementStatusHere(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlEncodeEntities(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlEntityLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlEntityValueLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlHandleOmittedElem(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = htmlHandleOmittedElem(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlHandleOmittedElem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlIsAutoClosed(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the HTML document */
    int n_doc;
    htmlNodePtr elem; /* the HTML element */
    int n_elem;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);

        ret_val = htmlIsAutoClosed(doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsAutoClosed",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlIsScriptAttribute(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * name; /* an attribute name */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = htmlIsScriptAttribute(name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsScriptAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeStatus(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlParseCharRef(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = htmlParseCharRef(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseCharRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseChunk(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const char * chunk; /* an char array */
    int n_chunk;
    int size; /* the size in byte of the chunk */
    int n_size;
    int terminate; /* last chunk indicator */
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        terminate = gen_int(n_terminate, 3);

        ret_val = htmlParseChunk(ctxt, chunk, size, terminate);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, chunk, 1);
        des_int(n_size, size, 2);
        des_int(n_terminate, terminate, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseChunk",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;
    const char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);

        ret_val = htmlParseDoc(cur, encoding);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseDocument(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = htmlParseDocument(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseElement(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        htmlParseElement(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseEntityRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlParseFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    htmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;
    const char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);

        ret_val = htmlParseFile(filename, encoding);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        xmlResetLastError();
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlReadDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = htmlReadDoc(cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlReadFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_int(n_options, 2);

        ret_val = htmlReadFile(filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlReadMemory(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = htmlReadMemory(buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSAXParseDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlSAXParseFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlTagLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_HTMLparser(void) {
    int ret = 0;

    printf("Testing HTMLparser : 19 of 37 functions ...\n");
    ret += test_UTF8ToHtml();
    ret += test_htmlAttrAllowed();
    ret += test_htmlAutoCloseTag();
    ret += test_htmlCreateMemoryParserCtxt();
    ret += test_htmlCreatePushParserCtxt();
    ret += test_htmlCtxtReadDoc();
    ret += test_htmlCtxtReadFile();
    ret += test_htmlCtxtReadMemory();
    ret += test_htmlCtxtReset();
    ret += test_htmlCtxtUseOptions();
    ret += test_htmlElementAllowedHere();
    ret += test_htmlElementStatusHere();
    ret += test_htmlEncodeEntities();
    ret += test_htmlEntityLookup();
    ret += test_htmlEntityValueLookup();
    ret += test_htmlHandleOmittedElem();
    ret += test_htmlIsAutoClosed();
    ret += test_htmlIsScriptAttribute();
    ret += test_htmlNodeStatus();
    ret += test_htmlParseCharRef();
    ret += test_htmlParseChunk();
    ret += test_htmlParseDoc();
    ret += test_htmlParseDocument();
    ret += test_htmlParseElement();
    ret += test_htmlParseEntityRef();
    ret += test_htmlParseFile();
    ret += test_htmlReadDoc();
    ret += test_htmlReadFile();
    ret += test_htmlReadMemory();
    ret += test_htmlSAXParseDoc();
    ret += test_htmlSAXParseFile();
    ret += test_htmlTagLookup();

    if (ret != 0)
	printf("Module HTMLparser: %d errors\n", ret);
    return(ret);
}

static int
test_htmlDocContentDumpFormatOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the encoding string */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        htmlDocContentDumpFormatOutput(buf, cur, encoding, format);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocContentDumpFormatOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlDocContentDumpOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the encoding string */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        htmlDocContentDumpOutput(buf, cur, encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocContentDumpOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlDocDump(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * f; /* the FILE* */
    int n_f;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = htmlDocDump(f, cur);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlDocDumpMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlGetMetaEncoding(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    htmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = htmlGetMetaEncoding(doc);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlGetMetaEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlIsBooleanAttr(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * name; /* the name of the attribute to check */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = htmlIsBooleanAttr(name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsBooleanAttr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNewDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const xmlChar * URI; /* URI for the dtd, or NULL */
    int n_URI;
    const xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
    int n_ExternalID;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);

        ret_val = htmlNewDoc(URI, ExternalID);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNewDocNoDtD(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const xmlChar * URI; /* URI for the dtd, or NULL */
    int n_URI;
    const xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
    int n_ExternalID;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);

        ret_val = htmlNewDocNoDtD(URI, ExternalID);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDocNoDtD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDump(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        ret_val = htmlNodeDump(buf, doc, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * out; /* the FILE pointer */
    int n_out;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;

    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        htmlNodeDumpFile(out, doc, cur);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpFileFormat(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * out; /* the FILE pointer */
    int n_out;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    const char * encoding; /* the document encoding */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        format = gen_int(n_format, 4);

        ret_val = htmlNodeDumpFileFormat(out, doc, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFileFormat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpFormatOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    const char * encoding; /* the encoding string */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        format = gen_int(n_format, 4);

        htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFormatOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    const char * encoding; /* the encoding string */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);

        htmlNodeDumpOutput(buf, doc, cur, encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSaveFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = htmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSaveFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the document encoding */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = htmlSaveFileEnc(filename, cur, encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSaveFileFormat(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the document encoding */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = htmlSaveFileFormat(filename, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileFormat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSetMetaEncoding(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * encoding; /* the encoding string */
    int n_encoding;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_xmlChar_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        encoding = gen_const_xmlChar_ptr(n_encoding, 1);

        ret_val = htmlSetMetaEncoding(doc, encoding);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_encoding, encoding, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSetMetaEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_HTMLtree(void) {
    int ret = 0;

    printf("Testing HTMLtree : 16 of 17 functions ...\n");
    ret += test_htmlDocContentDumpFormatOutput();
    ret += test_htmlDocContentDumpOutput();
    ret += test_htmlDocDump();
    ret += test_htmlDocDumpMemory();
    ret += test_htmlGetMetaEncoding();
    ret += test_htmlIsBooleanAttr();
    ret += test_htmlNewDoc();
    ret += test_htmlNewDocNoDtD();
    ret += test_htmlNodeDump();
    ret += test_htmlNodeDumpFile();
    ret += test_htmlNodeDumpFileFormat();
    ret += test_htmlNodeDumpFormatOutput();
    ret += test_htmlNodeDumpOutput();
    ret += test_htmlSaveFile();
    ret += test_htmlSaveFileEnc();
    ret += test_htmlSaveFileFormat();
    ret += test_htmlSetMetaEncoding();

    if (ret != 0)
	printf("Module HTMLtree: %d errors\n", ret);
    return(ret);
}

static int
test_xmlACatalogAdd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogRemove(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolve(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolvePublic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolveSystem(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolveURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogAdd(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * type; /* the type of record to add to the catalog */
    int n_type;
    const xmlChar * orig; /* the system, public or prefix to match */
    int n_orig;
    const xmlChar * replace; /* the replacement value for the match */
    int n_replace;

    for (n_type = 0;n_type < gen_nb_const_xmlChar_ptr;n_type++) {
    for (n_orig = 0;n_orig < gen_nb_const_xmlChar_ptr;n_orig++) {
    for (n_replace = 0;n_replace < gen_nb_const_xmlChar_ptr;n_replace++) {
        mem_base = xmlMemBlocks();
        type = gen_const_xmlChar_ptr(n_type, 0);
        orig = gen_const_xmlChar_ptr(n_orig, 1);
        replace = gen_const_xmlChar_ptr(n_replace, 2);

        ret_val = xmlCatalogAdd(type, orig, replace);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_type, type, 0);
        des_const_xmlChar_ptr(n_orig, orig, 1);
        des_const_xmlChar_ptr(n_replace, replace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogAdd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_orig);
            printf(" %d", n_replace);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogCleanup(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED


        xmlCatalogCleanup();
        call_tests++;
        xmlResetLastError();
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogConvert(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;


        ret_val = xmlCatalogConvert();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogDump(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * out; /* the file. */
    int n_out;

    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);

        xmlCatalogDump(out);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogGetDefaults(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogIsEmpty(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogLocalResolve(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    void * catalogs; /* a document's list of catalogs */
    int n_catalogs;
    const xmlChar * pubID; /* the public ID string */
    int n_pubID;
    const xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_catalogs = 0;n_catalogs < gen_nb_void_ptr;n_catalogs++) {
    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        catalogs = gen_void_ptr(n_catalogs, 0);
        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
        sysID = gen_const_xmlChar_ptr(n_sysID, 2);

        ret_val = xmlCatalogLocalResolve(catalogs, pubID, sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_catalogs, catalogs, 0);
        des_const_xmlChar_ptr(n_pubID, pubID, 1);
        des_const_xmlChar_ptr(n_sysID, sysID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogLocalResolve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catalogs);
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogLocalResolveURI(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    void * catalogs; /* a document's list of catalogs */
    int n_catalogs;
    const xmlChar * URI; /* the URI */
    int n_URI;

    for (n_catalogs = 0;n_catalogs < gen_nb_void_ptr;n_catalogs++) {
    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
        mem_base = xmlMemBlocks();
        catalogs = gen_void_ptr(n_catalogs, 0);
        URI = gen_const_xmlChar_ptr(n_URI, 1);

        ret_val = xmlCatalogLocalResolveURI(catalogs, URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_catalogs, catalogs, 0);
        des_const_xmlChar_ptr(n_URI, URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogLocalResolveURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catalogs);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogRemove(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;
    const xmlChar * value; /* the value to remove */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlCatalogRemove(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolve(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * pubID; /* the public ID string */
    int n_pubID;
    const xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID, 0);
        sysID = gen_const_xmlChar_ptr(n_sysID, 1);

        ret_val = xmlCatalogResolve(pubID, sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, pubID, 0);
        des_const_xmlChar_ptr(n_sysID, sysID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolvePublic(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * pubID; /* the public ID string */
    int n_pubID;

    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID, 0);

        ret_val = xmlCatalogResolvePublic(pubID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, pubID, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolvePublic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pubID);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolveSystem(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        sysID = gen_const_xmlChar_ptr(n_sysID, 0);

        ret_val = xmlCatalogResolveSystem(sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_sysID, sysID, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveSystem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolveURI(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * URI; /* the URI */
    int n_URI;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);

        ret_val = xmlCatalogResolveURI(URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogSetDebug(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    int level; /* the debug level of catalogs required */
    int n_level;

    for (n_level = 0;n_level < gen_nb_int;n_level++) {
        mem_base = xmlMemBlocks();
        level = gen_int(n_level, 0);

        ret_val = xmlCatalogSetDebug(level);
        desret_int(ret_val);
        call_tests++;
        des_int(n_level, level, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogSetDebug",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_level);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogSetDefaultPrefer(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogSetDefaults(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlConvertSGMLCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlInitializeCatalog(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializeCatalog();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializeCatalog",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlLoadACatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlLoadCatalog(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;
    const char * filename; /* a file path */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlLoadCatalog(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlLoadCatalogs(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    const char * pathss; /* a list of directories separated by a colon or a space. */
    int n_pathss;

    for (n_pathss = 0;n_pathss < gen_nb_const_char_ptr;n_pathss++) {
        pathss = gen_const_char_ptr(n_pathss, 0);

        xmlLoadCatalogs(pathss);
        call_tests++;
        des_const_char_ptr(n_pathss, pathss, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlLoadSGMLSuperCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseCatalogFile(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseCatalogFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCatalogFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_catalog(void) {
    int ret = 0;

    printf("Testing catalog : 16 of 36 functions ...\n");
    ret += test_xmlACatalogAdd();
    ret += test_xmlACatalogDump();
    ret += test_xmlACatalogRemove();
    ret += test_xmlACatalogResolve();
    ret += test_xmlACatalogResolvePublic();
    ret += test_xmlACatalogResolveSystem();
    ret += test_xmlACatalogResolveURI();
    ret += test_xmlCatalogAdd();
    ret += test_xmlCatalogCleanup();
    ret += test_xmlCatalogConvert();
    ret += test_xmlCatalogDump();
    ret += test_xmlCatalogGetDefaults();
    ret += test_xmlCatalogIsEmpty();
    ret += test_xmlCatalogLocalResolve();
    ret += test_xmlCatalogLocalResolveURI();
    ret += test_xmlCatalogRemove();
    ret += test_xmlCatalogResolve();
    ret += test_xmlCatalogResolvePublic();
    ret += test_xmlCatalogResolveSystem();
    ret += test_xmlCatalogResolveURI();
    ret += test_xmlCatalogSetDebug();
    ret += test_xmlCatalogSetDefaultPrefer();
    ret += test_xmlCatalogSetDefaults();
    ret += test_xmlConvertSGMLCatalog();
    ret += test_xmlInitializeCatalog();
    ret += test_xmlLoadACatalog();
    ret += test_xmlLoadCatalog();
    ret += test_xmlLoadCatalogs();
    ret += test_xmlLoadSGMLSuperCatalog();
    ret += test_xmlNewCatalog();
    ret += test_xmlParseCatalogFile();

    if (ret != 0)
	printf("Module catalog: %d errors\n", ret);
    return(ret);
}

static int
test_xmlCharInRange(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsBaseChar(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsBaseChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBaseChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsBlank(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsBlank(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBlank",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsChar(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsCombining(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsCombining(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsCombining",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsDigit(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsDigit(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsDigit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsExtender(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsExtender(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsExtender",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsIdeographic(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsIdeographic(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsIdeographic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsPubidChar(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsPubidChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsPubidChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}

static int
test_chvalid(void) {
    int ret = 0;

    printf("Testing chvalid : 8 of 9 functions ...\n");
    ret += test_xmlCharInRange();
    ret += test_xmlIsBaseChar();
    ret += test_xmlIsBlank();
    ret += test_xmlIsChar();
    ret += test_xmlIsCombining();
    ret += test_xmlIsDigit();
    ret += test_xmlIsExtender();
    ret += test_xmlIsIdeographic();
    ret += test_xmlIsPubidChar();

    if (ret != 0)
	printf("Module chvalid: %d errors\n", ret);
    return(ret);
}

static int
test_xmlDictCreate(void) {
    int ret = 0;

    int mem_base;
    xmlDictPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlDictCreate();
        desret_xmlDictPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictCreate",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlDictCreateSub(void) {
    int ret = 0;

    int mem_base;
    xmlDictPtr ret_val;
    xmlDictPtr sub; /* an existing dictionnary */
    int n_sub;

    for (n_sub = 0;n_sub < gen_nb_xmlDictPtr;n_sub++) {
        mem_base = xmlMemBlocks();
        sub = gen_xmlDictPtr(n_sub, 0);

        ret_val = xmlDictCreateSub(sub);
        desret_xmlDictPtr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_sub, sub, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictCreateSub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sub);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictLookup(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    int len; /* the length of the name, if -1 it is recomputed */
    int n_len;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlDictLookup(dict, name, len);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf(" %d", n_name);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictOwns(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;
    const xmlChar * str; /* the string */
    int n_str;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlDictOwns(dict, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictOwns",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictQLookup(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;
    const xmlChar * prefix; /* the prefix */
    int n_prefix;
    const xmlChar * name; /* the name */
    int n_name;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlDictQLookup(dict, prefix, name);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictQLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictReference(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);

        ret_val = xmlDictReference(dict);
        xmlDictFree(dict);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictReference",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictSize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);

        ret_val = xmlDictSize(dict);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictSize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}

static int
test_dict(void) {
    int ret = 0;

    printf("Testing dict : 7 of 8 functions ...\n");
    ret += test_xmlDictCreate();
    ret += test_xmlDictCreateSub();
    ret += test_xmlDictLookup();
    ret += test_xmlDictOwns();
    ret += test_xmlDictQLookup();
    ret += test_xmlDictReference();
    ret += test_xmlDictSize();

    if (ret != 0)
	printf("Module dict: %d errors\n", ret);
    return(ret);
}

static int
test_UTF8Toisolat1(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_isolat1ToUTF8(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddEncodingAlias(void) {
    int ret = 0;

    int ret_val;
    const char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
    int n_name;
    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        name = gen_const_char_ptr(n_name, 0);
        alias = gen_const_char_ptr(n_alias, 1);

        ret_val = xmlAddEncodingAlias(name, alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_name, name, 0);
        des_const_char_ptr(n_alias, alias, 1);
        xmlResetLastError();
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCharEncCloseFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCharEncFirstLine(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCharEncInFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCharEncOutFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCleanupCharEncodingHandlers(void) {
    int ret = 0;



        xmlCleanupCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();

    function_tests++;
    return(ret);
}


static int
test_xmlCleanupEncodingAliases(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupEncodingAliases();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupEncodingAliases",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlDelEncodingAlias(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0);

        ret_val = xmlDelEncodingAlias(alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, alias, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDelEncodingAlias",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDetectCharEncoding(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlFindCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCharEncodingName(void) {
    int ret = 0;

    int mem_base;
    const char * ret_val;
    xmlCharEncoding enc; /* the encoding */
    int n_enc;

    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        enc = gen_xmlCharEncoding(n_enc, 0);

        ret_val = xmlGetCharEncodingName(enc);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlCharEncoding(n_enc, enc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetCharEncodingName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_enc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetEncodingAlias(void) {
    int ret = 0;

    int mem_base;
    const char * ret_val;
    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0);

        ret_val = xmlGetEncodingAlias(alias);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, alias, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetEncodingAlias",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlInitCharEncodingHandlers(void) {
    int ret = 0;



        xmlInitCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();

    function_tests++;
    return(ret);
}


static int
test_xmlNewCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseCharEncoding(void) {
    int ret = 0;

    int mem_base;
    xmlCharEncoding ret_val;
    const char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_char_ptr(n_name, 0);

        ret_val = xmlParseCharEncoding(name);
        desret_xmlCharEncoding(ret_val);
        call_tests++;
        des_const_char_ptr(n_name, name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCharEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_encoding(void) {
    int ret = 0;

    printf("Testing encoding : 8 of 19 functions ...\n");
    ret += test_UTF8Toisolat1();
    ret += test_isolat1ToUTF8();
    ret += test_xmlAddEncodingAlias();
    ret += test_xmlCharEncCloseFunc();
    ret += test_xmlCharEncFirstLine();
    ret += test_xmlCharEncInFunc();
    ret += test_xmlCharEncOutFunc();
    ret += test_xmlCleanupCharEncodingHandlers();
    ret += test_xmlCleanupEncodingAliases();
    ret += test_xmlDelEncodingAlias();
    ret += test_xmlDetectCharEncoding();
    ret += test_xmlFindCharEncodingHandler();
    ret += test_xmlGetCharEncodingHandler();
    ret += test_xmlGetCharEncodingName();
    ret += test_xmlGetEncodingAlias();
    ret += test_xmlInitCharEncodingHandlers();
    ret += test_xmlNewCharEncodingHandler();
    ret += test_xmlParseCharEncoding();
    ret += test_xmlRegisterCharEncodingHandler();

    if (ret != 0)
	printf("Module encoding: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddDocEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddDtdEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCleanupPredefinedEntities(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupPredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupPredefinedEntities",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpEntityDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlEncodeEntitiesReentrant(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document containing the string */
    int n_doc;
    const xmlChar * input; /* A string to convert to XML. */
    int n_input;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        input = gen_const_xmlChar_ptr(n_input, 1);

        ret_val = xmlEncodeEntitiesReentrant(doc, input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_input, input, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeEntitiesReentrant",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlEncodeSpecialChars(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document containing the string */
    int n_doc;
    const xmlChar * input; /* A string to convert to XML. */
    int n_input;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        input = gen_const_xmlChar_ptr(n_input, 1);

        ret_val = xmlEncodeSpecialChars(doc, input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_input, input, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeSpecialChars",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetDocEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetParameterEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetPredefinedEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlInitializePredefinedEntities(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializePredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializePredefinedEntities",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}

static int
test_entities(void) {
    int ret = 0;

    printf("Testing entities : 4 of 16 functions ...\n");
    ret += test_xmlAddDocEntity();
    ret += test_xmlAddDtdEntity();
    ret += test_xmlCleanupPredefinedEntities();
    ret += test_xmlCopyEntitiesTable();
    ret += test_xmlCreateEntitiesTable();
    ret += test_xmlDumpEntitiesTable();
    ret += test_xmlDumpEntityDecl();
    ret += test_xmlEncodeEntitiesReentrant();
    ret += test_xmlEncodeSpecialChars();
    ret += test_xmlGetDocEntity();
    ret += test_xmlGetDtdEntity();
    ret += test_xmlGetParameterEntity();
    ret += test_xmlGetPredefinedEntity();
    ret += test_xmlInitializePredefinedEntities();

    if (ret != 0)
	printf("Module entities: %d errors\n", ret);
    return(ret);
}

static int
test_xmlHashAddEntry(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    void * userdata; /* a pointer to the userdata */
    int n_userdata;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        userdata = gen_userdata(n_userdata, 2);

        ret_val = xmlHashAddEntry(table, name, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_userdata(n_userdata, userdata, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashAddEntry2(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    const xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    void * userdata; /* a pointer to the userdata */
    int n_userdata;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        userdata = gen_userdata(n_userdata, 3);

        ret_val = xmlHashAddEntry2(table, name, name2, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        des_userdata(n_userdata, userdata, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry2",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashAddEntry3(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    const xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    const xmlChar * name3; /* a third name of the userdata */
    int n_name3;
    void * userdata; /* a pointer to the userdata */
    int n_userdata;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);
        userdata = gen_userdata(n_userdata, 4);

        ret_val = xmlHashAddEntry3(table, name, name2, name3, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        des_const_xmlChar_ptr(n_name3, name3, 3);
        des_userdata(n_userdata, userdata, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashCopy(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashLookup(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * name; /* the name of the userdata */
    int n_name;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlHashLookup(table, name);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashLookup2(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    const xmlChar * name2; /* a second name of the userdata */
    int n_name2;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);

        ret_val = xmlHashLookup2(table, name, name2);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup2",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashLookup3(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    const xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    const xmlChar * name3; /* a third name of the userdata */
    int n_name3;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);

        ret_val = xmlHashLookup3(table, name, name2, name3);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        des_const_xmlChar_ptr(n_name3, name3, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashQLookup(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * prefix; /* the prefix of the userdata */
    int n_prefix;
    const xmlChar * name; /* the name of the userdata */
    int n_name;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlHashQLookup(table, prefix, name);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashQLookup2(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * prefix; /* the prefix of the userdata */
    int n_prefix;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    const xmlChar * prefix2; /* the second prefix of the userdata */
    int n_prefix2;
    const xmlChar * name2; /* a second name of the userdata */
    int n_name2;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_prefix2 = 0;n_prefix2 < gen_nb_const_xmlChar_ptr;n_prefix2++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
        name2 = gen_const_xmlChar_ptr(n_name2, 4);

        ret_val = xmlHashQLookup2(table, prefix, name, prefix2, name2);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_prefix2, prefix2, 3);
        des_const_xmlChar_ptr(n_name2, name2, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup2",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_prefix2);
            printf(" %d", n_name2);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashQLookup3(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    const xmlChar * prefix; /* the prefix of the userdata */
    int n_prefix;
    const xmlChar * name; /* the name of the userdata */
    int n_name;
    const xmlChar * prefix2; /* the second prefix of the userdata */
    int n_prefix2;
    const xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    const xmlChar * prefix3; /* the third prefix of the userdata */
    int n_prefix3;
    const xmlChar * name3; /* a third name of the userdata */
    int n_name3;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_prefix2 = 0;n_prefix2 < gen_nb_const_xmlChar_ptr;n_prefix2++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_prefix3 = 0;n_prefix3 < gen_nb_const_xmlChar_ptr;n_prefix3++) {
    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
        name2 = gen_const_xmlChar_ptr(n_name2, 4);
        prefix3 = gen_const_xmlChar_ptr(n_prefix3, 5);
        name3 = gen_const_xmlChar_ptr(n_name3, 6);

        ret_val = xmlHashQLookup3(table, prefix, name, prefix2, name2, prefix3, name3);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_prefix2, prefix2, 3);
        des_const_xmlChar_ptr(n_name2, name2, 4);
        des_const_xmlChar_ptr(n_prefix3, prefix3, 5);
        des_const_xmlChar_ptr(n_name3, name3, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_prefix2);
            printf(" %d", n_name2);
            printf(" %d", n_prefix3);
            printf(" %d", n_name3);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashRemoveEntry(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashRemoveEntry2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashRemoveEntry3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScan(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScan3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScanFull(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScanFull3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashSize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);

        ret_val = xmlHashSize(table);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashSize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashUpdateEntry(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashUpdateEntry2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashUpdateEntry3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_hash(void) {
    int ret = 0;

    printf("Testing hash : 10 of 23 functions ...\n");
    ret += test_xmlHashAddEntry();
    ret += test_xmlHashAddEntry2();
    ret += test_xmlHashAddEntry3();
    ret += test_xmlHashCopy();
    ret += test_xmlHashCreate();
    ret += test_xmlHashLookup();
    ret += test_xmlHashLookup2();
    ret += test_xmlHashLookup3();
    ret += test_xmlHashQLookup();
    ret += test_xmlHashQLookup2();
    ret += test_xmlHashQLookup3();
    ret += test_xmlHashRemoveEntry();
    ret += test_xmlHashRemoveEntry2();
    ret += test_xmlHashRemoveEntry3();
    ret += test_xmlHashScan();
    ret += test_xmlHashScan3();
    ret += test_xmlHashScanFull();
    ret += test_xmlHashScanFull3();
    ret += test_xmlHashSize();
    ret += test_xmlHashUpdateEntry();
    ret += test_xmlHashUpdateEntry2();
    ret += test_xmlHashUpdateEntry3();

    if (ret != 0)
	printf("Module hash: %d errors\n", ret);
    return(ret);
}

static int
test_xmlLinkGetData(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListAppend(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* the data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListAppend(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListAppend",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListClear(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListClear(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListClear",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListCopy(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListDup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListEmpty(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        ret_val = xmlListEmpty(l);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListEmpty",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListEnd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListFront(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListInsert(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* the data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListInsert(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListInsert",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListMerge(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l1; /* the original list */
    int n_l1;
    xmlListPtr l2; /* the new list */
    int n_l2;

    for (n_l1 = 0;n_l1 < gen_nb_xmlListPtr;n_l1++) {
    for (n_l2 = 0;n_l2 < gen_nb_xmlListPtr;n_l2++) {
        mem_base = xmlMemBlocks();
        l1 = gen_xmlListPtr(n_l1, 0);
        l2 = gen_xmlListPtr(n_l2, 1);

        xmlListMerge(l1, l2);
        call_tests++;
        des_xmlListPtr(n_l1, l1, 0);
        des_xmlListPtr(n_l2, l2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListMerge",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l1);
            printf(" %d", n_l2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPopBack(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListPopBack(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPopBack",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPopFront(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListPopFront(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPopFront",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPushBack(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* new data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListPushBack(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPushBack",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPushFront(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* new data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListPushFront(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPushFront",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListRemoveAll(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* list data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveAll(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveAll",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListRemoveFirst(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* list data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveFirst(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveFirst",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListRemoveLast(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* list data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveLast(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveLast",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListReverse(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListReverse(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListReverse",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListReverseSearch(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* a search value */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListReverseSearch(l, data);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListReverseSearch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListReverseWalk(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListSearch(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* a search value */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListSearch(l, data);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSearch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListSize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        ret_val = xmlListSize(l);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListSort(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListSort(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSort",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListWalk(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_list(void) {
    int ret = 0;

    printf("Testing list : 17 of 26 functions ...\n");
    ret += test_xmlLinkGetData();
    ret += test_xmlListAppend();
    ret += test_xmlListClear();
    ret += test_xmlListCopy();
    ret += test_xmlListCreate();
    ret += test_xmlListDup();
    ret += test_xmlListEmpty();
    ret += test_xmlListEnd();
    ret += test_xmlListFront();
    ret += test_xmlListInsert();
    ret += test_xmlListMerge();
    ret += test_xmlListPopBack();
    ret += test_xmlListPopFront();
    ret += test_xmlListPushBack();
    ret += test_xmlListPushFront();
    ret += test_xmlListRemoveAll();
    ret += test_xmlListRemoveFirst();
    ret += test_xmlListRemoveLast();
    ret += test_xmlListReverse();
    ret += test_xmlListReverseSearch();
    ret += test_xmlListReverseWalk();
    ret += test_xmlListSearch();
    ret += test_xmlListSize();
    ret += test_xmlListSort();
    ret += test_xmlListWalk();

    if (ret != 0)
	printf("Module list: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNanoFTPCheckResponse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPCleanup(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCleanup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPCloseConnection(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPConnect(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPConnectTo(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * server; /* an FTP server name */
    int n_server;
    int port; /* the port (use 21 if 0) */
    int n_port;

    for (n_server = 0;n_server < gen_nb_const_char_ptr;n_server++) {
    for (n_port = 0;n_port < gen_nb_int;n_port++) {
        mem_base = xmlMemBlocks();
        server = gen_const_char_ptr(n_server, 0);
        port = gen_int(n_port, 1);

        ret_val = xmlNanoFTPConnectTo(server, port);
        desret_void_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_server, server, 0);
        des_int(n_port, port, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPConnectTo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_server);
            printf(" %d", n_port);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPCwd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPDele(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGetConnection(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGetResponse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGetSocket(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPInit(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPNewCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPOpen(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * URL; /* the URL to the resource */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);

        ret_val = xmlNanoFTPOpen(URL);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URL);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPProxy(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    const char * host; /* the proxy host name */
    int n_host;
    int port; /* the proxy port */
    int n_port;
    const char * user; /* the proxy user name */
    int n_user;
    const char * passwd; /* the proxy password */
    int n_passwd;
    int type; /* the type of proxy 1 for using SITE, 2 for USER a@b */
    int n_type;

    for (n_host = 0;n_host < gen_nb_const_char_ptr;n_host++) {
    for (n_port = 0;n_port < gen_nb_int;n_port++) {
    for (n_user = 0;n_user < gen_nb_const_char_ptr;n_user++) {
    for (n_passwd = 0;n_passwd < gen_nb_const_char_ptr;n_passwd++) {
    for (n_type = 0;n_type < gen_nb_int;n_type++) {
        host = gen_const_char_ptr(n_host, 0);
        port = gen_int(n_port, 1);
        user = gen_const_char_ptr(n_user, 2);
        passwd = gen_const_char_ptr(n_passwd, 3);
        type = gen_int(n_type, 4);

        xmlNanoFTPProxy(host, port, user, passwd, type);
        call_tests++;
        des_const_char_ptr(n_host, host, 0);
        des_int(n_port, port, 1);
        des_const_char_ptr(n_user, user, 2);
        des_const_char_ptr(n_passwd, passwd, 3);
        des_int(n_type, type, 4);
        xmlResetLastError();
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPQuit(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPScanProxy(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    const char * URL; /* The proxy URL used to initialize the proxy context */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        URL = gen_filepath(n_URL, 0);

        xmlNanoFTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPUpdateURL(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_nanoftp(void) {
    int ret = 0;

    printf("Testing nanoftp : 6 of 22 functions ...\n");
    ret += test_xmlNanoFTPCheckResponse();
    ret += test_xmlNanoFTPCleanup();
    ret += test_xmlNanoFTPClose();
    ret += test_xmlNanoFTPCloseConnection();
    ret += test_xmlNanoFTPConnect();
    ret += test_xmlNanoFTPConnectTo();
    ret += test_xmlNanoFTPCwd();
    ret += test_xmlNanoFTPDele();
    ret += test_xmlNanoFTPGet();
    ret += test_xmlNanoFTPGetConnection();
    ret += test_xmlNanoFTPGetResponse();
    ret += test_xmlNanoFTPGetSocket();
    ret += test_xmlNanoFTPInit();
    ret += test_xmlNanoFTPList();
    ret += test_xmlNanoFTPNewCtxt();
    ret += test_xmlNanoFTPOpen();
    ret += test_xmlNanoFTPProxy();
    ret += test_xmlNanoFTPQuit();
    ret += test_xmlNanoFTPRead();
    ret += test_xmlNanoFTPScanProxy();
    ret += test_xmlNanoFTPUpdateURL();

    if (ret != 0)
	printf("Module nanoftp: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNanoHTTPAuthHeader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPCleanup(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPCleanup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPContentLength(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPEncoding(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPFetch(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPInit(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPMethod(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPMethodRedir(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPMimeType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPOpen(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPOpenRedir(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPRedir(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPReturnCode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPSave(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    void * ctxt; /* the HTTP context */
    int n_ctxt;
    const char * filename; /* the filename where the content should be saved */
    int n_filename;

    for (n_ctxt = 0;n_ctxt < gen_nb_void_ptr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_void_ptr(n_ctxt, 0);
        filename = gen_fileoutput(n_filename, 1);

        ret_val = xmlNanoHTTPSave(ctxt, filename);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctxt, ctxt, 0);
        des_fileoutput(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPSave",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPScanProxy(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    const char * URL; /* The proxy URL used to initialize the proxy context */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        URL = gen_filepath(n_URL, 0);

        xmlNanoHTTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_nanohttp(void) {
    int ret = 0;

    printf("Testing nanohttp : 4 of 17 functions ...\n");
    ret += test_xmlNanoHTTPAuthHeader();
    ret += test_xmlNanoHTTPCleanup();
    ret += test_xmlNanoHTTPClose();
    ret += test_xmlNanoHTTPContentLength();
    ret += test_xmlNanoHTTPEncoding();
    ret += test_xmlNanoHTTPFetch();
    ret += test_xmlNanoHTTPInit();
    ret += test_xmlNanoHTTPMethod();
    ret += test_xmlNanoHTTPMethodRedir();
    ret += test_xmlNanoHTTPMimeType();
    ret += test_xmlNanoHTTPOpen();
    ret += test_xmlNanoHTTPOpenRedir();
    ret += test_xmlNanoHTTPRead();
    ret += test_xmlNanoHTTPRedir();
    ret += test_xmlNanoHTTPReturnCode();
    ret += test_xmlNanoHTTPSave();
    ret += test_xmlNanoHTTPScanProxy();

    if (ret != 0)
	printf("Module nanohttp: %d errors\n", ret);
    return(ret);
}

static int
test_xmlByteConsumed(void) {
    int ret = 0;

    int mem_base;
    long ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlByteConsumed(ctxt);
        desret_long(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlByteConsumed",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlClearNodeInfoSeq(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlClearParserCtxt(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlClearParserCtxt(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlClearParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCreateDocParserCtxt(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;
    const xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlCreateDocParserCtxt(cur);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateDocParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCreateIOParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreatePushParserCtxt(void) {
    int ret = 0;

#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    xmlParserCtxtPtr ret_val;
    xmlSAXHandlerPtr sax; /* a SAX handler */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks */
    int n_user_data;
    const char * chunk; /* a pointer to an array of chars */
    int n_chunk;
    int size; /* number of chars in the array */
    int n_size;
    const char * filename; /* an optional file name or URI */
    int n_filename;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        chunk = gen_const_char_ptr(n_chunk, 2);
        size = gen_int(n_size, 3);
        filename = gen_filepath(n_filename, 4);

        ret_val = xmlCreatePushParserCtxt(sax, user_data, chunk, size, filename);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_chunk, chunk, 2);
        des_int(n_size, size, 3);
        des_filepath(n_filename, filename, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreatePushParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReadDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_cur, cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReadFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlCtxtReadFile(ctxt, filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReadMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_int(n_options, 5);

        ret_val = xmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReset(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlCtxtReset(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtResetPush(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * chunk; /* a pointer to an array of chars */
    int n_chunk;
    int size; /* number of chars in the array */
    int n_size;
    const char * filename; /* an optional file name or URI */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        filename = gen_filepath(n_filename, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);

        ret_val = xmlCtxtResetPush(ctxt, chunk, size, filename, encoding);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, chunk, 1);
        des_int(n_size, size, 2);
        des_filepath(n_filename, filename, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtResetPush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtUseOptions(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        options = gen_int(n_options, 1);

        ret_val = xmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtUseOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetFeature(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML/HTML parser context */
    int n_ctxt;
    const char * name; /* the feature name */
    int n_name;
    void * result; /* location to store the result */
    int n_result;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    for (n_result = 0;n_result < gen_nb_void_ptr;n_result++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        name = gen_const_char_ptr(n_name, 1);
        result = gen_void_ptr(n_result, 2);

        ret_val = xmlGetFeature(ctxt, name, result);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_name, name, 1);
        des_void_ptr(n_result, result, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetFeature",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_result);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetFeaturesList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOParseDTD(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block or NULL */
    int n_sax;
    xmlParserInputBufferPtr input; /* an Input Buffer */
    int n_input;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        input = gen_xmlParserInputBufferPtr(n_input, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlIOParseDTD(sax, input, enc);
        input = NULL;
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_xmlParserInputBufferPtr(n_input, input, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOParseDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_input);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlInitNodeInfoSeq(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlInitParser(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitParser();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParser",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlInitParserCtxt(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlInitParserCtxt(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlKeepBlanksDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlKeepBlanksDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlKeepBlanksDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlLineNumbersDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlLineNumbersDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLineNumbersDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlLoadExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewIOInputStream(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewParserCtxt(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlNewParserCtxt();
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlParseBalancedChunkMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseBalancedChunkMemoryRecover(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseChunk(void) {
    int ret = 0;

#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * chunk; /* an char array */
    int n_chunk;
    int size; /* the size in byte of the chunk */
    int n_size;
    int terminate; /* last chunk indicator */
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        terminate = gen_int(n_terminate, 3);

        ret_val = xmlParseChunk(ctxt, chunk, size, terminate);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, chunk, 1);
        des_int(n_size, size, 2);
        des_int(n_terminate, terminate, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseChunk",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlParseCtxtExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseDTD(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    const xmlChar * ExternalID; /* a NAME* containing the External ID of the DTD */
    int n_ExternalID;
    const xmlChar * SystemID; /* a NAME* containing the URL to the DTD */
    int n_SystemID;

    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 0);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 1);

        ret_val = xmlParseDTD(ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 0);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);

        ret_val = xmlParseDoc(cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseDocument(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlParseDocument(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseEntity(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseEntity(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseExtParsedEnt(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlParseExtParsedEnt(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseExtParsedEnt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseInNodeContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlParseMemory(buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserAddNodeInfo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserFindNodeInfo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserFindNodeInfoIndex(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputGrow(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlPedanticParserDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlPedanticParserDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPedanticParserDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlReadDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlReadDoc(cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlReadFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_int(n_options, 2);

        ret_val = xmlReadFile(filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlReadMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlReadMemory(buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRecoverDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);

        ret_val = xmlRecoverDoc(cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRecoverFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlRecoverFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRecoverMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlRecoverMemory(buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseDTD(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const xmlChar * ExternalID; /* a NAME* containing the External ID of the DTD */
    int n_ExternalID;
    const xmlChar * SystemID; /* a NAME* containing the URL to the DTD */
    int n_SystemID;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 2);

        ret_val = xmlSAXParseDTD(sax, ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 1);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        cur = gen_xmlChar_ptr(n_cur, 1);
        recovery = gen_int(n_recovery, 2);

        ret_val = xmlSAXParseDoc(sax, cur, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_xmlChar_ptr(n_cur, cur, 1);
        des_int(n_recovery, recovery, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_cur);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseEntity(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * filename; /* the filename */
    int n_filename;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);

        ret_val = xmlSAXParseEntity(sax, filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * filename; /* the filename */
    int n_filename;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);
        recovery = gen_int(n_recovery, 2);

        ret_val = xmlSAXParseFile(sax, filename, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        des_int(n_recovery, recovery, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseFileWithData(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * filename; /* the filename */
    int n_filename;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;
    void * data; /* the userdata */
    int n_data;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);
        recovery = gen_int(n_recovery, 2);
        data = gen_userdata(n_data, 3);

        ret_val = xmlSAXParseFileWithData(sax, filename, recovery, data);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        des_int(n_recovery, recovery, 2);
        des_userdata(n_data, data, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseFileWithData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf(" %d", n_recovery);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    int recovery; /* work in recovery mode, i.e. tries to read not Well Formed documents */
    int n_recovery;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        recovery = gen_int(n_recovery, 3);

        ret_val = xmlSAXParseMemory(sax, buffer, size, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_int(n_recovery, recovery, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseMemoryWithData(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;
    void * data; /* the userdata */
    int n_data;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        recovery = gen_int(n_recovery, 3);
        data = gen_userdata(n_data, 4);

        ret_val = xmlSAXParseMemoryWithData(sax, buffer, size, recovery, data);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_int(n_recovery, recovery, 3);
        des_userdata(n_data, data, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseMemoryWithData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_recovery);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXUserParseFile(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlSAXHandlerPtr sax; /* a SAX handler */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks */
    int n_user_data;
    const char * filename; /* a file name */
    int n_filename;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        filename = gen_filepath(n_filename, 2);
        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;

        ret_val = xmlSAXUserParseFile(sax, user_data, filename);
        desret_int(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_filepath(n_filename, filename, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXUserParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXUserParseMemory(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlSAXHandlerPtr sax; /* a SAX handler */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks */
    int n_user_data;
    const char * buffer; /* an in-memory XML document input */
    int n_buffer;
    int size; /* the length of the XML document in bytes */
    int n_size;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        buffer = gen_const_char_ptr(n_buffer, 2);
        size = gen_int(n_size, 3);
        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;

        ret_val = xmlSAXUserParseMemory(sax, user_data, buffer, size);
        desret_int(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_buffer, buffer, 2);
        des_int(n_size, size, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXUserParseMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetFeature(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML/HTML parser context */
    int n_ctxt;
    const char * name; /* the feature name */
    int n_name;
    void * value; /* pointer to the location of the new value */
    int n_value;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_void_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        name = gen_const_char_ptr(n_name, 1);
        value = gen_void_ptr(n_value, 2);

        ret_val = xmlSetFeature(ctxt, name, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_name, name, 1);
        des_void_ptr(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetFeature",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetupParserForBuffer(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const xmlChar * buffer; /* a xmlChar * buffer */
    int n_buffer;
    const char * filename; /* a file name */
    int n_filename;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_xmlChar_ptr;n_buffer++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_xmlChar_ptr(n_buffer, 1);
        filename = gen_filepath(n_filename, 2);

        xmlSetupParserForBuffer(ctxt, buffer, filename);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_buffer, buffer, 1);
        des_filepath(n_filename, filename, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetupParserForBuffer",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStopParser(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlStopParser(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStopParser",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSubstituteEntitiesDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlSubstituteEntitiesDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSubstituteEntitiesDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}

static int
test_parser(void) {
    int ret = 0;

    printf("Testing parser : 45 of 69 functions ...\n");
    ret += test_xmlByteConsumed();
    ret += test_xmlClearNodeInfoSeq();
    ret += test_xmlClearParserCtxt();
    ret += test_xmlCreateDocParserCtxt();
    ret += test_xmlCreateIOParserCtxt();
    ret += test_xmlCreatePushParserCtxt();
    ret += test_xmlCtxtReadDoc();
    ret += test_xmlCtxtReadFile();
    ret += test_xmlCtxtReadMemory();
    ret += test_xmlCtxtReset();
    ret += test_xmlCtxtResetPush();
    ret += test_xmlCtxtUseOptions();
    ret += test_xmlGetExternalEntityLoader();
    ret += test_xmlGetFeature();
    ret += test_xmlGetFeaturesList();
    ret += test_xmlIOParseDTD();
    ret += test_xmlInitNodeInfoSeq();
    ret += test_xmlInitParser();
    ret += test_xmlInitParserCtxt();
    ret += test_xmlKeepBlanksDefault();
    ret += test_xmlLineNumbersDefault();
    ret += test_xmlLoadExternalEntity();
    ret += test_xmlNewIOInputStream();
    ret += test_xmlNewParserCtxt();
    ret += test_xmlParseBalancedChunkMemory();
    ret += test_xmlParseBalancedChunkMemoryRecover();
    ret += test_xmlParseChunk();
    ret += test_xmlParseCtxtExternalEntity();
    ret += test_xmlParseDTD();
    ret += test_xmlParseDoc();
    ret += test_xmlParseDocument();
    ret += test_xmlParseEntity();
    ret += test_xmlParseExtParsedEnt();
    ret += test_xmlParseExternalEntity();
    ret += test_xmlParseFile();
    ret += test_xmlParseInNodeContext();
    ret += test_xmlParseMemory();
    ret += test_xmlParserAddNodeInfo();
    ret += test_xmlParserFindNodeInfo();
    ret += test_xmlParserFindNodeInfoIndex();
    ret += test_xmlParserInputGrow();
    ret += test_xmlParserInputRead();
    ret += test_xmlPedanticParserDefault();
    ret += test_xmlReadDoc();
    ret += test_xmlReadFile();
    ret += test_xmlReadMemory();
    ret += test_xmlRecoverDoc();
    ret += test_xmlRecoverFile();
    ret += test_xmlRecoverMemory();
    ret += test_xmlSAXParseDTD();
    ret += test_xmlSAXParseDoc();
    ret += test_xmlSAXParseEntity();
    ret += test_xmlSAXParseFile();
    ret += test_xmlSAXParseFileWithData();
    ret += test_xmlSAXParseMemory();
    ret += test_xmlSAXParseMemoryWithData();
    ret += test_xmlSAXUserParseFile();
    ret += test_xmlSAXUserParseMemory();
    ret += test_xmlSetExternalEntityLoader();
    ret += test_xmlSetFeature();
    ret += test_xmlSetupParserForBuffer();
    ret += test_xmlStopParser();
    ret += test_xmlSubstituteEntitiesDefault();

    if (ret != 0)
	printf("Module parser: %d errors\n", ret);
    return(ret);
}

static int
test_xmlPatternMatch(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlPatterncompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_pattern(void) {
    int ret = 0;

    printf("Testing pattern : 0 of 4 functions ...\n");
    ret += test_xmlPatternMatch();
    ret += test_xmlPatterncompile();

    if (ret != 0)
	printf("Module pattern: %d errors\n", ret);
    return(ret);
}

static int
test_xmlRelaxNGDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGDumpTree(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGGetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGGetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGInitTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlRelaxNGInitTypes();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGInitTypes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGNewDocParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewMemParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGParse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGSetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGSetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidateDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidateFullElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidatePopElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidatePushCData(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidatePushElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxParserSetFlag(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_relaxng(void) {
    int ret = 0;

    printf("Testing relaxng : 1 of 22 functions ...\n");
    ret += test_xmlRelaxNGDump();
    ret += test_xmlRelaxNGDumpTree();
    ret += test_xmlRelaxNGGetParserErrors();
    ret += test_xmlRelaxNGGetValidErrors();
    ret += test_xmlRelaxNGInitTypes();
    ret += test_xmlRelaxNGNewDocParserCtxt();
    ret += test_xmlRelaxNGNewMemParserCtxt();
    ret += test_xmlRelaxNGNewParserCtxt();
    ret += test_xmlRelaxNGNewValidCtxt();
    ret += test_xmlRelaxNGParse();
    ret += test_xmlRelaxNGSetParserErrors();
    ret += test_xmlRelaxNGSetValidErrors();
    ret += test_xmlRelaxNGValidateDoc();
    ret += test_xmlRelaxNGValidateFullElement();
    ret += test_xmlRelaxNGValidatePopElement();
    ret += test_xmlRelaxNGValidatePushCData();
    ret += test_xmlRelaxNGValidatePushElement();
    ret += test_xmlRelaxParserSetFlag();

    if (ret != 0)
	printf("Module relaxng: %d errors\n", ret);
    return(ret);
}
static int
test_schemasInternals(void) {
    int ret = 0;

    printf("Testing schemasInternals : 0 of 2 functions ...\n");

    if (ret != 0)
	printf("Module schemasInternals: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNodePtr cur; /* the child node */
    int n_cur;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlAddChild(parent, cur);
        if (ret_val == NULL) { xmlFreeNode(cur) ; cur = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddChildList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNodePtr cur; /* the first node in the list */
    int n_cur;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlAddChildList(parent, cur);
        if (ret_val == NULL) { xmlFreeNodeList(cur) ; cur = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChildList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddNextSibling(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddNextSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddNextSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddPrevSibling(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddPrevSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddPrevSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlAddSibling(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAttrSerializeTxtContent(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlAttrPtr attr; /* the attribute node */
    int n_attr;
    const xmlChar * string; /* the text content */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);
        string = gen_const_xmlChar_ptr(n_string, 3);

        xmlAttrSerializeTxtContent(buf, doc, attr, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        des_const_xmlChar_ptr(n_string, string, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAttrSerializeTxtContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferAdd(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to dump */
    int n_buf;
    const xmlChar * str; /* the #xmlChar string */
    int n_str;
    int len; /* the number of #xmlChar to add */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlBufferAdd(buf, str, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferAdd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferAddHead(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;
    const xmlChar * str; /* the #xmlChar string */
    int n_str;
    int len; /* the number of #xmlChar to add */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlBufferAddHead(buf, str, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferAddHead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferCCat(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to dump */
    int n_buf;
    const char * str; /* the C char string */
    int n_str;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlBufferCCat(buf, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_char_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCCat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferCat(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to add to */
    int n_buf;
    const xmlChar * str; /* the #xmlChar string */
    int n_str;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlBufferCat(buf, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCreateSize(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCreateStatic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferEmpty(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);

        xmlBufferEmpty(buf);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferEmpty",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferGrow(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;
    unsigned int len; /* the minimum free size to allocate */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_len = 0;n_len < gen_nb_unsigned_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        len = gen_unsigned_int(n_len, 1);

        ret_val = xmlBufferGrow(buf, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferGrow",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferLength(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferResize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to resize */
    int n_buf;
    unsigned int size; /* the desired size */
    int n_size;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_size = 0;n_size < gen_nb_unsigned_int;n_size++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        size = gen_unsigned_int(n_size, 1);

        ret_val = xmlBufferResize(buf, size);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferResize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferSetAllocationScheme(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferShrink(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to dump */
    int n_buf;
    unsigned int len; /* the number of xmlChar to remove */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_len = 0;n_len < gen_nb_unsigned_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        len = gen_unsigned_int(n_len, 1);

        ret_val = xmlBufferShrink(buf, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferShrink",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferWriteCHAR(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer */
    int n_buf;
    const xmlChar * string; /* the string to add */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_xmlChar_ptr(n_string, 1);

        xmlBufferWriteCHAR(buf, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_string, string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteCHAR",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferWriteChar(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    const char * string; /* the string to add */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_string = 0;n_string < gen_nb_const_char_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_char_ptr(n_string, 1);

        xmlBufferWriteChar(buf, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_char_ptr(n_string, string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferWriteQuotedString(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    const xmlChar * string; /* the string to add */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_xmlChar_ptr(n_string, 1);

        xmlBufferWriteQuotedString(buf, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_string, string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteQuotedString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBuildQName(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * ncname; /* the Name */
    int n_ncname;
    const xmlChar * prefix; /* the prefix */
    int n_prefix;
    xmlChar * memory; /* preallocated memory */
    int n_memory;
    int len; /* preallocated memory length */
    int n_len;

    for (n_ncname = 0;n_ncname < gen_nb_const_xmlChar_ptr;n_ncname++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_memory = 0;n_memory < gen_nb_xmlChar_ptr;n_memory++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ncname = gen_const_xmlChar_ptr(n_ncname, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        memory = gen_xmlChar_ptr(n_memory, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlBuildQName(ncname, prefix, memory, len);
        if ((ret_val != NULL) && (ret_val != ncname) &&
              (ret_val != prefix) && (ret_val != memory))
              xmlFree(ret_val);
	  ret_val = NULL;
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_ncname, ncname, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_xmlChar_ptr(n_memory, memory, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildQName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ncname);
            printf(" %d", n_prefix);
            printf(" %d", n_memory);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyDoc(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    int recursive; /* if not zero do a recursive copy. */
    int n_recursive;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_recursive = 0;n_recursive < gen_nb_int;n_recursive++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        recursive = gen_int(n_recursive, 1);

        ret_val = xmlCopyDoc(doc, recursive);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_recursive, recursive, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_recursive);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCopyDtd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNamespace(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNamespaceList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNodeList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyPropList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateIntSubset(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc; /* the document pointer */
    int n_doc;
    const xmlChar * name; /* the DTD name */
    int n_name;
    const xmlChar * ExternalID; /* the external (PUBLIC) ID */
    int n_ExternalID;
    const xmlChar * SystemID; /* the system ID */
    int n_SystemID;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        ret_val = xmlCreateIntSubset(doc, name, ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateIntSubset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDocCopyNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocCopyNodeList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * f; /* the FILE* */
    int n_f;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = xmlDocDump(f, cur);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocDumpFormatMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDumpFormatMemoryEnc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDumpMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDumpMemoryEnc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocFormatDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * f; /* the FILE* */
    int n_f;
    xmlDocPtr cur; /* the document */
    int n_cur;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        format = gen_int(n_format, 2);

        ret_val = xmlDocFormatDump(f, cur, format);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_int(n_format, format, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocFormatDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocGetRootElement(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlDocGetRootElement(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocGetRootElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDocSetRootElement(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr root; /* the new document root element */
    int n_root;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_root = 0;n_root < gen_nb_xmlNodePtr_in;n_root++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        root = gen_xmlNodePtr_in(n_root, 1);

        ret_val = xmlDocSetRootElement(doc, root);
        if (doc == NULL) { xmlFreeNode(root) ; root = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr_in(n_root, root, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocSetRootElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_root);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlElemDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * f; /* the FILE * for the output */
    int n_f;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        xmlElemDump(f, doc, cur);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlElemDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlGetBufferAllocationScheme(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCompressMode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlGetCompressMode();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlGetDocCompressMode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlGetDocCompressMode(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDocCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetIntSubset(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc; /* the document pointer */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlGetIntSubset(doc);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetIntSubset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetLastChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);

        ret_val = xmlGetLastChild(parent);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetLastChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetLineNo(void) {
    int ret = 0;

    int mem_base;
    long ret_val;
    xmlNodePtr node; /* valid node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlGetLineNo(node);
        desret_long(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetLineNo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetNoNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetNoNsProp(node, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNoNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetNodePath(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlGetNodePath(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNodePath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlGetNsList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;
    const xmlChar * nameSpace; /* the URI of the namespace */
    int n_nameSpace;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);

        ret_val = xmlGetNsProp(node, name, nameSpace);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_nameSpace, nameSpace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetProp(node, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHasNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHasProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsBlankNode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlIsBlankNode(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBlankNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsXHTML(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * systemID; /* the system identifier */
    int n_systemID;
    const xmlChar * publicID; /* the public identifier */
    int n_publicID;

    for (n_systemID = 0;n_systemID < gen_nb_const_xmlChar_ptr;n_systemID++) {
    for (n_publicID = 0;n_publicID < gen_nb_const_xmlChar_ptr;n_publicID++) {
        mem_base = xmlMemBlocks();
        systemID = gen_const_xmlChar_ptr(n_systemID, 0);
        publicID = gen_const_xmlChar_ptr(n_publicID, 1);

        ret_val = xmlIsXHTML(systemID, publicID);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_systemID, systemID, 0);
        des_const_xmlChar_ptr(n_publicID, publicID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsXHTML",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_systemID);
            printf(" %d", n_publicID);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewCDataBlock(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the CDATA block content content */
    int n_content;
    int len; /* the length of the block */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNewCDataBlock(doc, content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCDataBlock",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewCharRef(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * name; /* the char ref string, starting with # or "&# ... ;" */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewCharRef(doc, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCharRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewChild(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewComment(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * content; /* the comment content */
    int n_content;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);

        ret_val = xmlNewComment(content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const xmlChar * version; /* xmlChar string giving the version of XML "1.0" */
    int n_version;

    for (n_version = 0;n_version < gen_nb_const_xmlChar_ptr;n_version++) {
        mem_base = xmlMemBlocks();
        version = gen_const_xmlChar_ptr(n_version, 0);

        ret_val = xmlNewDoc(version);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_version, version, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_version);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocComment(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the comment content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewDocComment(doc, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocFragment(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document owning the fragment */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlNewDocFragment(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocFragment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocNodeEatName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocPI(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the target document */
    int n_doc;
    const xmlChar * name; /* the processing instruction name */
    int n_name;
    const xmlChar * content; /* the PI content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlNewDocPI(doc, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocRawNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocText(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the text content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewDocText(doc, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocTextLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the text content */
    int n_content;
    int len; /* the text len. */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNewDocTextLen(doc, content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocTextLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDtd(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc; /* the document pointer */
    int n_doc;
    const xmlChar * name; /* the DTD name */
    int n_name;
    const xmlChar * ExternalID; /* the external ID */
    int n_ExternalID;
    const xmlChar * SystemID; /* the system ID */
    int n_SystemID;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        ret_val = xmlNewDtd(doc, name, ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDtd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewGlobalNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNodeEatName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNsPropEatName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewPI(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * name; /* the processing instruction name */
    int n_name;
    const xmlChar * content; /* the PI content */
    int n_content;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewPI(name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewReference(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * name; /* the reference name, or the reference string with & and ; */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewReference(doc, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewReference",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewText(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * content; /* the text content */
    int n_content;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);

        ret_val = xmlNewText(content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextChild(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * content; /* the text content */
    int n_content;
    int len; /* the text len. */
    int n_len;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlNewTextLen(content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeAddContent(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* extra content */
    int n_content;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        xmlNodeAddContent(cur, content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeAddContentLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* extra content */
    int n_content;
    int len; /* the size of @content */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        xmlNodeAddContentLen(cur, content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContentLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeBufGetContent(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buffer; /* a buffer */
    int n_buffer;
    xmlNodePtr cur; /* the node being read */
    int n_cur;

    for (n_buffer = 0;n_buffer < gen_nb_xmlBufferPtr;n_buffer++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        buffer = gen_xmlBufferPtr(n_buffer, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlNodeBufGetContent(buffer, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buffer, buffer, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeBufGetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    int level; /* the imbrication level for indenting */
    int n_level;
    int format; /* is formatting allowed */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_level = 0;n_level < gen_nb_int;n_level++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        level = gen_int(n_level, 3);
        format = gen_int(n_format, 4);

        ret_val = xmlNodeDump(buf, doc, cur, level, format);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_int(n_level, level, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_level);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeDumpOutput(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    int level; /* the imbrication level for indenting */
    int n_level;
    int format; /* is formatting allowed */
    int n_format;
    const char * encoding; /* an optional encoding string */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_level = 0;n_level < gen_nb_int;n_level++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        level = gen_int(n_level, 3);
        format = gen_int(n_format, 4);
        encoding = gen_const_char_ptr(n_encoding, 5);

        xmlNodeDumpOutput(buf, doc, cur, level, format, encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_int(n_level, level, 3);
        des_int(n_format, format, 4);
        des_const_char_ptr(n_encoding, encoding, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeDumpOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_level);
            printf(" %d", n_format);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetBase(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document the node pertains to */
    int n_doc;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlNodeGetBase(doc, cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetBase",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetContent(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur; /* the node being read */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetContent(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetLang(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetLang(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetSpacePreserve(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetSpacePreserve(cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetSpacePreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeIsText(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlNodeIsText(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeIsText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeListGetRawString(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr list; /* a Node list */
    int n_list;
    int inLine; /* should we replace entity contents or show their external form */
    int n_inLine;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_list = 0;n_list < gen_nb_xmlNodePtr;n_list++) {
    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        list = gen_xmlNodePtr(n_list, 1);
        inLine = gen_int(n_inLine, 2);

        ret_val = xmlNodeListGetRawString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_list, list, 1);
        des_int(n_inLine, inLine, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetRawString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeListGetString(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr list; /* a Node list */
    int n_list;
    int inLine; /* should we replace entity contents or show their external form */
    int n_inLine;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_list = 0;n_list < gen_nb_xmlNodePtr;n_list++) {
    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        list = gen_xmlNodePtr(n_list, 1);
        inLine = gen_int(n_inLine, 2);

        ret_val = xmlNodeListGetString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_list, list, 1);
        des_int(n_inLine, inLine, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetBase(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    const xmlChar * uri; /* the new base URI */
    int n_uri;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_uri = 0;n_uri < gen_nb_const_xmlChar_ptr;n_uri++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        uri = gen_const_xmlChar_ptr(n_uri, 1);

        xmlNodeSetBase(cur, uri);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_uri, uri, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetBase",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_uri);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetContent(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* the new value of the content */
    int n_content;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        xmlNodeSetContent(cur, content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetContentLen(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* the new value of the content */
    int n_content;
    int len; /* the size of @content */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        xmlNodeSetContentLen(cur, content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContentLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetLang(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    const xmlChar * lang; /* the language description */
    int n_lang;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_lang = 0;n_lang < gen_nb_const_xmlChar_ptr;n_lang++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        lang = gen_const_xmlChar_ptr(n_lang, 1);

        xmlNodeSetLang(cur, lang);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_lang, lang, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_lang);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetName(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    const xmlChar * name; /* the new tag name */
    int n_name;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        xmlNodeSetName(cur, name);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetSpacePreserve(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    int val; /* the xml:space value ("0": default, 1: "preserve") */
    int n_val;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        val = gen_int(n_val, 1);

        xmlNodeSetSpacePreserve(cur, val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_int(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetSpacePreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReconciliateNs(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr tree; /* a node defining the subtree to reconciliate */
    int n_tree;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        tree = gen_xmlNodePtr(n_tree, 1);

        ret_val = xmlReconciliateNs(doc, tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_tree, tree, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReconciliateNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_tree);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRemoveProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    int ret_val;
    xmlAttrPtr cur; /* an attribute */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlAttrPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlAttrPtr(n_cur, 0);

        ret_val = xmlRemoveProp(cur);
        cur = NULL;
        desret_int(ret_val);
        call_tests++;
        des_xmlAttrPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReplaceNode(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr old; /* the old node */
    int n_old;
    xmlNodePtr cur; /* the node */
    int n_cur;

    for (n_old = 0;n_old < gen_nb_xmlNodePtr;n_old++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        old = gen_xmlNodePtr(n_old, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlReplaceNode(old, cur);
        if (cur != NULL) {
              xmlUnlinkNode(cur);
              xmlFreeNode(cur) ; cur = NULL ; }
          if (old != NULL) {
              xmlUnlinkNode(old);
              xmlFreeNode(old) ; old = NULL ; }
	  ret_val = NULL;
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_old, old, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReplaceNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_old);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFile(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = xmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the name of an encoding (or NULL) */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = xmlSaveFileEnc(filename, cur, encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFileTo(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr buf; /* an output I/O buffer */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the encoding if any assuming the I/O layer handles the trancoding */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = xmlSaveFileTo(buf, cur, encoding);
        buf = NULL;
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFileTo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFormatFile(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        format = gen_int(n_format, 2);

        ret_val = xmlSaveFormatFile(filename, cur, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_int(n_format, format, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFormatFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename or URL to output */
    int n_filename;
    xmlDocPtr cur; /* the document being saved */
    int n_cur;
    const char * encoding; /* the name of the encoding to use or NULL. */
    int n_encoding;
    int format; /* should formatting spaces be added. */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = xmlSaveFormatFileEnc(filename, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFormatFileTo(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr buf; /* an output I/O buffer */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the encoding if any assuming the I/O layer handles the trancoding */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = xmlSaveFormatFileTo(buf, cur, encoding, format);
        buf = NULL;
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFileTo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSearchNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSearchNsByHref(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetBufferAllocationScheme(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetCompressMode(void) {
    int ret = 0;

    int mem_base;
    int mode; /* the compression ratio */
    int n_mode;

    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
        mem_base = xmlMemBlocks();
        mode = gen_int(n_mode, 0);

        xmlSetCompressMode(mode);
        call_tests++;
        des_int(n_mode, mode, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_mode);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetDocCompressMode(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr doc; /* the document */
    int n_doc;
    int mode; /* the compression ratio */
    int n_mode;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        mode = gen_int(n_mode, 1);

        xmlSetDocCompressMode(doc, mode);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_mode, mode, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetDocCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_mode);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSplitQName2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSplitQName3(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    const xmlChar * name; /* the full QName */
    int n_name;
    int * len; /* an int * */
    int n_len;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        len = gen_int_ptr(n_len, 1);

        ret_val = xmlSplitQName3(name, len);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        des_int_ptr(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSplitQName3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStringGetNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * value; /* the value of the attribute */
    int n_value;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = xmlStringGetNodeList(doc, value);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringGetNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStringLenGetNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * value; /* the value of the text */
    int n_value;
    int len; /* the length of the string value */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStringLenGetNodeList(doc, value, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringLenGetNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlTextConcat(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * content; /* the content */
    int n_content;
    int len; /* @content length */
    int n_len;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlTextConcat(node, content, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextConcat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlTextMerge(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr first; /* the first text node */
    int n_first;
    xmlNodePtr second; /* the second text node being merged */
    int n_second;

    for (n_first = 0;n_first < gen_nb_xmlNodePtr_in;n_first++) {
    for (n_second = 0;n_second < gen_nb_xmlNodePtr_in;n_second++) {
        mem_base = xmlMemBlocks();
        first = gen_xmlNodePtr_in(n_first, 0);
        second = gen_xmlNodePtr_in(n_second, 1);

        ret_val = xmlTextMerge(first, second);
        if ((first != NULL) && (first->type != XML_TEXT_NODE)) {
              xmlUnlinkNode(second);
              xmlFreeNode(second) ; second = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr_in(n_first, first, 0);
        des_xmlNodePtr_in(n_second, second, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextMerge",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_first);
            printf(" %d", n_second);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUnsetNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlUnsetProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlUnsetProp(node, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUnsetProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNCName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateNCName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNCName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNMToken(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateNMToken(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNMToken",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidateName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidateQName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateQName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateQName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}

static int
test_tree(void) {
    int ret = 0;

    printf("Testing tree : 89 of 146 functions ...\n");
    ret += test_xmlAddChild();
    ret += test_xmlAddChildList();
    ret += test_xmlAddNextSibling();
    ret += test_xmlAddPrevSibling();
    ret += test_xmlAddSibling();
    ret += test_xmlAttrSerializeTxtContent();
    ret += test_xmlBufferAdd();
    ret += test_xmlBufferAddHead();
    ret += test_xmlBufferCCat();
    ret += test_xmlBufferCat();
    ret += test_xmlBufferContent();
    ret += test_xmlBufferCreate();
    ret += test_xmlBufferCreateSize();
    ret += test_xmlBufferCreateStatic();
    ret += test_xmlBufferEmpty();
    ret += test_xmlBufferGrow();
    ret += test_xmlBufferLength();
    ret += test_xmlBufferResize();
    ret += test_xmlBufferSetAllocationScheme();
    ret += test_xmlBufferShrink();
    ret += test_xmlBufferWriteCHAR();
    ret += test_xmlBufferWriteChar();
    ret += test_xmlBufferWriteQuotedString();
    ret += test_xmlBuildQName();
    ret += test_xmlCopyDoc();
    ret += test_xmlCopyDtd();
    ret += test_xmlCopyNamespace();
    ret += test_xmlCopyNamespaceList();
    ret += test_xmlCopyNode();
    ret += test_xmlCopyNodeList();
    ret += test_xmlCopyProp();
    ret += test_xmlCopyPropList();
    ret += test_xmlCreateIntSubset();
    ret += test_xmlDocCopyNode();
    ret += test_xmlDocCopyNodeList();
    ret += test_xmlDocDump();
    ret += test_xmlDocDumpFormatMemory();
    ret += test_xmlDocDumpFormatMemoryEnc();
    ret += test_xmlDocDumpMemory();
    ret += test_xmlDocDumpMemoryEnc();
    ret += test_xmlDocFormatDump();
    ret += test_xmlDocGetRootElement();
    ret += test_xmlDocSetRootElement();
    ret += test_xmlElemDump();
    ret += test_xmlGetBufferAllocationScheme();
    ret += test_xmlGetCompressMode();
    ret += test_xmlGetDocCompressMode();
    ret += test_xmlGetIntSubset();
    ret += test_xmlGetLastChild();
    ret += test_xmlGetLineNo();
    ret += test_xmlGetNoNsProp();
    ret += test_xmlGetNodePath();
    ret += test_xmlGetNsList();
    ret += test_xmlGetNsProp();
    ret += test_xmlGetProp();
    ret += test_xmlHasNsProp();
    ret += test_xmlHasProp();
    ret += test_xmlIsBlankNode();
    ret += test_xmlIsXHTML();
    ret += test_xmlNewCDataBlock();
    ret += test_xmlNewCharRef();
    ret += test_xmlNewChild();
    ret += test_xmlNewComment();
    ret += test_xmlNewDoc();
    ret += test_xmlNewDocComment();
    ret += test_xmlNewDocFragment();
    ret += test_xmlNewDocNode();
    ret += test_xmlNewDocNodeEatName();
    ret += test_xmlNewDocPI();
    ret += test_xmlNewDocProp();
    ret += test_xmlNewDocRawNode();
    ret += test_xmlNewDocText();
    ret += test_xmlNewDocTextLen();
    ret += test_xmlNewDtd();
    ret += test_xmlNewGlobalNs();
    ret += test_xmlNewNode();
    ret += test_xmlNewNodeEatName();
    ret += test_xmlNewNs();
    ret += test_xmlNewNsProp();
    ret += test_xmlNewNsPropEatName();
    ret += test_xmlNewPI();
    ret += test_xmlNewProp();
    ret += test_xmlNewReference();
    ret += test_xmlNewText();
    ret += test_xmlNewTextChild();
    ret += test_xmlNewTextLen();
    ret += test_xmlNodeAddContent();
    ret += test_xmlNodeAddContentLen();
    ret += test_xmlNodeBufGetContent();
    ret += test_xmlNodeDump();
    ret += test_xmlNodeDumpOutput();
    ret += test_xmlNodeGetBase();
    ret += test_xmlNodeGetContent();
    ret += test_xmlNodeGetLang();
    ret += test_xmlNodeGetSpacePreserve();
    ret += test_xmlNodeIsText();
    ret += test_xmlNodeListGetRawString();
    ret += test_xmlNodeListGetString();
    ret += test_xmlNodeSetBase();
    ret += test_xmlNodeSetContent();
    ret += test_xmlNodeSetContentLen();
    ret += test_xmlNodeSetLang();
    ret += test_xmlNodeSetName();
    ret += test_xmlNodeSetSpacePreserve();
    ret += test_xmlReconciliateNs();
    ret += test_xmlRemoveProp();
    ret += test_xmlReplaceNode();
    ret += test_xmlSaveFile();
    ret += test_xmlSaveFileEnc();
    ret += test_xmlSaveFileTo();
    ret += test_xmlSaveFormatFile();
    ret += test_xmlSaveFormatFileEnc();
    ret += test_xmlSaveFormatFileTo();
    ret += test_xmlSearchNs();
    ret += test_xmlSearchNsByHref();
    ret += test_xmlSetBufferAllocationScheme();
    ret += test_xmlSetCompressMode();
    ret += test_xmlSetDocCompressMode();
    ret += test_xmlSetNs();
    ret += test_xmlSetNsProp();
    ret += test_xmlSetProp();
    ret += test_xmlSplitQName2();
    ret += test_xmlSplitQName3();
    ret += test_xmlStringGetNodeList();
    ret += test_xmlStringLenGetNodeList();
    ret += test_xmlTextConcat();
    ret += test_xmlTextMerge();
    ret += test_xmlUnsetNsProp();
    ret += test_xmlUnsetProp();
    ret += test_xmlValidateNCName();
    ret += test_xmlValidateNMToken();
    ret += test_xmlValidateName();
    ret += test_xmlValidateQName();

    if (ret != 0)
	printf("Module tree: %d errors\n", ret);
    return(ret);
}

static int
test_xmlBuildRelativeURI(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * URI; /* the URI reference under consideration */
    int n_URI;
    const xmlChar * base; /* the base value */
    int n_base;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        base = gen_const_xmlChar_ptr(n_base, 1);

        ret_val = xmlBuildRelativeURI(URI, base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_base, base, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildRelativeURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBuildURI(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * URI; /* the URI instance found in the document */
    int n_URI;
    const xmlChar * base; /* the base value */
    int n_base;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        base = gen_const_xmlChar_ptr(n_base, 1);

        ret_val = xmlBuildURI(URI, base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_base, base, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCanonicPath(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * path; /* the resource locator in a filesystem notation */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0);

        ret_val = xmlCanonicPath(path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCanonicPath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCreateURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNormalizeURIPath(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseURIReference(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlPrintURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveUri(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlURIEscape(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str; /* the string of the URI to escape */
    int n_str;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);

        ret_val = xmlURIEscape(str);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscape",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlURIEscapeStr(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str; /* string to escape */
    int n_str;
    const xmlChar * list; /* exception list string of chars not to escape */
    int n_list;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_list = 0;n_list < gen_nb_const_xmlChar_ptr;n_list++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        list = gen_const_xmlChar_ptr(n_list, 1);

        ret_val = xmlURIEscapeStr(str, list);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_const_xmlChar_ptr(n_list, list, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscapeStr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_list);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlURIUnescapeString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_uri(void) {
    int ret = 0;

    printf("Testing uri : 5 of 13 functions ...\n");
    ret += test_xmlBuildRelativeURI();
    ret += test_xmlBuildURI();
    ret += test_xmlCanonicPath();
    ret += test_xmlCreateURI();
    ret += test_xmlNormalizeURIPath();
    ret += test_xmlParseURI();
    ret += test_xmlParseURIReference();
    ret += test_xmlPrintURI();
    ret += test_xmlSaveUri();
    ret += test_xmlURIEscape();
    ret += test_xmlURIEscapeStr();
    ret += test_xmlURIUnescapeString();

    if (ret != 0)
	printf("Module uri: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddAttributeDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddElementDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddID(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddNotationDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyAttributeTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyElementTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyEnumeration(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNotationTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateEnumeration(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpAttributeDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpAttributeTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpElementDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpElementTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpNotationDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpNotationTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdAttrDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdElementDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdNotationDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdQAttrDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdQElementDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetID(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetRefs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsID(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the element carrying the attribute */
    int n_elem;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);

        ret_val = xmlIsID(doc, elem, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsID",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsMixedElement(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * name; /* the element name */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlIsMixedElement(doc, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsMixedElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsRef(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the element carrying the attribute */
    int n_elem;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);

        ret_val = xmlIsRef(doc, elem, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRemoveID(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);

        ret_val = xmlRemoveID(doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveID",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRemoveRef(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);

        ret_val = xmlRemoveRef(doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSnprintfElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSprintfElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidBuildContentModel(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidCtxtNormalizeAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context or NULL */
    int n_ctxt;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the parent */
    int n_elem;
    const xmlChar * name; /* the attribute name */
    int n_name;
    const xmlChar * value; /* the attribute value */
    int n_value;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        name = gen_const_xmlChar_ptr(n_name, 3);
        value = gen_const_xmlChar_ptr(n_value, 4);

        ret_val = xmlValidCtxtNormalizeAttributeValue(ctxt, doc, elem, name, value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_name, name, 3);
        des_const_xmlChar_ptr(n_value, value, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidCtxtNormalizeAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidGetPotentialChildren(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidGetValidElements(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidNormalizeAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the parent */
    int n_elem;
    const xmlChar * name; /* the attribute name */
    int n_name;
    const xmlChar * value; /* the attribute value */
    int n_value;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlValidNormalizeAttributeValue(doc, elem, name, value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_value, value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidNormalizeAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateAttributeDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateAttributeValue(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateDocument(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDocument(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateDocumentFinal(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDocumentFinal(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDocumentFinal",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateDtd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateDtdFinal(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDtdFinal(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDtdFinal",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateElement(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlValidateElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateElementDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateNameValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Name value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNameValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNameValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNamesValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Names value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNamesValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNamesValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNmtokenValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Nmtoken value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNmtokenValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokenValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNmtokensValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Nmtokens value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNmtokensValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokensValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNotationDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateNotationUse(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * notationName; /* the notation name to check */
    int n_notationName;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_notationName = 0;n_notationName < gen_nb_const_xmlChar_ptr;n_notationName++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        notationName = gen_const_xmlChar_ptr(n_notationName, 2);

        ret_val = xmlValidateNotationUse(ctxt, doc, notationName);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_const_xmlChar_ptr(n_notationName, notationName, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNotationUse",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_notationName);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateOneAttribute(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;
    xmlAttrPtr attr; /* an attribute instance */
    int n_attr;
    const xmlChar * value; /* the attribute value (without entities processing) */
    int n_value;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        attr = gen_xmlAttrPtr(n_attr, 3);
        value = gen_const_xmlChar_ptr(n_value, 4);

        ret_val = xmlValidateOneAttribute(ctxt, doc, elem, attr, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_xmlAttrPtr(n_attr, attr, 3);
        des_const_xmlChar_ptr(n_value, value, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateOneElement(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlValidateOneElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateOneNamespace(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidatePopElement(void) {
    int ret = 0;

#ifdef LIBXML_REGEXP_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;
    const xmlChar * qname; /* the qualified name as appearing in the serialization */
    int n_qname;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_qname = 0;n_qname < gen_nb_const_xmlChar_ptr;n_qname++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        qname = gen_const_xmlChar_ptr(n_qname, 3);

        ret_val = xmlValidatePopElement(ctxt, doc, elem, qname);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_qname, qname, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePopElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_qname);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidatePushCData(void) {
    int ret = 0;

#ifdef LIBXML_REGEXP_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    const xmlChar * data; /* some character data read */
    int n_data;
    int len; /* the lenght of the data */
    int n_len;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_data = 0;n_data < gen_nb_const_xmlChar_ptr;n_data++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        data = gen_const_xmlChar_ptr(n_data, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlValidatePushCData(ctxt, data, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_data, data, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePushCData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_data);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidatePushElement(void) {
    int ret = 0;

#ifdef LIBXML_REGEXP_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;
    const xmlChar * qname; /* the qualified name as appearing in the serialization */
    int n_qname;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_qname = 0;n_qname < gen_nb_const_xmlChar_ptr;n_qname++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        qname = gen_const_xmlChar_ptr(n_qname, 3);

        ret_val = xmlValidatePushElement(ctxt, doc, elem, qname);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_qname, qname, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePushElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_qname);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateRoot(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateRoot(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateRoot",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_valid(void) {
    int ret = 0;

    printf("Testing valid : 22 of 67 functions ...\n");
    ret += test_xmlAddAttributeDecl();
    ret += test_xmlAddElementDecl();
    ret += test_xmlAddID();
    ret += test_xmlAddNotationDecl();
    ret += test_xmlAddRef();
    ret += test_xmlCopyAttributeTable();
    ret += test_xmlCopyElementContent();
    ret += test_xmlCopyElementTable();
    ret += test_xmlCopyEnumeration();
    ret += test_xmlCopyNotationTable();
    ret += test_xmlCreateEnumeration();
    ret += test_xmlDumpAttributeDecl();
    ret += test_xmlDumpAttributeTable();
    ret += test_xmlDumpElementDecl();
    ret += test_xmlDumpElementTable();
    ret += test_xmlDumpNotationDecl();
    ret += test_xmlDumpNotationTable();
    ret += test_xmlGetDtdAttrDesc();
    ret += test_xmlGetDtdElementDesc();
    ret += test_xmlGetDtdNotationDesc();
    ret += test_xmlGetDtdQAttrDesc();
    ret += test_xmlGetDtdQElementDesc();
    ret += test_xmlGetID();
    ret += test_xmlGetRefs();
    ret += test_xmlIsID();
    ret += test_xmlIsMixedElement();
    ret += test_xmlIsRef();
    ret += test_xmlNewElementContent();
    ret += test_xmlNewValidCtxt();
    ret += test_xmlRemoveID();
    ret += test_xmlRemoveRef();
    ret += test_xmlSnprintfElementContent();
    ret += test_xmlSprintfElementContent();
    ret += test_xmlValidBuildContentModel();
    ret += test_xmlValidCtxtNormalizeAttributeValue();
    ret += test_xmlValidGetPotentialChildren();
    ret += test_xmlValidGetValidElements();
    ret += test_xmlValidNormalizeAttributeValue();
    ret += test_xmlValidateAttributeDecl();
    ret += test_xmlValidateAttributeValue();
    ret += test_xmlValidateDocument();
    ret += test_xmlValidateDocumentFinal();
    ret += test_xmlValidateDtd();
    ret += test_xmlValidateDtdFinal();
    ret += test_xmlValidateElement();
    ret += test_xmlValidateElementDecl();
    ret += test_xmlValidateNameValue();
    ret += test_xmlValidateNamesValue();
    ret += test_xmlValidateNmtokenValue();
    ret += test_xmlValidateNmtokensValue();
    ret += test_xmlValidateNotationDecl();
    ret += test_xmlValidateNotationUse();
    ret += test_xmlValidateOneAttribute();
    ret += test_xmlValidateOneElement();
    ret += test_xmlValidateOneNamespace();
    ret += test_xmlValidatePopElement();
    ret += test_xmlValidatePushCData();
    ret += test_xmlValidatePushElement();
    ret += test_xmlValidateRoot();

    if (ret != 0)
	printf("Module valid: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXIncludeNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXIncludeProcess(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* an XML document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlXIncludeProcess(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcess",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeProcessFlags(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* an XML document */
    int n_doc;
    int flags; /* a set of xmlParserOption used for parsing XML includes */
    int n_flags;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeProcessFlags(doc, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessFlags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeProcessNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXIncludeProcessTree(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr tree; /* a node in an XML document */
    int n_tree;

    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0);

        ret_val = xmlXIncludeProcessTree(tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTree",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_tree);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeProcessTreeFlags(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr tree; /* a node in an XML document */
    int n_tree;
    int flags; /* a set of xmlParserOption used for parsing XML includes */
    int n_flags;

    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeProcessTreeFlags(tree, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTreeFlags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_tree);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeSetFlags(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xinclude(void) {
    int ret = 0;

    printf("Testing xinclude : 4 of 8 functions ...\n");
    ret += test_xmlXIncludeNewContext();
    ret += test_xmlXIncludeProcess();
    ret += test_xmlXIncludeProcessFlags();
    ret += test_xmlXIncludeProcessNode();
    ret += test_xmlXIncludeProcessTree();
    ret += test_xmlXIncludeProcessTreeFlags();
    ret += test_xmlXIncludeSetFlags();

    if (ret != 0)
	printf("Module xinclude: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAllocOutputBuffer(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAllocParserInputBuffer(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCheckFilename(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const char * path; /* the path to check */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_char_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_char_ptr(n_path, 0);

        ret_val = xmlCheckFilename(path);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCheckHTTPInput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCleanupInputCallbacks(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlCleanupOutputCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupOutputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlFileClose(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlFileClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlFileMatch(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlFileMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlFileOpen(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlFileOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlFileRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOFTPClose(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlIOFTPClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOFTPMatch(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOFTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOFTPOpen(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOFTPOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOFTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOHTTPClose(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlIOHTTPClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOHTTPMatch(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOHTTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOHTTPOpen(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOHTTPOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOHTTPOpenW(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOHTTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNoNetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNormalizeWindowsPath(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * path; /* the input file path */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0);

        ret_val = xmlNormalizeWindowsPath(path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNormalizeWindowsPath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferCreateFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferCreateFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferCreateFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferCreateIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferFlush(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out; /* a buffered output */
    int n_out;

    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);

        ret_val = xmlOutputBufferFlush(out);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferFlush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferWrite(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out; /* a buffered parser output */
    int n_out;
    int len; /* the size in bytes of the array. */
    int n_len;
    const char * buf; /* an char array */
    int n_buf;

    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    for (n_buf = 0;n_buf < gen_nb_const_char_ptr;n_buf++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);
        len = gen_int(n_len, 1);
        buf = gen_const_char_ptr(n_buf, 2);

        ret_val = xmlOutputBufferWrite(out, len, buf);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        des_int(n_len, len, 1);
        des_const_char_ptr(n_buf, buf, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferWrite",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_len);
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferWriteEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferWriteString(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out; /* a buffered parser output */
    int n_out;
    const char * str; /* a zero terminated C string */
    int n_str;

    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlOutputBufferWriteString(out, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        des_const_char_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferWriteString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlParserGetDirectory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateMem(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateStatic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferGrow(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in; /* a buffered parser input */
    int n_in;
    int len; /* indicative value of the amount of chars to read */
    int n_len;

    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputBufferGrow(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferGrow",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferPush(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in; /* a buffered parser input */
    int n_in;
    int len; /* the size in bytes of the array. */
    int n_len;
    const char * buf; /* an char array */
    int n_buf;

    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    for (n_buf = 0;n_buf < gen_nb_const_char_ptr;n_buf++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);
        buf = gen_const_char_ptr(n_buf, 2);

        ret_val = xmlParserInputBufferPush(in, len, buf);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        des_const_char_ptr(n_buf, buf, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferPush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferRead(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in; /* a buffered parser input */
    int n_in;
    int len; /* indicative value of the amount of chars to read */
    int n_len;

    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputBufferRead(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlPopInputCallbacks(void) {
    int ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlPopInputCallbacks();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPopInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterDefaultInputCallbacks(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterDefaultOutputCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultOutputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterHTTPPostCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterHTTPPostCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterHTTPPostCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterInputCallbacks(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegisterOutputCallbacks(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlIO(void) {
    int ret = 0;

    printf("Testing xmlIO : 23 of 47 functions ...\n");
    ret += test_xmlAllocOutputBuffer();
    ret += test_xmlAllocParserInputBuffer();
    ret += test_xmlCheckFilename();
    ret += test_xmlCheckHTTPInput();
    ret += test_xmlCleanupInputCallbacks();
    ret += test_xmlCleanupOutputCallbacks();
    ret += test_xmlFileClose();
    ret += test_xmlFileMatch();
    ret += test_xmlFileOpen();
    ret += test_xmlFileRead();
    ret += test_xmlIOFTPClose();
    ret += test_xmlIOFTPMatch();
    ret += test_xmlIOFTPOpen();
    ret += test_xmlIOFTPRead();
    ret += test_xmlIOHTTPClose();
    ret += test_xmlIOHTTPMatch();
    ret += test_xmlIOHTTPOpen();
    ret += test_xmlIOHTTPOpenW();
    ret += test_xmlIOHTTPRead();
    ret += test_xmlNoNetExternalEntityLoader();
    ret += test_xmlNormalizeWindowsPath();
    ret += test_xmlOutputBufferCreateFd();
    ret += test_xmlOutputBufferCreateFile();
    ret += test_xmlOutputBufferCreateFilename();
    ret += test_xmlOutputBufferCreateIO();
    ret += test_xmlOutputBufferFlush();
    ret += test_xmlOutputBufferWrite();
    ret += test_xmlOutputBufferWriteEscape();
    ret += test_xmlOutputBufferWriteString();
    ret += test_xmlParserGetDirectory();
    ret += test_xmlParserInputBufferCreateFd();
    ret += test_xmlParserInputBufferCreateFile();
    ret += test_xmlParserInputBufferCreateFilename();
    ret += test_xmlParserInputBufferCreateIO();
    ret += test_xmlParserInputBufferCreateMem();
    ret += test_xmlParserInputBufferCreateStatic();
    ret += test_xmlParserInputBufferGrow();
    ret += test_xmlParserInputBufferPush();
    ret += test_xmlParserInputBufferRead();
    ret += test_xmlPopInputCallbacks();
    ret += test_xmlRegisterDefaultInputCallbacks();
    ret += test_xmlRegisterDefaultOutputCallbacks();
    ret += test_xmlRegisterHTTPPostCallbacks();
    ret += test_xmlRegisterInputCallbacks();
    ret += test_xmlRegisterOutputCallbacks();

    if (ret != 0)
	printf("Module xmlIO: %d errors\n", ret);
    return(ret);
}

static int
test_initGenericErrorDefaultFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCtxtGetLastError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCtxtResetLastError(void) {
    int ret = 0;

    int mem_base;
    void * ctx; /* an XML parser context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        xmlCtxtResetLastError(ctx);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtResetLastError",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetLastError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserPrintFileContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserPrintFileInfo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserValidityError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserValidityWarning(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserWarning(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlResetError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlResetLastError(void) {
    int ret = 0;



        xmlResetLastError();
        call_tests++;
        xmlResetLastError();

    function_tests++;
    return(ret);
}


static int
test_xmlSetGenericErrorFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetStructuredErrorFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlerror(void) {
    int ret = 0;

    printf("Testing xmlerror : 2 of 15 functions ...\n");
    ret += test_initGenericErrorDefaultFunc();
    ret += test_xmlCopyError();
    ret += test_xmlCtxtGetLastError();
    ret += test_xmlCtxtResetLastError();
    ret += test_xmlGetLastError();
    ret += test_xmlParserError();
    ret += test_xmlParserPrintFileContext();
    ret += test_xmlParserPrintFileInfo();
    ret += test_xmlParserValidityError();
    ret += test_xmlParserValidityWarning();
    ret += test_xmlParserWarning();
    ret += test_xmlResetError();
    ret += test_xmlResetLastError();
    ret += test_xmlSetGenericErrorFunc();
    ret += test_xmlSetStructuredErrorFunc();

    if (ret != 0)
	printf("Module xmlerror: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNewTextReader(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlParserInputBufferPtr input; /* the xmlParserInputBufferPtr used to read data */
    int n_input;
    const char * URI; /* the URI information for the source if available */
    int n_URI;

    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputBufferPtr(n_input, 0);
        URI = gen_filepath(n_URI, 1);

        ret_val = xmlNewTextReader(input, URI);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_input, input, 0);
        des_filepath(n_URI, URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextReader",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_input);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextReaderFilename(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    const char * URI; /* the URI of the resource to process */
    int n_URI;

    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
        mem_base = xmlMemBlocks();
        URI = gen_filepath(n_URI, 0);

        ret_val = xmlNewTextReaderFilename(URI);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_filepath(n_URI, URI, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextReaderFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderForDoc(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlReaderForDoc(cur, URL, encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderForFile(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_int(n_options, 2);

        ret_val = xmlReaderForFile(filename, encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderForIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderForMemory(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlReaderForMemory(buffer, size, URL, encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewDoc(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlReaderNewDoc(reader, cur, URL, encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_cur, cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewFile(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlReaderNewFile(reader, filename, encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewMemory(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_int(n_options, 5);

        ret_val = xmlReaderNewMemory(reader, buffer, size, URL, encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewWalker(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    xmlDocPtr doc; /* a preparsed document */
    int n_doc;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlReaderNewWalker(reader, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewWalker",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderWalker(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlDocPtr doc; /* a preparsed document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlReaderWalker(doc);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderWalker",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderAttributeCount(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderAttributeCount(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderAttributeCount",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderBaseUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderBaseUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderBaseUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderClose(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderClose(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstBaseUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstBaseUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstBaseUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstEncoding(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstEncoding(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstLocalName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstLocalName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstLocalName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstNamespaceUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstNamespaceUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstNamespaceUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstPrefix(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstPrefix(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstPrefix",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstString(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    const xmlChar * str; /* the string to intern. */
    int n_str;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlTextReaderConstString(reader, str);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstValue(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstXmlLang(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstXmlLang(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstXmlLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstXmlVersion(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstXmlVersion(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstXmlVersion",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderCurrentDoc(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderCurrentDoc(reader);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderCurrentDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderCurrentNode(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderCurrentNode(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderCurrentNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderDepth(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderDepth(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderDepth",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderExpand(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderExpand(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderExpand",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    const xmlChar * name; /* the qualified name of the attribute. */
    int n_name;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextReaderGetAttribute(reader, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetAttributeNo(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int no; /* the zero-based index of the attribute relative to the containing element */
    int n_no;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_no = 0;n_no < gen_nb_int;n_no++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        no = gen_int(n_no, 1);

        ret_val = xmlTextReaderGetAttributeNo(reader, no);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_no, no, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_no);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetAttributeNs(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    const xmlChar * localName; /* the local name of the attribute. */
    int n_localName;
    const xmlChar * namespaceURI; /* the namespace URI of the attribute. */
    int n_namespaceURI;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        localName = gen_const_xmlChar_ptr(n_localName, 1);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);

        ret_val = xmlTextReaderGetAttributeNs(reader, localName, namespaceURI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_localName, localName, 1);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_localName);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderGetParserProp(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int prop; /* the xmlParserProperties to get */
    int n_prop;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prop = gen_int(n_prop, 1);

        ret_val = xmlTextReaderGetParserProp(reader, prop);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_prop, prop, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetParserProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prop);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetRemainder(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderHasAttributes(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderHasAttributes(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderHasAttributes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderHasValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderHasValue(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderHasValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsDefault(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsDefault(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsEmptyElement(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsEmptyElement(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsEmptyElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsNamespaceDecl(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsNamespaceDecl(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsNamespaceDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsValid(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsValid(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsValid",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderLocalName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderLocalName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLocalName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderLocatorBaseURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderLocatorLineNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderLookupNamespace(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    const xmlChar * prefix; /* the prefix whose namespace URI is to be resolved. To return the default namespace, specify NULL */
    int n_prefix;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);

        ret_val = xmlTextReaderLookupNamespace(reader, prefix);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLookupNamespace",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    const xmlChar * name; /* the qualified name of the attribute. */
    int n_name;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextReaderMoveToAttribute(reader, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToAttributeNo(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int no; /* the zero-based index of the attribute relative to the containing element. */
    int n_no;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_no = 0;n_no < gen_nb_int;n_no++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        no = gen_int(n_no, 1);

        ret_val = xmlTextReaderMoveToAttributeNo(reader, no);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_no, no, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_no);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToAttributeNs(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    const xmlChar * localName; /* the local name of the attribute. */
    int n_localName;
    const xmlChar * namespaceURI; /* the namespace URI of the attribute. */
    int n_namespaceURI;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        localName = gen_const_xmlChar_ptr(n_localName, 1);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);

        ret_val = xmlTextReaderMoveToAttributeNs(reader, localName, namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_localName, localName, 1);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_localName);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToElement(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToElement(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToFirstAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToFirstAttribute(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToFirstAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToNextAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToNextAttribute(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToNextAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNamespaceUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNamespaceUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNamespaceUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNext(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNext(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNext",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNextSibling(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNextSibling(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNextSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNodeType(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNodeType(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNodeType",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNormalization(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNormalization(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNormalization",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderPrefix(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderPrefix(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPrefix",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderPreserve(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderPreserve(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderPreservePattern(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderQuoteChar(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderQuoteChar(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderQuoteChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderRead(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderRead(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderReadAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderReadAttributeValue(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderReadAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderReadState(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderReadState(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderReadState",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderRelaxNGSetSchema(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderRelaxNGValidate(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    const char * rng; /* the path to a RelaxNG schema or NULL */
    int n_rng;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_rng = 0;n_rng < gen_nb_const_char_ptr;n_rng++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        rng = gen_const_char_ptr(n_rng, 1);

        ret_val = xmlTextReaderRelaxNGValidate(reader, rng);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_char_ptr(n_rng, rng, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidate",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_rng);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderSetErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderSetParserProp(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int prop; /* the xmlParserProperties to set */
    int n_prop;
    int value; /* usually 0 or 1 to (de)activate it */
    int n_value;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
    for (n_value = 0;n_value < gen_nb_int;n_value++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prop = gen_int(n_prop, 1);
        value = gen_int(n_value, 2);

        ret_val = xmlTextReaderSetParserProp(reader, prop, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_prop, prop, 1);
        des_int(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderSetParserProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prop);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderSetStructuredErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderStandalone(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderStandalone(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderStandalone",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderValue(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderXmlLang(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderXmlLang(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderXmlLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xmlreader(void) {
    int ret = 0;

    printf("Testing xmlreader : 62 of 78 functions ...\n");
    ret += test_xmlNewTextReader();
    ret += test_xmlNewTextReaderFilename();
    ret += test_xmlReaderForDoc();
    ret += test_xmlReaderForFile();
    ret += test_xmlReaderForIO();
    ret += test_xmlReaderForMemory();
    ret += test_xmlReaderNewDoc();
    ret += test_xmlReaderNewFile();
    ret += test_xmlReaderNewMemory();
    ret += test_xmlReaderNewWalker();
    ret += test_xmlReaderWalker();
    ret += test_xmlTextReaderAttributeCount();
    ret += test_xmlTextReaderBaseUri();
    ret += test_xmlTextReaderClose();
    ret += test_xmlTextReaderConstBaseUri();
    ret += test_xmlTextReaderConstEncoding();
    ret += test_xmlTextReaderConstLocalName();
    ret += test_xmlTextReaderConstName();
    ret += test_xmlTextReaderConstNamespaceUri();
    ret += test_xmlTextReaderConstPrefix();
    ret += test_xmlTextReaderConstString();
    ret += test_xmlTextReaderConstValue();
    ret += test_xmlTextReaderConstXmlLang();
    ret += test_xmlTextReaderConstXmlVersion();
    ret += test_xmlTextReaderCurrentDoc();
    ret += test_xmlTextReaderCurrentNode();
    ret += test_xmlTextReaderDepth();
    ret += test_xmlTextReaderExpand();
    ret += test_xmlTextReaderGetAttribute();
    ret += test_xmlTextReaderGetAttributeNo();
    ret += test_xmlTextReaderGetAttributeNs();
    ret += test_xmlTextReaderGetErrorHandler();
    ret += test_xmlTextReaderGetParserProp();
    ret += test_xmlTextReaderGetRemainder();
    ret += test_xmlTextReaderHasAttributes();
    ret += test_xmlTextReaderHasValue();
    ret += test_xmlTextReaderIsDefault();
    ret += test_xmlTextReaderIsEmptyElement();
    ret += test_xmlTextReaderIsNamespaceDecl();
    ret += test_xmlTextReaderIsValid();
    ret += test_xmlTextReaderLocalName();
    ret += test_xmlTextReaderLocatorBaseURI();
    ret += test_xmlTextReaderLocatorLineNumber();
    ret += test_xmlTextReaderLookupNamespace();
    ret += test_xmlTextReaderMoveToAttribute();
    ret += test_xmlTextReaderMoveToAttributeNo();
    ret += test_xmlTextReaderMoveToAttributeNs();
    ret += test_xmlTextReaderMoveToElement();
    ret += test_xmlTextReaderMoveToFirstAttribute();
    ret += test_xmlTextReaderMoveToNextAttribute();
    ret += test_xmlTextReaderName();
    ret += test_xmlTextReaderNamespaceUri();
    ret += test_xmlTextReaderNext();
    ret += test_xmlTextReaderNextSibling();
    ret += test_xmlTextReaderNodeType();
    ret += test_xmlTextReaderNormalization();
    ret += test_xmlTextReaderPrefix();
    ret += test_xmlTextReaderPreserve();
    ret += test_xmlTextReaderPreservePattern();
    ret += test_xmlTextReaderQuoteChar();
    ret += test_xmlTextReaderRead();
    ret += test_xmlTextReaderReadAttributeValue();
    ret += test_xmlTextReaderReadState();
    ret += test_xmlTextReaderRelaxNGSetSchema();
    ret += test_xmlTextReaderRelaxNGValidate();
    ret += test_xmlTextReaderSetErrorHandler();
    ret += test_xmlTextReaderSetParserProp();
    ret += test_xmlTextReaderSetStructuredErrorHandler();
    ret += test_xmlTextReaderStandalone();
    ret += test_xmlTextReaderValue();
    ret += test_xmlTextReaderXmlLang();

    if (ret != 0)
	printf("Module xmlreader: %d errors\n", ret);
    return(ret);
}

static int
test_xmlSaveClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveFlush(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveSetAttrEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveSetEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveTree(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlsave(void) {
    int ret = 0;

    printf("Testing xmlsave : 0 of 9 functions ...\n");
    ret += test_xmlSaveClose();
    ret += test_xmlSaveDoc();
    ret += test_xmlSaveFlush();
    ret += test_xmlSaveSetAttrEscape();
    ret += test_xmlSaveSetEscape();
    ret += test_xmlSaveToFd();
    ret += test_xmlSaveToFilename();
    ret += test_xmlSaveToIO();
    ret += test_xmlSaveTree();

    if (ret != 0)
	printf("Module xmlsave: %d errors\n", ret);
    return(ret);
}

static int
test_xmlSchemaDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewDocParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewMemParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaParse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetValidOptions(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidCtxtGetOptions(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateOneElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateStream(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlschemas(void) {
    int ret = 0;

    printf("Testing xmlschemas : 0 of 18 functions ...\n");
    ret += test_xmlSchemaDump();
    ret += test_xmlSchemaGetParserErrors();
    ret += test_xmlSchemaGetValidErrors();
    ret += test_xmlSchemaNewDocParserCtxt();
    ret += test_xmlSchemaNewMemParserCtxt();
    ret += test_xmlSchemaNewParserCtxt();
    ret += test_xmlSchemaNewValidCtxt();
    ret += test_xmlSchemaParse();
    ret += test_xmlSchemaSetParserErrors();
    ret += test_xmlSchemaSetValidErrors();
    ret += test_xmlSchemaSetValidOptions();
    ret += test_xmlSchemaValidCtxtGetOptions();
    ret += test_xmlSchemaValidateDoc();
    ret += test_xmlSchemaValidateOneElement();
    ret += test_xmlSchemaValidateStream();

    if (ret != 0)
	printf("Module xmlschemas: %d errors\n", ret);
    return(ret);
}

static int
test_xmlSchemaCheckFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaCleanupTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlSchemaCleanupTypes();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCleanupTypes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaCollapseString(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * value; /* a value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlSchemaCollapseString(value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCollapseString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaCompareValues(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetBuiltInListSimpleTypeItemType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetBuiltInType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetFacetValueAsULong(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetPredefinedType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaInitTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED


        xmlSchemaInitTypes();
        call_tests++;
        xmlResetLastError();
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaIsBuiltInTypeFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValPredefTypeNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValPredefTypeNodeNoNorm(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateLengthFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateListSimpleTypeFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidatePredefinedType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlschemastypes(void) {
    int ret = 0;

    printf("Testing xmlschemastypes : 3 of 19 functions ...\n");
    ret += test_xmlSchemaCheckFacet();
    ret += test_xmlSchemaCleanupTypes();
    ret += test_xmlSchemaCollapseString();
    ret += test_xmlSchemaCompareValues();
    ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
    ret += test_xmlSchemaGetBuiltInType();
    ret += test_xmlSchemaGetFacetValueAsULong();
    ret += test_xmlSchemaGetPredefinedType();
    ret += test_xmlSchemaInitTypes();
    ret += test_xmlSchemaIsBuiltInTypeFacet();
    ret += test_xmlSchemaNewFacet();
    ret += test_xmlSchemaValPredefTypeNode();
    ret += test_xmlSchemaValPredefTypeNodeNoNorm();
    ret += test_xmlSchemaValidateFacet();
    ret += test_xmlSchemaValidateLengthFacet();
    ret += test_xmlSchemaValidateListSimpleTypeFacet();
    ret += test_xmlSchemaValidatePredefinedType();

    if (ret != 0)
	printf("Module xmlschemastypes: %d errors\n", ret);
    return(ret);
}

static int
test_xmlCharStrdup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const char * cur; /* the input char * */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur, 0);

        ret_val = xmlCharStrdup(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrdup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCharStrndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const char * cur; /* the input char * */
    int n_cur;
    int len; /* the len of @cur */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlCharStrndup(cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, cur, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCheckUTF8(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetUTF8Char(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrEqual(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrEqual(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrEqual",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrPrintf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrQEqual(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * pref; /* the prefix of the QName */
    int n_pref;
    const xmlChar * name; /* the localname of the QName */
    int n_name;
    const xmlChar * str; /* the second xmlChar * */
    int n_str;

    for (n_pref = 0;n_pref < gen_nb_const_xmlChar_ptr;n_pref++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        pref = gen_const_xmlChar_ptr(n_pref, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        str = gen_const_xmlChar_ptr(n_str, 2);

        ret_val = xmlStrQEqual(pref, name, str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pref, pref, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_str, str, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrQEqual",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pref);
            printf(" %d", n_name);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrVPrintf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrcasecmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrcasecmp(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcasecmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrcasestr(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    const xmlChar * str; /* the xmlChar * array (haystack) */
    int n_str;
    xmlChar * val; /* the xmlChar to search (needle) */
    int n_val;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_val = 0;n_val < gen_nb_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        val = gen_xmlChar_ptr(n_val, 1);

        ret_val = xmlStrcasestr(str, val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_xmlChar_ptr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcasestr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrchr(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrcmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrcmp(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrdup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * cur; /* the input xmlChar * */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlStrdup(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrdup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrlen(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str; /* the xmlChar * array */
    int n_str;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);

        ret_val = xmlStrlen(str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrlen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrncasecmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;
    int len; /* the max comparison length */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncasecmp(str1, str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncasecmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrncatNew(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str1; /* first xmlChar string */
    int n_str1;
    const xmlChar * str2; /* second xmlChar string */
    int n_str2;
    int len; /* the len of @str2 */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncatNew(str1, str2, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncatNew",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrncmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;
    int len; /* the max comparison length */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncmp(str1, str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * cur; /* the input xmlChar * */
    int n_cur;
    int len; /* the len of @cur */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlStrndup(cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrstr(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    const xmlChar * str; /* the xmlChar * array (haystack) */
    int n_str;
    const xmlChar * val; /* the xmlChar to search (needle) */
    int n_val;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        val = gen_const_xmlChar_ptr(n_val, 1);

        ret_val = xmlStrstr(str, val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_const_xmlChar_ptr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrstr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrsub(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str; /* the xmlChar * array (haystack) */
    int n_str;
    int start; /* the index of the first char (zero based) */
    int n_start;
    int len; /* the length of the substring */
    int n_len;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        start = gen_int(n_start, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrsub(str, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_int(n_start, start, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrsub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Charcmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf1; /* pointer to first UTF8 char */
    int n_utf1;
    const xmlChar * utf2; /* pointer to second UTF8 char */
    int n_utf2;

    for (n_utf1 = 0;n_utf1 < gen_nb_const_xmlChar_ptr;n_utf1++) {
    for (n_utf2 = 0;n_utf2 < gen_nb_const_xmlChar_ptr;n_utf2++) {
        mem_base = xmlMemBlocks();
        utf1 = gen_const_xmlChar_ptr(n_utf1, 0);
        utf2 = gen_const_xmlChar_ptr(n_utf2, 1);

        ret_val = xmlUTF8Charcmp(utf1, utf2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf1, utf1, 0);
        des_const_xmlChar_ptr(n_utf2, utf2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Charcmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf1);
            printf(" %d", n_utf2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Size(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* pointer to the UTF8 character */
    int n_utf;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);

        ret_val = xmlUTF8Size(utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Size",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strlen(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);

        ret_val = xmlUTF8Strlen(utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strlen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strloc(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    const xmlChar * utfchar; /* the UTF8 character to be found */
    int n_utfchar;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_utfchar = 0;n_utfchar < gen_nb_const_xmlChar_ptr;n_utfchar++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        utfchar = gen_const_xmlChar_ptr(n_utfchar, 1);

        ret_val = xmlUTF8Strloc(utf, utfchar);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_const_xmlChar_ptr(n_utfchar, utfchar, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strloc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_utfchar);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    int len; /* the len of @utf (in chars) */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlUTF8Strndup(utf, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strpos(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    const xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    int pos; /* the position of the desired UTF8 char (in chars) */
    int n_pos;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_pos = 0;n_pos < gen_nb_int;n_pos++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        pos = gen_int(n_pos, 1);

        ret_val = xmlUTF8Strpos(utf, pos);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_pos, pos, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strpos",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_pos);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strsize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;
    int len; /* the number of characters in the array */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlUTF8Strsize(utf, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strsub(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;
    int start; /* relative pos of first char */
    int n_start;
    int len; /* total number to copy */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        start = gen_int(n_start, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlUTF8Strsub(utf, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_start, start, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}

static int
test_xmlstring(void) {
    int ret = 0;

    printf("Testing xmlstring : 23 of 30 functions ...\n");
    ret += test_xmlCharStrdup();
    ret += test_xmlCharStrndup();
    ret += test_xmlCheckUTF8();
    ret += test_xmlGetUTF8Char();
    ret += test_xmlStrEqual();
    ret += test_xmlStrPrintf();
    ret += test_xmlStrQEqual();
    ret += test_xmlStrVPrintf();
    ret += test_xmlStrcasecmp();
    ret += test_xmlStrcasestr();
    ret += test_xmlStrchr();
    ret += test_xmlStrcmp();
    ret += test_xmlStrdup();
    ret += test_xmlStrlen();
    ret += test_xmlStrncasecmp();
    ret += test_xmlStrncatNew();
    ret += test_xmlStrncmp();
    ret += test_xmlStrndup();
    ret += test_xmlStrstr();
    ret += test_xmlStrsub();
    ret += test_xmlUTF8Charcmp();
    ret += test_xmlUTF8Size();
    ret += test_xmlUTF8Strlen();
    ret += test_xmlUTF8Strloc();
    ret += test_xmlUTF8Strndup();
    ret += test_xmlUTF8Strpos();
    ret += test_xmlUTF8Strsize();
    ret += test_xmlUTF8Strsub();

    if (ret != 0)
	printf("Module xmlstring: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNewTextWriter(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterPushParser(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterTree(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndAttribute(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndAttribute(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndCDATA(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndCDATA(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndCDATA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndComment(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndComment(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTD(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTD(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTDAttlist(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDAttlist(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDAttlist",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTDElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTDEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDEntity(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDocument(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDocument(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndPI(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndPI(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterFlush(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterFlush(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterFlush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterFullEndElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterFullEndElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterFullEndElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterSetIndent(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int indent; /* do indentation? */
    int n_indent;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_indent = 0;n_indent < gen_nb_int;n_indent++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        indent = gen_int(n_indent, 1);

        ret_val = xmlTextWriterSetIndent(writer, indent);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_indent, indent, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterSetIndent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_indent);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterSetIndentString(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * str; /* the xmlChar string */
    int n_str;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlTextWriterSetIndentString(writer, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterSetIndentString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartAttribute(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* element name */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartAttribute(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartAttributeNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * prefix; /* namespace prefix or NULL */
    int n_prefix;
    const xmlChar * name; /* element local name */
    int n_name;
    const xmlChar * namespaceURI; /* namespace URI or NULL */
    int n_namespaceURI;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);

        ret_val = xmlTextWriterStartAttributeNS(writer, prefix, name, namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartAttributeNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartCDATA(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterStartCDATA(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartCDATA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartComment(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterStartComment(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTD(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* the name of the DTD */
    int n_name;
    const xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    const xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);

        ret_val = xmlTextWriterStartDTD(writer, name, pubid, sysid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_pubid, pubid, 2);
        des_const_xmlChar_ptr(n_sysid, sysid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTDAttlist(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* the name of the DTD ATTLIST */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartDTDAttlist(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDAttlist",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTDElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* the name of the DTD element */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartDTDElement(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTDEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    const xmlChar * name; /* the name of the DTD ATTLIST */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlTextWriterStartDTDEntity(writer, pe, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDocument(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const char * version; /* the xml version ("1.0") or NULL for default ("1.0") */
    int n_version;
    const char * encoding; /* the encoding or NULL for default */
    int n_encoding;
    const char * standalone; /* "yes" or "no" or NULL for default */
    int n_standalone;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_version = 0;n_version < gen_nb_const_char_ptr;n_version++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_standalone = 0;n_standalone < gen_nb_const_char_ptr;n_standalone++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        version = gen_const_char_ptr(n_version, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        standalone = gen_const_char_ptr(n_standalone, 3);

        ret_val = xmlTextWriterStartDocument(writer, version, encoding, standalone);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_version, version, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_const_char_ptr(n_standalone, standalone, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_version);
            printf(" %d", n_encoding);
            printf(" %d", n_standalone);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* element name */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartElement(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartElementNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * prefix; /* namespace prefix or NULL */
    int n_prefix;
    const xmlChar * name; /* element local name */
    int n_name;
    const xmlChar * namespaceURI; /* namespace URI or NULL */
    int n_namespaceURI;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);

        ret_val = xmlTextWriterStartElementNS(writer, prefix, name, namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartElementNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartPI(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * target; /* PI target */
    int n_target;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_target = 0;n_target < gen_nb_const_xmlChar_ptr;n_target++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        target = gen_const_xmlChar_ptr(n_target, 1);

        ret_val = xmlTextWriterStartPI(writer, target);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_target, target, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_target);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteAttribute(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* attribute name */
    int n_name;
    const xmlChar * content; /* attribute content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteAttribute(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteAttributeNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * prefix; /* namespace prefix */
    int n_prefix;
    const xmlChar * name; /* attribute local name */
    int n_name;
    const xmlChar * namespaceURI; /* namespace URI */
    int n_namespaceURI;
    const xmlChar * content; /* attribute content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        content = gen_const_xmlChar_ptr(n_content, 4);

        ret_val = xmlTextWriterWriteAttributeNS(writer, prefix, name, namespaceURI, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        des_const_xmlChar_ptr(n_content, content, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteAttributeNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteBase64(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const char * data; /* binary data */
    int n_data;
    int start; /* the position within the data of the first byte to encode */
    int n_start;
    int len; /* the number of bytes to encode */
    int n_len;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        data = gen_const_char_ptr(n_data, 1);
        start = gen_int(n_start, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlTextWriterWriteBase64(writer, data, start, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_data, data, 1);
        des_int(n_start, start, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteBase64",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_data);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteBinHex(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const char * data; /* binary data */
    int n_data;
    int start; /* the position within the data of the first byte to encode */
    int n_start;
    int len; /* the number of bytes to encode */
    int n_len;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        data = gen_const_char_ptr(n_data, 1);
        start = gen_int(n_start, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlTextWriterWriteBinHex(writer, data, start, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_data, data, 1);
        des_int(n_start, start, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteBinHex",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_data);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteCDATA(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * content; /* CDATA content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteCDATA(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteCDATA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteComment(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * content; /* comment string */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteComment(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTD(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* the name of the DTD */
    int n_name;
    const xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    const xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    const xmlChar * subset; /* string content of the DTD */
    int n_subset;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_subset = 0;n_subset < gen_nb_const_xmlChar_ptr;n_subset++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);
        subset = gen_const_xmlChar_ptr(n_subset, 4);

        ret_val = xmlTextWriterWriteDTD(writer, name, pubid, sysid, subset);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_pubid, pubid, 2);
        des_const_xmlChar_ptr(n_sysid, sysid, 3);
        des_const_xmlChar_ptr(n_subset, subset, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_subset);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDAttlist(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* the name of the DTD ATTLIST */
    int n_name;
    const xmlChar * content; /* content of the ATTLIST */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteDTDAttlist(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDAttlist",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* the name of the DTD element */
    int n_name;
    const xmlChar * content; /* content of the element */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteDTDElement(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    const xmlChar * name; /* the name of the DTD entity */
    int n_name;
    const xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    const xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    const xmlChar * ndataid; /* the xml notation name. */
    int n_ndataid;
    const xmlChar * content; /* content of the entity */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);
        content = gen_const_xmlChar_ptr(n_content, 6);

        ret_val = xmlTextWriterWriteDTDEntity(writer, pe, name, pubid, sysid, ndataid, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_pubid, pubid, 3);
        des_const_xmlChar_ptr(n_sysid, sysid, 4);
        des_const_xmlChar_ptr(n_ndataid, ndataid, 5);
        des_const_xmlChar_ptr(n_content, content, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    const xmlChar * name; /* the name of the DTD entity */
    int n_name;
    const xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    const xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    const xmlChar * ndataid; /* the xml notation name. */
    int n_ndataid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);

        ret_val = xmlTextWriterWriteDTDExternalEntity(writer, pe, name, pubid, sysid, ndataid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_pubid, pubid, 3);
        des_const_xmlChar_ptr(n_sysid, sysid, 4);
        des_const_xmlChar_ptr(n_ndataid, ndataid, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntityContents(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    const xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    const xmlChar * ndataid; /* the xml notation name. */
    int n_ndataid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pubid = gen_const_xmlChar_ptr(n_pubid, 1);
        sysid = gen_const_xmlChar_ptr(n_sysid, 2);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 3);

        ret_val = xmlTextWriterWriteDTDExternalEntityContents(writer, pubid, sysid, ndataid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_pubid, pubid, 1);
        des_const_xmlChar_ptr(n_sysid, sysid, 2);
        des_const_xmlChar_ptr(n_ndataid, ndataid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntityContents",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDInternalEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    const xmlChar * name; /* the name of the DTD entity */
    int n_name;
    const xmlChar * content; /* content of the entity */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlTextWriterWriteDTDInternalEntity(writer, pe, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDInternalEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDNotation(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* the name of the xml notation */
    int n_name;
    const xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    const xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);

        ret_val = xmlTextWriterWriteDTDNotation(writer, name, pubid, sysid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_pubid, pubid, 2);
        des_const_xmlChar_ptr(n_sysid, sysid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDNotation",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * name; /* element name */
    int n_name;
    const xmlChar * content; /* element content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteElement(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteElementNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * prefix; /* namespace prefix */
    int n_prefix;
    const xmlChar * name; /* element local name */
    int n_name;
    const xmlChar * namespaceURI; /* namespace URI */
    int n_namespaceURI;
    const xmlChar * content; /* element content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        content = gen_const_xmlChar_ptr(n_content, 4);

        ret_val = xmlTextWriterWriteElementNS(writer, prefix, name, namespaceURI, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        des_const_xmlChar_ptr(n_content, content, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteElementNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteFormatAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDInternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatRaw(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWritePI(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * target; /* PI target */
    int n_target;
    const xmlChar * content; /* PI content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_target = 0;n_target < gen_nb_const_xmlChar_ptr;n_target++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        target = gen_const_xmlChar_ptr(n_target, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWritePI(writer, target, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_target, target, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWritePI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_target);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteRaw(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * content; /* text string */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteRaw(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteRaw",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteRawLen(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * content; /* text string */
    int n_content;
    int len; /* length of the text string */
    int n_len;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlTextWriterWriteRawLen(writer, content, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteRawLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteString(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    const xmlChar * content; /* text string */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteString(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDInternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatRaw(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlwriter(void) {
    int ret = 0;

    printf("Testing xmlwriter : 46 of 79 functions ...\n");
    ret += test_xmlNewTextWriter();
    ret += test_xmlNewTextWriterDoc();
    ret += test_xmlNewTextWriterFilename();
    ret += test_xmlNewTextWriterMemory();
    ret += test_xmlNewTextWriterPushParser();
    ret += test_xmlNewTextWriterTree();
    ret += test_xmlTextWriterEndAttribute();
    ret += test_xmlTextWriterEndCDATA();
    ret += test_xmlTextWriterEndComment();
    ret += test_xmlTextWriterEndDTD();
    ret += test_xmlTextWriterEndDTDAttlist();
    ret += test_xmlTextWriterEndDTDElement();
    ret += test_xmlTextWriterEndDTDEntity();
    ret += test_xmlTextWriterEndDocument();
    ret += test_xmlTextWriterEndElement();
    ret += test_xmlTextWriterEndPI();
    ret += test_xmlTextWriterFlush();
    ret += test_xmlTextWriterFullEndElement();
    ret += test_xmlTextWriterSetIndent();
    ret += test_xmlTextWriterSetIndentString();
    ret += test_xmlTextWriterStartAttribute();
    ret += test_xmlTextWriterStartAttributeNS();
    ret += test_xmlTextWriterStartCDATA();
    ret += test_xmlTextWriterStartComment();
    ret += test_xmlTextWriterStartDTD();
    ret += test_xmlTextWriterStartDTDAttlist();
    ret += test_xmlTextWriterStartDTDElement();
    ret += test_xmlTextWriterStartDTDEntity();
    ret += test_xmlTextWriterStartDocument();
    ret += test_xmlTextWriterStartElement();
    ret += test_xmlTextWriterStartElementNS();
    ret += test_xmlTextWriterStartPI();
    ret += test_xmlTextWriterWriteAttribute();
    ret += test_xmlTextWriterWriteAttributeNS();
    ret += test_xmlTextWriterWriteBase64();
    ret += test_xmlTextWriterWriteBinHex();
    ret += test_xmlTextWriterWriteCDATA();
    ret += test_xmlTextWriterWriteComment();
    ret += test_xmlTextWriterWriteDTD();
    ret += test_xmlTextWriterWriteDTDAttlist();
    ret += test_xmlTextWriterWriteDTDElement();
    ret += test_xmlTextWriterWriteDTDEntity();
    ret += test_xmlTextWriterWriteDTDExternalEntity();
    ret += test_xmlTextWriterWriteDTDExternalEntityContents();
    ret += test_xmlTextWriterWriteDTDInternalEntity();
    ret += test_xmlTextWriterWriteDTDNotation();
    ret += test_xmlTextWriterWriteElement();
    ret += test_xmlTextWriterWriteElementNS();
    ret += test_xmlTextWriterWriteFormatAttribute();
    ret += test_xmlTextWriterWriteFormatAttributeNS();
    ret += test_xmlTextWriterWriteFormatCDATA();
    ret += test_xmlTextWriterWriteFormatComment();
    ret += test_xmlTextWriterWriteFormatDTD();
    ret += test_xmlTextWriterWriteFormatDTDAttlist();
    ret += test_xmlTextWriterWriteFormatDTDElement();
    ret += test_xmlTextWriterWriteFormatDTDInternalEntity();
    ret += test_xmlTextWriterWriteFormatElement();
    ret += test_xmlTextWriterWriteFormatElementNS();
    ret += test_xmlTextWriterWriteFormatPI();
    ret += test_xmlTextWriterWriteFormatRaw();
    ret += test_xmlTextWriterWriteFormatString();
    ret += test_xmlTextWriterWritePI();
    ret += test_xmlTextWriterWriteRaw();
    ret += test_xmlTextWriterWriteRawLen();
    ret += test_xmlTextWriterWriteString();
    ret += test_xmlTextWriterWriteVFormatAttribute();
    ret += test_xmlTextWriterWriteVFormatAttributeNS();
    ret += test_xmlTextWriterWriteVFormatCDATA();
    ret += test_xmlTextWriterWriteVFormatComment();
    ret += test_xmlTextWriterWriteVFormatDTD();
    ret += test_xmlTextWriterWriteVFormatDTDAttlist();
    ret += test_xmlTextWriterWriteVFormatDTDElement();
    ret += test_xmlTextWriterWriteVFormatDTDInternalEntity();
    ret += test_xmlTextWriterWriteVFormatElement();
    ret += test_xmlTextWriterWriteVFormatElementNS();
    ret += test_xmlTextWriterWriteVFormatPI();
    ret += test_xmlTextWriterWriteVFormatRaw();
    ret += test_xmlTextWriterWriteVFormatString();

    if (ret != 0)
	printf("Module xmlwriter: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXPathCastBooleanToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    int val; /* a boolean */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlXPathCastBooleanToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastBooleanToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastBooleanToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    int val; /* a boolean */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlXPathCastBooleanToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastBooleanToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNodeSetToBoolean(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNodeSetToNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNodeSetToString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNodeToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlXPathCastNodeToNumber(node);
        desret_double(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNodeToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlXPathCastNodeToString(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNumberToBoolean(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNumberToString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastStringToBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * val; /* a string */
    int n_val;

    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0);

        ret_val = xmlXPathCastStringToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastStringToBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastStringToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    const xmlChar * val; /* a string */
    int n_val;

    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0);

        ret_val = xmlXPathCastStringToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastStringToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastToBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCmpNodes(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr node1; /* the first node */
    int n_node1;
    xmlNodePtr node2; /* the second node */
    int n_node2;

    for (n_node1 = 0;n_node1 < gen_nb_xmlNodePtr;n_node1++) {
    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
        mem_base = xmlMemBlocks();
        node1 = gen_xmlNodePtr(n_node1, 0);
        node2 = gen_xmlNodePtr(n_node2, 1);

        ret_val = xmlXPathCmpNodes(node1, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node1, node1, 0);
        des_xmlNodePtr(n_node2, node2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCmpNodes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node1);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCompiledEval(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathConvertBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertBoolean(val);
        val = NULL;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathConvertNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertNumber(val);
        val = NULL;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathConvertString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertString(val);
        val = NULL;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCtxtCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathEval(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathEvalExpression(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathEvalPredicate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathInit(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlXPathInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathIsInf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathIsNaN(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathNodeSetCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathObjectCopy(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* the original object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathObjectCopy(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathObjectCopy",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathOrderDocElems(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    long ret_val;
    xmlDocPtr doc; /* an input document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlXPathOrderDocElems(doc);
        desret_long(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathOrderDocElems",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xpath(void) {
    int ret = 0;

    printf("Testing xpath : 16 of 36 functions ...\n");
    ret += test_xmlXPathCastBooleanToNumber();
    ret += test_xmlXPathCastBooleanToString();
    ret += test_xmlXPathCastNodeSetToBoolean();
    ret += test_xmlXPathCastNodeSetToNumber();
    ret += test_xmlXPathCastNodeSetToString();
    ret += test_xmlXPathCastNodeToNumber();
    ret += test_xmlXPathCastNodeToString();
    ret += test_xmlXPathCastNumberToBoolean();
    ret += test_xmlXPathCastNumberToString();
    ret += test_xmlXPathCastStringToBoolean();
    ret += test_xmlXPathCastStringToNumber();
    ret += test_xmlXPathCastToBoolean();
    ret += test_xmlXPathCastToNumber();
    ret += test_xmlXPathCastToString();
    ret += test_xmlXPathCmpNodes();
    ret += test_xmlXPathCompile();
    ret += test_xmlXPathCompiledEval();
    ret += test_xmlXPathConvertBoolean();
    ret += test_xmlXPathConvertNumber();
    ret += test_xmlXPathConvertString();
    ret += test_xmlXPathCtxtCompile();
    ret += test_xmlXPathEval();
    ret += test_xmlXPathEvalExpression();
    ret += test_xmlXPathEvalPredicate();
    ret += test_xmlXPathInit();
    ret += test_xmlXPathIsInf();
    ret += test_xmlXPathIsNaN();
    ret += test_xmlXPathNewContext();
    ret += test_xmlXPathNodeSetCreate();
    ret += test_xmlXPathObjectCopy();
    ret += test_xmlXPathOrderDocElems();

    if (ret != 0)
	printf("Module xpath: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXPtrBuildNodeList(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathObjectPtr obj; /* the XPointer result from the evaluation. */
    int n_obj;

    for (n_obj = 0;n_obj < gen_nb_xmlXPathObjectPtr;n_obj++) {
        mem_base = xmlMemBlocks();
        obj = gen_xmlXPathObjectPtr(n_obj, 0);

        ret_val = xmlXPtrBuildNodeList(obj);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_obj, obj, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrBuildNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_obj);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrEval(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrEvalRangePredicate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetAdd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetDel(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetMerge(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetRemove(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewCollapsedRange(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting and ending node */
    int n_start;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);

        ret_val = xmlXPtrNewCollapsedRange(start);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewCollapsedRange",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewLocationSetNodeSet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewLocationSetNodes(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the start NodePtr value */
    int n_start;
    xmlNodePtr end; /* the end NodePtr value or NULL */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewLocationSetNodes(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewLocationSetNodes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRange(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    int startindex; /* the start index */
    int n_startindex;
    xmlNodePtr end; /* the ending point */
    int n_end;
    int endindex; /* the ending index */
    int n_endindex;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_startindex = 0;n_startindex < gen_nb_int;n_startindex++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
    for (n_endindex = 0;n_endindex < gen_nb_int;n_endindex++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        startindex = gen_int(n_startindex, 1);
        end = gen_xmlNodePtr(n_end, 2);
        endindex = gen_int(n_endindex, 3);

        ret_val = xmlXPtrNewRange(start, startindex, end, endindex);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_int(n_startindex, startindex, 1);
        des_xmlNodePtr(n_end, end, 2);
        des_int(n_endindex, endindex, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRange",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_startindex);
            printf(" %d", n_end);
            printf(" %d", n_endindex);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangeNodeObject(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    xmlXPathObjectPtr end; /* the ending object */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodeObject(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodeObject",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangeNodePoint(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    xmlXPathObjectPtr end; /* the ending point */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodePoint(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodePoint",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangeNodes(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    xmlNodePtr end; /* the ending node */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodes(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangePointNode(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr start; /* the starting point */
    int n_start;
    xmlNodePtr end; /* the ending node */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlXPathObjectPtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlXPathObjectPtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewRangePointNode(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangePointNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangePoints(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr start; /* the starting point */
    int n_start;
    xmlXPathObjectPtr end; /* the ending point */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlXPathObjectPtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlXPathObjectPtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangePoints(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangePoints",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrRangeToFunction(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrWrapLocationSet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xpointer(void) {
    int ret = 0;

    printf("Testing xpointer : 9 of 21 functions ...\n");
    ret += test_xmlXPtrBuildNodeList();
    ret += test_xmlXPtrEval();
    ret += test_xmlXPtrEvalRangePredicate();
    ret += test_xmlXPtrLocationSetAdd();
    ret += test_xmlXPtrLocationSetCreate();
    ret += test_xmlXPtrLocationSetDel();
    ret += test_xmlXPtrLocationSetMerge();
    ret += test_xmlXPtrLocationSetRemove();
    ret += test_xmlXPtrNewCollapsedRange();
    ret += test_xmlXPtrNewContext();
    ret += test_xmlXPtrNewLocationSetNodeSet();
    ret += test_xmlXPtrNewLocationSetNodes();
    ret += test_xmlXPtrNewRange();
    ret += test_xmlXPtrNewRangeNodeObject();
    ret += test_xmlXPtrNewRangeNodePoint();
    ret += test_xmlXPtrNewRangeNodes();
    ret += test_xmlXPtrNewRangePointNode();
    ret += test_xmlXPtrNewRangePoints();
    ret += test_xmlXPtrRangeToFunction();
    ret += test_xmlXPtrWrapLocationSet();

    if (ret != 0)
	printf("Module xpointer: %d errors\n", ret);
    return(ret);
}
static int
test_module(const char *module) {
    if (!strcmp(module, "HTMLparser")) return(test_HTMLparser());
    if (!strcmp(module, "HTMLtree")) return(test_HTMLtree());
    if (!strcmp(module, "catalog")) return(test_catalog());
    if (!strcmp(module, "chvalid")) return(test_chvalid());
    if (!strcmp(module, "dict")) return(test_dict());
    if (!strcmp(module, "encoding")) return(test_encoding());
    if (!strcmp(module, "entities")) return(test_entities());
    if (!strcmp(module, "hash")) return(test_hash());
    if (!strcmp(module, "list")) return(test_list());
    if (!strcmp(module, "nanoftp")) return(test_nanoftp());
    if (!strcmp(module, "nanohttp")) return(test_nanohttp());
    if (!strcmp(module, "parser")) return(test_parser());
    if (!strcmp(module, "pattern")) return(test_pattern());
    if (!strcmp(module, "relaxng")) return(test_relaxng());
    if (!strcmp(module, "schemasInternals")) return(test_schemasInternals());
    if (!strcmp(module, "tree")) return(test_tree());
    if (!strcmp(module, "uri")) return(test_uri());
    if (!strcmp(module, "valid")) return(test_valid());
    if (!strcmp(module, "xinclude")) return(test_xinclude());
    if (!strcmp(module, "xmlIO")) return(test_xmlIO());
    if (!strcmp(module, "xmlerror")) return(test_xmlerror());
    if (!strcmp(module, "xmlreader")) return(test_xmlreader());
    if (!strcmp(module, "xmlsave")) return(test_xmlsave());
    if (!strcmp(module, "xmlschemas")) return(test_xmlschemas());
    if (!strcmp(module, "xmlschemastypes")) return(test_xmlschemastypes());
    if (!strcmp(module, "xmlstring")) return(test_xmlstring());
    if (!strcmp(module, "xmlwriter")) return(test_xmlwriter());
    if (!strcmp(module, "xpath")) return(test_xpath());
    if (!strcmp(module, "xpointer")) return(test_xpointer());
    return(0);
}
