/*
 * testapi.c: libxml2 API tester program.
 *
 * Automatically generated by gentest.py from libxml2-api.xml
 *
 * See Copyright for the status of this software.
 *
 * daniel@veillard.com
 */

#include <stdio.h>
#include <string.h>
#include <libxml/xmlerror.h>
#include <libxml/relaxng.h>

static int testlibxml2(void);
static int test_module(const char *module);

static int generic_errors = 0;
static int call_tests = 0;
static int function_tests = 0;

static xmlChar chartab[1024] = "  chartab\n";
static int inttab[1024];
static unsigned long longtab[1024];

static xmlDocPtr api_doc = NULL;
static xmlDtdPtr api_dtd = NULL;
static xmlNodePtr api_root = NULL;
static xmlAttrPtr api_attr = NULL;
static xmlNsPtr api_ns = NULL;

static void
structured_errors(void *userData ATTRIBUTE_UNUSED,
                  xmlErrorPtr error ATTRIBUTE_UNUSED) {
    generic_errors++;
}

static void
free_api_doc(void) {
    xmlFreeDoc(api_doc);
    api_doc = NULL;
    api_dtd = NULL;
    api_root = NULL;
    api_attr = NULL;
    api_ns = NULL;
}

static xmlDocPtr
get_api_doc(void) {
    if (api_doc == NULL) {
        api_doc = xmlReadMemory("<!DOCTYPE root [<!ELEMENT root EMPTY>]><root xmlns:h='http://example.com/' h:foo='bar'/>", 88, "root_test", NULL, 0);
	api_root = NULL;
	api_attr = NULL;
    }
    return(api_doc);
}

static xmlDtdPtr
get_api_dtd(void) {
    if ((api_dtd == NULL) || (api_dtd->type != XML_DTD_NODE)) {
        get_api_doc();
	if ((api_doc != NULL) && (api_doc->children != NULL) &&
	    (api_doc->children->type == XML_DTD_NODE))
	    api_dtd = (xmlDtdPtr) api_doc->children;
    }
    return(api_dtd);
}

static xmlNodePtr
get_api_root(void) {
    if ((api_root == NULL) || (api_root->type != XML_ELEMENT_NODE)) {
        get_api_doc();
	if ((api_doc != NULL) && (api_doc->children != NULL) &&
	    (api_doc->children->next != NULL) &&
	    (api_doc->children->next->type == XML_ELEMENT_NODE))
	    api_root = api_doc->children->next;
    }
    return(api_root);
}

static xmlNsPtr
get_api_ns(void) {
    get_api_root();
    if (api_root != NULL)
        api_ns = api_root->nsDef;
    return(api_ns);
}

static xmlAttrPtr
get_api_attr(void) {
    static int nr = 0;
    xmlChar name[20];

    if ((api_root == NULL) || (api_root->type != XML_ELEMENT_NODE)) {
        get_api_root();
    }
    if (api_root == NULL) 
        return(NULL);
    if (api_root->properties != NULL) {
        api_attr = api_root->properties;
        return(api_root->properties);
    }
    snprintf((char *) name, 20, "foo%d", nr++);
    api_attr = xmlSetProp(api_root, name, (const xmlChar *) "bar");
    return(api_attr);
}

int main(int argc, char **argv) {
    int ret;
    int blocks, mem;

    xmlInitParser();
#ifdef LIBXML_SCHEMAS_ENABLED
    xmlRelaxNGInitTypes();
#endif

    LIBXML_TEST_VERSION

    xmlSetStructuredErrorFunc(NULL, structured_errors);

    if (argc == 2)
        ret = test_module(argv[1]);
    else
	ret = testlibxml2();

    xmlCleanupParser();
    blocks = xmlMemBlocks();
    mem = xmlMemUsed();
    if ((blocks != 0) || (mem != 0)) {
        printf("testapi leaked %d bytes in %d blocks\n", mem, blocks);
    }
    xmlMemoryDump();

    return (ret != 0);
}

#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/catalog.h>
#include <libxml/chvalid.h>
#include <libxml/dict.h>
#include <libxml/encoding.h>
#include <libxml/entities.h>
#include <libxml/hash.h>
#include <libxml/list.h>
#include <libxml/nanoftp.h>
#include <libxml/nanohttp.h>
#include <libxml/parser.h>
#include <libxml/pattern.h>
#include <libxml/relaxng.h>
#include <libxml/schemasInternals.h>
#include <libxml/tree.h>
#include <libxml/uri.h>
#include <libxml/valid.h>
#include <libxml/xinclude.h>
#include <libxml/xmlIO.h>
#include <libxml/xmlerror.h>
#include <libxml/xmlreader.h>
#include <libxml/xmlsave.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>
#include <libxml/xmlstring.h>
#include <libxml/xmlwriter.h>
#include <libxml/xpath.h>
#include <libxml/xpointer.h>

#define gen_nb_void_ptr 2

static void *gen_void_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_void_ptr(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#if 0
#define gen_nb_const_void_ptr 2

static const void *gen_const_void_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((const void *) "immutable string");
    return(NULL);
}
static void des_const_void_ptr(int no ATTRIBUTE_UNUSED, const void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
#endif

#define gen_nb_userdata 3

static void *gen_userdata(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((void *) &call_tests);
    if (no == 1) return((void *) -1);
    return(NULL);
}
static void des_userdata(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}


#define gen_nb_int 4

static int gen_int(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(-1);
    if (no == 3) return(122);
    return(-1);
}

static void des_int(int no ATTRIBUTE_UNUSED, int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#if 0
#define gen_nb_long 4

static long gen_long(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(-1);
    if (no == 3) return(122);
    return(-1);
}

static void des_long(int no ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
#endif

#define gen_nb_unsigned_int 3

static unsigned int gen_unsigned_int(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return(-1);
}

static void des_unsigned_int(int no ATTRIBUTE_UNUSED, unsigned int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_unsigned_long 4

static unsigned long gen_unsigned_long(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return(-1);
}

static void des_unsigned_long(int no ATTRIBUTE_UNUSED, unsigned long val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_double 4

static double gen_double(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(0);
    if (no == 1) return(-1.1);
    if (no == 2) return(xmlXPathNAN);
    return(-1);
}

static void des_double(int no ATTRIBUTE_UNUSED, double val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_unsigned_long_ptr 2

static unsigned long *gen_unsigned_long_ptr(int no, int nr) {
    if (no == 0) return(&longtab[nr]);
    return(NULL);
}

static void des_unsigned_long_ptr(int no ATTRIBUTE_UNUSED, unsigned long *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_int_ptr 2

static int *gen_int_ptr(int no, int nr) {
    if (no == 0) return(&inttab[nr]);
    return(NULL);
}

static void des_int_ptr(int no ATTRIBUTE_UNUSED, int *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_const_char_ptr 4

static char *gen_const_char_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((char *) "foo");
    if (no == 1) return((char *) "<foo/>");
    if (no == 2) return((char *) "test/ent2");
    return(NULL);
}
static void des_const_char_ptr(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlChar_ptr 2

static xmlChar *gen_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(&chartab[0]);
    return(NULL);
}
static void des_xmlChar_ptr(int no ATTRIBUTE_UNUSED, xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_FILE_ptr 2

static FILE *gen_FILE_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(fopen("test.out", "a+"));
    return(NULL);
}
static void des_FILE_ptr(int no ATTRIBUTE_UNUSED, FILE *val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) fclose(val);
}

#define gen_nb_const_xmlChar_ptr 5

static xmlChar *gen_const_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((xmlChar *) "foo");
    if (no == 1) return((xmlChar *) "<foo/>");
    if (no == 2) return((xmlChar *) "nøne");
    if (no == 3) return((xmlChar *) " 2ab ");
    return(NULL);
}
static void des_const_xmlChar_ptr(int no ATTRIBUTE_UNUSED, const xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_filepath 8

static const char *gen_filepath(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    if (no == 3) return("test/valid/REC-xml-19980210.xml");
    if (no == 4) return("test/valid/dtds/xhtml1-strict.dtd");
    if (no == 5) return("http://missing.example.org/");
    if (no == 6) return("http://missing. example.org/");
    return(NULL);
}
static void des_filepath(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_eaten_name 2

static xmlChar *gen_eaten_name(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlStrdup(BAD_CAST "eaten"));
    return(NULL);
}
static void des_eaten_name(int no ATTRIBUTE_UNUSED, xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_fileoutput 6

static const char *gen_fileoutput(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return("/missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("ftp://missing.example.org/foo");
    if (no == 3) return("http://missing.example.org/");
    if (no == 4) return("http://missing. example.org/");
    return(NULL);
}
static void des_fileoutput(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserCtxtPtr 2
static xmlParserCtxtPtr gen_xmlParserCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewParserCtxt());
    return(NULL);
}
static void des_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlParserCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlFreeParserCtxt(val);
}

#define gen_nb_xmlSAXHandlerPtr 2
static xmlSAXHandlerPtr gen_xmlSAXHandlerPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return((xmlSAXHandlerPtr) &xmlDefaultSAXHandler);
    return(NULL);
}
static void des_xmlSAXHandlerPtr(int no ATTRIBUTE_UNUSED, xmlSAXHandlerPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlValidCtxtPtr 2
static xmlValidCtxtPtr gen_xmlValidCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewValidCtxt());
    return(NULL);
}
static void des_xmlValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlValidCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlFreeValidCtxt(val);
}

#define gen_nb_xmlParserInputBufferPtr 8

static xmlParserInputBufferPtr gen_xmlParserInputBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlParserInputBufferCreateFilename("missing.xml", XML_CHAR_ENCODING_NONE));
    if (no == 1) return(xmlParserInputBufferCreateFilename("<foo/>", XML_CHAR_ENCODING_NONE));
    if (no == 2) return(xmlParserInputBufferCreateFilename("test/ent2", XML_CHAR_ENCODING_NONE));
    if (no == 3) return(xmlParserInputBufferCreateFilename("test/valid/REC-xml-19980210.xml", XML_CHAR_ENCODING_NONE));
    if (no == 4) return(xmlParserInputBufferCreateFilename("test/valid/dtds/xhtml1-strict.dtd", XML_CHAR_ENCODING_NONE));
    if (no == 5) return(xmlParserInputBufferCreateFilename("http://missing.example.org/", XML_CHAR_ENCODING_NONE));
    if (no == 6) return(xmlParserInputBufferCreateFilename("http://missing. example.org/", XML_CHAR_ENCODING_NONE));
    return(NULL);
}
static void des_xmlParserInputBufferPtr(int no ATTRIBUTE_UNUSED, xmlParserInputBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    xmlFreeParserInputBuffer(val);
}

#define gen_nb_xmlDocPtr 3
static xmlDocPtr gen_xmlDocPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewDoc(BAD_CAST "1.0"));
    if (no == 1) return(xmlReadMemory("<foo/>", 6, "test", NULL, 0));
    return(NULL);
}
static void des_xmlDocPtr(int no ATTRIBUTE_UNUSED, xmlDocPtr val, int nr ATTRIBUTE_UNUSED) {
    if ((val != NULL) && (val != api_doc) && (val->doc != api_doc))
        xmlFreeDoc(val);
}

#define gen_nb_xmlAttrPtr 2
static xmlAttrPtr gen_xmlAttrPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(get_api_attr());
    return(NULL);
}
static void des_xmlAttrPtr(int no, xmlAttrPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) free_api_doc();
}

#define gen_nb_xmlDictPtr 2
static xmlDictPtr gen_xmlDictPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlDictCreate());
    return(NULL);
}
static void des_xmlDictPtr(int no ATTRIBUTE_UNUSED, xmlDictPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL)
        xmlDictFree(val);
}

#define gen_nb_xmlNodePtr 3
static xmlNodePtr gen_xmlNodePtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    if (no == 1) return(get_api_root());
    return(NULL);
/*     if (no == 2) return((xmlNodePtr) get_api_doc()); */
}
static void des_xmlNodePtr(int no, xmlNodePtr val, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) free_api_doc();
    else if (val != NULL) {
        xmlUnlinkNode(val);
        xmlFreeNode(val);
    }
}

#define gen_nb_xmlDtdPtr 3
static xmlDtdPtr gen_xmlDtdPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) 
        return(xmlNewDtd(NULL, BAD_CAST "dtd", BAD_CAST"foo", BAD_CAST"bar"));
    if (no == 1) return(get_api_dtd());
    return(NULL);
}
static void des_xmlDtdPtr(int no, xmlDtdPtr val, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) free_api_doc();
    else if (val != NULL) {
        xmlUnlinkNode((xmlNodePtr) val);
        xmlFreeNode((xmlNodePtr) val);
    }
}

#define gen_nb_xmlNsPtr 2
static xmlNsPtr gen_xmlNsPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(get_api_ns());
    return(NULL);
}
static void des_xmlNsPtr(int no, xmlNsPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) free_api_doc();
}

#define gen_nb_xmlNodePtr_in 3
static xmlNodePtr gen_xmlNodePtr_in(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    if (no == 0) return(xmlNewText(BAD_CAST "text"));
    return(NULL);
}
static void des_xmlNodePtr_in(int no ATTRIBUTE_UNUSED, xmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlTextWriterPtr 2
static xmlTextWriterPtr gen_xmlTextWriterPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewTextWriterFilename("test.out", 0));
    return(NULL);
}
static void des_xmlTextWriterPtr(int no ATTRIBUTE_UNUSED, xmlTextWriterPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) xmlFreeTextWriter(val);
}

#define gen_nb_xmlTextReaderPtr 4
static xmlTextReaderPtr gen_xmlTextReaderPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNewTextReaderFilename("test/ent2"));
    if (no == 1) return(xmlNewTextReaderFilename("test/valid/REC-xml-19980210.xml"));
    if (no == 2) return(xmlNewTextReaderFilename("test/valid/dtds/xhtml1-strict.dtd"));
    return(NULL);
}
static void des_xmlTextReaderPtr(int no ATTRIBUTE_UNUSED, xmlTextReaderPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) xmlFreeTextReader(val);
}

#define gen_nb_xmlBufferPtr 3
static xmlBufferPtr gen_xmlBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlBufferCreate());
    if (no == 1) return(xmlBufferCreateStatic((void *)"a static buffer", 13));
    return(NULL);
}
static void des_xmlBufferPtr(int no ATTRIBUTE_UNUSED, xmlBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlBufferFree(val);
    }
}

#define gen_nb_xmlListPtr 2
static xmlListPtr gen_xmlListPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlListCreate(NULL, NULL));
    return(NULL);
}
static void des_xmlListPtr(int no ATTRIBUTE_UNUSED, xmlListPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlListDelete(val);
    }
}

#define gen_nb_xmlHashTablePtr 2
static xmlHashTablePtr gen_xmlHashTablePtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlHashCreate(10));
    return(NULL);
}
static void des_xmlHashTablePtr(int no ATTRIBUTE_UNUSED, xmlHashTablePtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlHashFree(val, NULL);
    }
}

#include <libxml/xpathInternals.h>

#define gen_nb_xmlXPathObjectPtr 5
static xmlXPathObjectPtr gen_xmlXPathObjectPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlXPathNewString(BAD_CAST "string object"));
    if (no == 1) return(xmlXPathNewFloat(1.1));
    if (no == 2) return(xmlXPathNewBoolean(1));
    if (no == 3) return(xmlXPathNewNodeSet(NULL));
    return(NULL);
}
static void des_xmlXPathObjectPtr(int no ATTRIBUTE_UNUSED, xmlXPathObjectPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlXPathFreeObject(val);
    }
}

#define gen_nb_xmlOutputBufferPtr 2
static xmlOutputBufferPtr gen_xmlOutputBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlOutputBufferCreateFilename("test.out", NULL, 0));
    return(NULL);
}
static void des_xmlOutputBufferPtr(int no ATTRIBUTE_UNUSED, xmlOutputBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlOutputBufferClose(val);
    }
}

#define gen_nb_xmlNanoFTPCtxtPtr 4
static void *gen_xmlNanoFTPCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(xmlNanoFTPNewCtxt("ftp://example.com/"));
    if (no == 1) return(xmlNanoFTPNewCtxt("http://example.com/"));
    if (no == 2) return(xmlNanoFTPNewCtxt("foo"));
    return(NULL);
}
static void des_xmlNanoFTPCtxtPtr(int no ATTRIBUTE_UNUSED, void *val, int nr ATTRIBUTE_UNUSED) {
    if (val != NULL) {
        xmlNanoFTPFreeCtxt(val);
    }
}

#define gen_nb_xmlNanoHTTPCtxtPtr 1
static void *gen_xmlNanoHTTPCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlNanoHTTPCtxtPtr(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlCharEncoding 4
static xmlCharEncoding gen_xmlCharEncoding(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 0) return(XML_CHAR_ENCODING_UTF8);
    if (no == 1) return(XML_CHAR_ENCODING_NONE);
    if (no == 0) return(XML_CHAR_ENCODING_8859_1);
    return(XML_CHAR_ENCODING_ERROR);
}
static void des_xmlCharEncoding(int no ATTRIBUTE_UNUSED, xmlCharEncoding val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}


static void desret_int(int val ATTRIBUTE_UNUSED) {
}
static void desret_long(long val ATTRIBUTE_UNUSED) {
}
static void desret_double(double val ATTRIBUTE_UNUSED) {
}
static void desret_xmlCharEncoding(xmlCharEncoding val ATTRIBUTE_UNUSED) {
}
#if 0
static void desret_const_void_ptr(void *val ATTRIBUTE_UNUSED) {
}
#endif
static void desret_void_ptr(void *val ATTRIBUTE_UNUSED) {
}
static void desret_const_char_ptr(const char *val ATTRIBUTE_UNUSED) {
}
static void desret_const_xmlChar_ptr(const xmlChar *val ATTRIBUTE_UNUSED) {
}
static void desret_xmlChar_ptr(xmlChar *val) {
    if (val != NULL)
	xmlFree(val);
}
static void desret_xmlDocPtr(xmlDocPtr val) {
    if (val != api_doc)
	xmlFreeDoc(val);
}
static void desret_xmlDictPtr(xmlDictPtr val) {
    xmlDictFree(val);
}
static void desret_xmlOutputBufferPtr(xmlOutputBufferPtr val) {
    xmlOutputBufferClose(val);
}
static void desret_xmlTextReaderPtr(xmlTextReaderPtr val) {
    xmlFreeTextReader(val);
}
static void desret_xmlNodePtr(xmlNodePtr val) {
    if ((val != NULL) && (val != api_root) && (val != (xmlNodePtr) api_doc)) {
	xmlUnlinkNode(val);
	xmlFreeNode(val);
    }
}
static void desret_xmlAttrPtr(xmlAttrPtr val) {
    if (val != NULL) {
	xmlUnlinkNode((xmlNodePtr) val);
	xmlFreeNode((xmlNodePtr) val);
    }
}
static void desret_xmlEntityPtr(xmlEntityPtr val) {
    if (val != NULL) {
	xmlUnlinkNode((xmlNodePtr) val);
	xmlFreeNode((xmlNodePtr) val);
    }
}
static void desret_xmlNsPtr(xmlNsPtr val ATTRIBUTE_UNUSED) {
}
static void desret_xmlDtdPtr(xmlDtdPtr val) {
    desret_xmlNodePtr((xmlNodePtr)val);
}
static void desret_xmlXPathObjectPtr(xmlXPathObjectPtr val) {
    xmlXPathFreeObject(val);
}
static void desret_xmlParserCtxtPtr(xmlParserCtxtPtr val) {
    xmlFreeParserCtxt(val);
}

static void desret_xmlParserInputBufferPtr(xmlParserInputBufferPtr val) {
    xmlFreeParserInputBuffer(val);
}
static void desret_xmlTextWriterPtr(xmlTextWriterPtr val) {
    xmlFreeTextWriter(val);
}
static void desret_xmlBufferPtr(xmlBufferPtr val) {
    xmlBufferFree(val);
}

/************************************************************************
 *									*
 *   WARNING: end of the manually maintained part of the test code	*
 *            do not remove or alter the CUT HERE line			*
 *									*
 ************************************************************************/

/* CUT HERE: everything below that line is generated */
#define gen_nb_htmlParserOption 4
static htmlParserOption gen_htmlParserOption(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(HTML_PARSE_NOBLANKS);
    if (no == 2) return(HTML_PARSE_NOERROR);
    if (no == 3) return(HTML_PARSE_NONET);
    if (no == 4) return(HTML_PARSE_NOWARNING);
    return(0);
}
static void des_htmlParserOption(int no ATTRIBUTE_UNUSED, htmlParserOption val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_htmlParserOption(htmlParserOption val ATTRIBUTE_UNUSED) {
}

#define gen_nb_htmlStatus 4
static htmlStatus gen_htmlStatus(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(HTML_DEPRECATED);
    if (no == 2) return(HTML_INVALID);
    if (no == 3) return(HTML_NA);
    if (no == 4) return(HTML_REQUIRED);
    return(0);
}
static void des_htmlStatus(int no ATTRIBUTE_UNUSED, htmlStatus val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_htmlStatus(htmlStatus val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xlinkActuate 3
static xlinkActuate gen_xlinkActuate(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XLINK_ACTUATE_AUTO);
    if (no == 2) return(XLINK_ACTUATE_NONE);
    if (no == 3) return(XLINK_ACTUATE_ONREQUEST);
    return(0);
}
static void des_xlinkActuate(int no ATTRIBUTE_UNUSED, xlinkActuate val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xlinkActuate(xlinkActuate val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xlinkShow 4
static xlinkShow gen_xlinkShow(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XLINK_SHOW_EMBED);
    if (no == 2) return(XLINK_SHOW_NEW);
    if (no == 3) return(XLINK_SHOW_NONE);
    if (no == 4) return(XLINK_SHOW_REPLACE);
    return(0);
}
static void des_xlinkShow(int no ATTRIBUTE_UNUSED, xlinkShow val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xlinkShow(xlinkShow val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xlinkType 4
static xlinkType gen_xlinkType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XLINK_TYPE_EXTENDED);
    if (no == 2) return(XLINK_TYPE_EXTENDED_SET);
    if (no == 3) return(XLINK_TYPE_NONE);
    if (no == 4) return(XLINK_TYPE_SIMPLE);
    return(0);
}
static void des_xlinkType(int no ATTRIBUTE_UNUSED, xlinkType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xlinkType(xlinkType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlAttributeDefault 4
static xmlAttributeDefault gen_xmlAttributeDefault(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_ATTRIBUTE_FIXED);
    if (no == 2) return(XML_ATTRIBUTE_IMPLIED);
    if (no == 3) return(XML_ATTRIBUTE_NONE);
    if (no == 4) return(XML_ATTRIBUTE_REQUIRED);
    return(0);
}
static void des_xmlAttributeDefault(int no ATTRIBUTE_UNUSED, xmlAttributeDefault val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlAttributeDefault(xmlAttributeDefault val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlAttributeType 4
static xmlAttributeType gen_xmlAttributeType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_ATTRIBUTE_CDATA);
    if (no == 2) return(XML_ATTRIBUTE_ENTITIES);
    if (no == 3) return(XML_ATTRIBUTE_ENTITY);
    if (no == 4) return(XML_ATTRIBUTE_ENUMERATION);
    return(0);
}
static void des_xmlAttributeType(int no ATTRIBUTE_UNUSED, xmlAttributeType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlAttributeType(xmlAttributeType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlBufferAllocationScheme 3
static xmlBufferAllocationScheme gen_xmlBufferAllocationScheme(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_BUFFER_ALLOC_DOUBLEIT);
    if (no == 2) return(XML_BUFFER_ALLOC_EXACT);
    if (no == 3) return(XML_BUFFER_ALLOC_IMMUTABLE);
    return(0);
}
static void des_xmlBufferAllocationScheme(int no ATTRIBUTE_UNUSED, xmlBufferAllocationScheme val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlBufferAllocationScheme(xmlBufferAllocationScheme val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlCatalogAllow 4
static xmlCatalogAllow gen_xmlCatalogAllow(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_CATA_ALLOW_ALL);
    if (no == 2) return(XML_CATA_ALLOW_DOCUMENT);
    if (no == 3) return(XML_CATA_ALLOW_GLOBAL);
    if (no == 4) return(XML_CATA_ALLOW_NONE);
    return(0);
}
static void des_xmlCatalogAllow(int no ATTRIBUTE_UNUSED, xmlCatalogAllow val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlCatalogAllow(xmlCatalogAllow val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlCatalogPrefer 3
static xmlCatalogPrefer gen_xmlCatalogPrefer(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_CATA_PREFER_NONE);
    if (no == 2) return(XML_CATA_PREFER_PUBLIC);
    if (no == 3) return(XML_CATA_PREFER_SYSTEM);
    return(0);
}
static void des_xmlCatalogPrefer(int no ATTRIBUTE_UNUSED, xmlCatalogPrefer val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlCatalogPrefer(xmlCatalogPrefer val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlElementContentOccur 4
static xmlElementContentOccur gen_xmlElementContentOccur(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_ELEMENT_CONTENT_MULT);
    if (no == 2) return(XML_ELEMENT_CONTENT_ONCE);
    if (no == 3) return(XML_ELEMENT_CONTENT_OPT);
    if (no == 4) return(XML_ELEMENT_CONTENT_PLUS);
    return(0);
}
static void des_xmlElementContentOccur(int no ATTRIBUTE_UNUSED, xmlElementContentOccur val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlElementContentOccur(xmlElementContentOccur val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlElementContentType 4
static xmlElementContentType gen_xmlElementContentType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_ELEMENT_CONTENT_ELEMENT);
    if (no == 2) return(XML_ELEMENT_CONTENT_OR);
    if (no == 3) return(XML_ELEMENT_CONTENT_PCDATA);
    if (no == 4) return(XML_ELEMENT_CONTENT_SEQ);
    return(0);
}
static void des_xmlElementContentType(int no ATTRIBUTE_UNUSED, xmlElementContentType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlElementContentType(xmlElementContentType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlElementType 4
static xmlElementType gen_xmlElementType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_ATTRIBUTE_DECL);
    if (no == 2) return(XML_ATTRIBUTE_NODE);
    if (no == 3) return(XML_CDATA_SECTION_NODE);
    if (no == 4) return(XML_COMMENT_NODE);
    return(0);
}
static void des_xmlElementType(int no ATTRIBUTE_UNUSED, xmlElementType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlElementType(xmlElementType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlElementTypeVal 4
static xmlElementTypeVal gen_xmlElementTypeVal(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_ELEMENT_TYPE_ANY);
    if (no == 2) return(XML_ELEMENT_TYPE_ELEMENT);
    if (no == 3) return(XML_ELEMENT_TYPE_EMPTY);
    if (no == 4) return(XML_ELEMENT_TYPE_MIXED);
    return(0);
}
static void des_xmlElementTypeVal(int no ATTRIBUTE_UNUSED, xmlElementTypeVal val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlElementTypeVal(xmlElementTypeVal val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlEntityType 4
static xmlEntityType gen_xmlEntityType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_EXTERNAL_GENERAL_PARSED_ENTITY);
    if (no == 2) return(XML_EXTERNAL_GENERAL_UNPARSED_ENTITY);
    if (no == 3) return(XML_EXTERNAL_PARAMETER_ENTITY);
    if (no == 4) return(XML_INTERNAL_GENERAL_ENTITY);
    return(0);
}
static void des_xmlEntityType(int no ATTRIBUTE_UNUSED, xmlEntityType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlEntityType(xmlEntityType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlErrorDomain 4
static xmlErrorDomain gen_xmlErrorDomain(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_FROM_C14N);
    if (no == 2) return(XML_FROM_CATALOG);
    if (no == 3) return(XML_FROM_CHECK);
    if (no == 4) return(XML_FROM_DATATYPE);
    return(0);
}
static void des_xmlErrorDomain(int no ATTRIBUTE_UNUSED, xmlErrorDomain val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlErrorDomain(xmlErrorDomain val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlErrorLevel 4
static xmlErrorLevel gen_xmlErrorLevel(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_ERR_ERROR);
    if (no == 2) return(XML_ERR_FATAL);
    if (no == 3) return(XML_ERR_NONE);
    if (no == 4) return(XML_ERR_WARNING);
    return(0);
}
static void des_xmlErrorLevel(int no ATTRIBUTE_UNUSED, xmlErrorLevel val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlErrorLevel(xmlErrorLevel val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserErrors 4
static xmlParserErrors gen_xmlParserErrors(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_C14N_CREATE_CTXT);
    if (no == 2) return(XML_C14N_CREATE_STACK);
    if (no == 3) return(XML_C14N_INVALID_NODE);
    if (no == 4) return(XML_C14N_REQUIRES_UTF8);
    return(0);
}
static void des_xmlParserErrors(int no ATTRIBUTE_UNUSED, xmlParserErrors val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlParserErrors(xmlParserErrors val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserInputState 4
static xmlParserInputState gen_xmlParserInputState(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_PARSER_ATTRIBUTE_VALUE);
    if (no == 2) return(XML_PARSER_CDATA_SECTION);
    if (no == 3) return(XML_PARSER_COMMENT);
    if (no == 4) return(XML_PARSER_CONTENT);
    return(0);
}
static void des_xmlParserInputState(int no ATTRIBUTE_UNUSED, xmlParserInputState val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlParserInputState(xmlParserInputState val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserMode 4
static xmlParserMode gen_xmlParserMode(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_PARSE_DOM);
    if (no == 2) return(XML_PARSE_PUSH_DOM);
    if (no == 3) return(XML_PARSE_PUSH_SAX);
    if (no == 4) return(XML_PARSE_READER);
    return(0);
}
static void des_xmlParserMode(int no ATTRIBUTE_UNUSED, xmlParserMode val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlParserMode(xmlParserMode val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserOption 4
static xmlParserOption gen_xmlParserOption(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_PARSE_DTDATTR);
    if (no == 2) return(XML_PARSE_DTDLOAD);
    if (no == 3) return(XML_PARSE_DTDVALID);
    if (no == 4) return(XML_PARSE_NOBLANKS);
    return(0);
}
static void des_xmlParserOption(int no ATTRIBUTE_UNUSED, xmlParserOption val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlParserOption(xmlParserOption val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserProperties 4
static xmlParserProperties gen_xmlParserProperties(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_PARSER_DEFAULTATTRS);
    if (no == 2) return(XML_PARSER_LOADDTD);
    if (no == 3) return(XML_PARSER_SUBST_ENTITIES);
    if (no == 4) return(XML_PARSER_VALIDATE);
    return(0);
}
static void des_xmlParserProperties(int no ATTRIBUTE_UNUSED, xmlParserProperties val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlParserProperties(xmlParserProperties val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserSeverities 4
static xmlParserSeverities gen_xmlParserSeverities(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_PARSER_SEVERITY_ERROR);
    if (no == 2) return(XML_PARSER_SEVERITY_VALIDITY_ERROR);
    if (no == 3) return(XML_PARSER_SEVERITY_VALIDITY_WARNING);
    if (no == 4) return(XML_PARSER_SEVERITY_WARNING);
    return(0);
}
static void des_xmlParserSeverities(int no ATTRIBUTE_UNUSED, xmlParserSeverities val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlParserSeverities(xmlParserSeverities val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlReaderTypes 4
static xmlReaderTypes gen_xmlReaderTypes(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_READER_TYPE_ATTRIBUTE);
    if (no == 2) return(XML_READER_TYPE_CDATA);
    if (no == 3) return(XML_READER_TYPE_COMMENT);
    if (no == 4) return(XML_READER_TYPE_DOCUMENT);
    return(0);
}
static void des_xmlReaderTypes(int no ATTRIBUTE_UNUSED, xmlReaderTypes val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlReaderTypes(xmlReaderTypes val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlRelaxNGParserFlag 3
static xmlRelaxNGParserFlag gen_xmlRelaxNGParserFlag(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_RELAXNGP_CRNG);
    if (no == 2) return(XML_RELAXNGP_FREE_DOC);
    if (no == 3) return(XML_RELAXNGP_NONE);
    return(0);
}
static void des_xmlRelaxNGParserFlag(int no ATTRIBUTE_UNUSED, xmlRelaxNGParserFlag val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlRelaxNGParserFlag(xmlRelaxNGParserFlag val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlRelaxNGValidErr 4
static xmlRelaxNGValidErr gen_xmlRelaxNGValidErr(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_RELAXNG_ERR_ATTREXTRANS);
    if (no == 2) return(XML_RELAXNG_ERR_ATTRNAME);
    if (no == 3) return(XML_RELAXNG_ERR_ATTRNONS);
    if (no == 4) return(XML_RELAXNG_ERR_ATTRVALID);
    return(0);
}
static void des_xmlRelaxNGValidErr(int no ATTRIBUTE_UNUSED, xmlRelaxNGValidErr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlRelaxNGValidErr(xmlRelaxNGValidErr val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaContentType 4
static xmlSchemaContentType gen_xmlSchemaContentType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_SCHEMA_CONTENT_ANY);
    if (no == 2) return(XML_SCHEMA_CONTENT_BASIC);
    if (no == 3) return(XML_SCHEMA_CONTENT_ELEMENTS);
    if (no == 4) return(XML_SCHEMA_CONTENT_EMPTY);
    return(0);
}
static void des_xmlSchemaContentType(int no ATTRIBUTE_UNUSED, xmlSchemaContentType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlSchemaContentType(xmlSchemaContentType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaTypeType 4
static xmlSchemaTypeType gen_xmlSchemaTypeType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_SCHEMA_FACET_ENUMERATION);
    if (no == 2) return(XML_SCHEMA_FACET_FRACTIONDIGITS);
    if (no == 3) return(XML_SCHEMA_FACET_LENGTH);
    if (no == 4) return(XML_SCHEMA_FACET_MAXEXCLUSIVE);
    return(0);
}
static void des_xmlSchemaTypeType(int no ATTRIBUTE_UNUSED, xmlSchemaTypeType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlSchemaTypeType(xmlSchemaTypeType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaValType 4
static xmlSchemaValType gen_xmlSchemaValType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_SCHEMAS_ANYSIMPLETYPE);
    if (no == 2) return(XML_SCHEMAS_ANYTYPE);
    if (no == 3) return(XML_SCHEMAS_ANYURI);
    if (no == 4) return(XML_SCHEMAS_BASE64BINARY);
    return(0);
}
static void des_xmlSchemaValType(int no ATTRIBUTE_UNUSED, xmlSchemaValType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlSchemaValType(xmlSchemaValType val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaValidError 4
static xmlSchemaValidError gen_xmlSchemaValidError(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_SCHEMAS_ERR_);
    if (no == 2) return(XML_SCHEMAS_ERR_ATTRINVALID);
    if (no == 3) return(XML_SCHEMAS_ERR_ATTRUNKNOWN);
    if (no == 4) return(XML_SCHEMAS_ERR_CONSTRUCT);
    return(0);
}
static void des_xmlSchemaValidError(int no ATTRIBUTE_UNUSED, xmlSchemaValidError val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlSchemaValidError(xmlSchemaValidError val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaValidOption 1
static xmlSchemaValidOption gen_xmlSchemaValidOption(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_SCHEMA_VAL_VC_I_CREATE);
    return(0);
}
static void des_xmlSchemaValidOption(int no ATTRIBUTE_UNUSED, xmlSchemaValidOption val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlSchemaValidOption(xmlSchemaValidOption val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlTextReaderMode 4
static xmlTextReaderMode gen_xmlTextReaderMode(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XML_TEXTREADER_MODE_CLOSED);
    if (no == 2) return(XML_TEXTREADER_MODE_EOF);
    if (no == 3) return(XML_TEXTREADER_MODE_ERROR);
    if (no == 4) return(XML_TEXTREADER_MODE_INITIAL);
    return(0);
}
static void des_xmlTextReaderMode(int no ATTRIBUTE_UNUSED, xmlTextReaderMode val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlTextReaderMode(xmlTextReaderMode val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlXPathError 4
static xmlXPathError gen_xmlXPathError(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XPATH_ENCODING_ERROR);
    if (no == 2) return(XPATH_EXPRESSION_OK);
    if (no == 3) return(XPATH_EXPR_ERROR);
    if (no == 4) return(XPATH_INVALID_ARITY);
    return(0);
}
static void des_xmlXPathError(int no ATTRIBUTE_UNUSED, xmlXPathError val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlXPathError(xmlXPathError val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlXPathObjectType 4
static xmlXPathObjectType gen_xmlXPathObjectType(int no, int nr ATTRIBUTE_UNUSED) {
    if (no == 1) return(XPATH_BOOLEAN);
    if (no == 2) return(XPATH_LOCATIONSET);
    if (no == 3) return(XPATH_NODESET);
    if (no == 4) return(XPATH_NUMBER);
    return(0);
}
static void des_xmlXPathObjectType(int no ATTRIBUTE_UNUSED, xmlXPathObjectType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}
static void desret_xmlXPathObjectType(xmlXPathObjectType val ATTRIBUTE_UNUSED) {
}

#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/catalog.h>
#include <libxml/chvalid.h>
#include <libxml/dict.h>
#include <libxml/encoding.h>
#include <libxml/entities.h>
#include <libxml/hash.h>
#include <libxml/list.h>
#include <libxml/nanoftp.h>
#include <libxml/nanohttp.h>
#include <libxml/parser.h>
#include <libxml/pattern.h>
#include <libxml/relaxng.h>
#include <libxml/schemasInternals.h>
#include <libxml/tree.h>
#include <libxml/uri.h>
#include <libxml/valid.h>
#include <libxml/xinclude.h>
#include <libxml/xmlIO.h>
#include <libxml/xmlerror.h>
#include <libxml/xmlreader.h>
#include <libxml/xmlsave.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>
#include <libxml/xmlstring.h>
#include <libxml/xmlunicode.h>
#include <libxml/xmlwriter.h>
#include <libxml/xpath.h>
#include <libxml/xpointer.h>
static int test_HTMLparser(void);
static int test_HTMLtree(void);
static int test_catalog(void);
static int test_chvalid(void);
static int test_dict(void);
static int test_encoding(void);
static int test_entities(void);
static int test_hash(void);
static int test_list(void);
static int test_nanoftp(void);
static int test_nanohttp(void);
static int test_parser(void);
static int test_pattern(void);
static int test_relaxng(void);
static int test_schemasInternals(void);
static int test_tree(void);
static int test_uri(void);
static int test_valid(void);
static int test_xinclude(void);
static int test_xmlIO(void);
static int test_xmlerror(void);
static int test_xmlreader(void);
static int test_xmlsave(void);
static int test_xmlschemas(void);
static int test_xmlschemastypes(void);
static int test_xmlstring(void);
static int test_xmlunicode(void);
static int test_xmlwriter(void);
static int test_xpath(void);
static int test_xpointer(void);

/**
 * testlibxml2:
 *
 * Main entry point of the tester for the full libxml2 module,
 * it calls all the tester entry point for each module.
 *
 * Returns the number of error found
 */
static int
testlibxml2(void)
{
    int ret = 0;

    ret += test_HTMLparser();
    ret += test_HTMLtree();
    ret += test_catalog();
    ret += test_chvalid();
    ret += test_dict();
    ret += test_encoding();
    ret += test_entities();
    ret += test_hash();
    ret += test_list();
    ret += test_nanoftp();
    ret += test_nanohttp();
    ret += test_parser();
    ret += test_pattern();
    ret += test_relaxng();
    ret += test_schemasInternals();
    ret += test_tree();
    ret += test_uri();
    ret += test_valid();
    ret += test_xinclude();
    ret += test_xmlIO();
    ret += test_xmlerror();
    ret += test_xmlreader();
    ret += test_xmlsave();
    ret += test_xmlschemas();
    ret += test_xmlschemastypes();
    ret += test_xmlstring();
    ret += test_xmlunicode();
    ret += test_xmlwriter();
    ret += test_xpath();
    ret += test_xpointer();

    printf("Total: %d functions, %d tests, %d errors\n",
           function_tests, call_tests, ret);
    return(ret);
}


#define gen_nb_unsigned_char_ptr 1
static unsigned char * gen_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, unsigned char * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_const_unsigned_char_ptr 1
static unsigned char * gen_const_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, const unsigned char * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_UTF8ToHtml(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    unsigned char * out; /* a pointer to an array of bytes to store the result */
    int n_out;
    int * outlen; /* the length of @out */
    int n_outlen;
    unsigned char * in; /* a pointer to an array of UTF-8 chars */
    int n_in;
    int * inlen; /* the length of @in */
    int n_inlen;

    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);

        ret_val = UTF8ToHtml(out, outlen, in, inlen);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in UTF8ToHtml",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_const_htmlElemDesc_ptr 1
static htmlElemDesc * gen_const_htmlElemDesc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_htmlElemDesc_ptr(int no ATTRIBUTE_UNUSED, const htmlElemDesc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_htmlAttrAllowed(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlStatus ret_val;
    htmlElemDesc * elt; /* HTML element */
    int n_elt;
    xmlChar * attr; /* HTML attribute */
    int n_attr;
    int legacy; /* whether to allow deprecated attributes */
    int n_legacy;

    for (n_elt = 0;n_elt < gen_nb_const_htmlElemDesc_ptr;n_elt++) {
    for (n_attr = 0;n_attr < gen_nb_const_xmlChar_ptr;n_attr++) {
    for (n_legacy = 0;n_legacy < gen_nb_int;n_legacy++) {
        mem_base = xmlMemBlocks();
        elt = gen_const_htmlElemDesc_ptr(n_elt, 0);
        attr = gen_const_xmlChar_ptr(n_attr, 1);
        legacy = gen_int(n_legacy, 2);

        ret_val = htmlAttrAllowed(elt, attr, legacy);
        desret_htmlStatus(ret_val);
        call_tests++;
        des_const_htmlElemDesc_ptr(n_elt, elt, 0);
        des_const_xmlChar_ptr(n_attr, attr, 1);
        des_int(n_legacy, legacy, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlAttrAllowed",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_elt);
            printf(" %d", n_attr);
            printf(" %d", n_legacy);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlAutoCloseTag(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the HTML document */
    int n_doc;
    xmlChar * name; /* The tag name */
    int n_name;
    htmlNodePtr elem; /* the HTML element */
    int n_elem;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = htmlAutoCloseTag(doc, name, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlAutoCloseTag",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCreateMemoryParserCtxt(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ret_val;
    char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = htmlCreateMemoryParserCtxt(buffer, size);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCreateMemoryParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_htmlSAXHandlerPtr 1
static htmlSAXHandlerPtr gen_htmlSAXHandlerPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_htmlSAXHandlerPtr(int no ATTRIBUTE_UNUSED, htmlSAXHandlerPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_htmlCreatePushParserCtxt(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    htmlParserCtxtPtr ret_val;
    htmlSAXHandlerPtr sax; /* a SAX handler */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks */
    int n_user_data;
    char * chunk; /* a pointer to an array of chars */
    int n_chunk;
    int size; /* number of chars in the array */
    int n_size;
    const char * filename; /* an optional file name or URI */
    int n_filename;
    xmlCharEncoding enc; /* an optional encoding */
    int n_enc;

    for (n_sax = 0;n_sax < gen_nb_htmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        sax = gen_htmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        chunk = gen_const_char_ptr(n_chunk, 2);
        size = gen_int(n_size, 3);
        filename = gen_filepath(n_filename, 4);
        enc = gen_xmlCharEncoding(n_enc, 5);

        ret_val = htmlCreatePushParserCtxt(sax, user_data, chunk, size, filename, enc);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_htmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_chunk, chunk, 2);
        des_int(n_size, size, 3);
        des_filepath(n_filename, filename, 4);
        des_xmlCharEncoding(n_enc, enc, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCreatePushParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtReadDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = htmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_cur, cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtReadFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const char * filename; /* a file or URL */
    int n_filename;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = htmlCtxtReadFile(ctxt, filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtReadMemory(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_int(n_options, 5);

        ret_val = htmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtReset(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        htmlCtxtReset(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlCtxtUseOptions(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        options = gen_int(n_options, 1);

        ret_val = htmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtUseOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlElementAllowedHere(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlElemDesc * parent; /* HTML parent element */
    int n_parent;
    xmlChar * elt; /* HTML element */
    int n_elt;

    for (n_parent = 0;n_parent < gen_nb_const_htmlElemDesc_ptr;n_parent++) {
    for (n_elt = 0;n_elt < gen_nb_const_xmlChar_ptr;n_elt++) {
        mem_base = xmlMemBlocks();
        parent = gen_const_htmlElemDesc_ptr(n_parent, 0);
        elt = gen_const_xmlChar_ptr(n_elt, 1);

        ret_val = htmlElementAllowedHere(parent, elt);
        desret_int(ret_val);
        call_tests++;
        des_const_htmlElemDesc_ptr(n_parent, parent, 0);
        des_const_xmlChar_ptr(n_elt, elt, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlElementAllowedHere",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_elt);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlElementStatusHere(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlStatus ret_val;
    htmlElemDesc * parent; /* HTML parent element */
    int n_parent;
    htmlElemDesc * elt; /* HTML element */
    int n_elt;

    for (n_parent = 0;n_parent < gen_nb_const_htmlElemDesc_ptr;n_parent++) {
    for (n_elt = 0;n_elt < gen_nb_const_htmlElemDesc_ptr;n_elt++) {
        mem_base = xmlMemBlocks();
        parent = gen_const_htmlElemDesc_ptr(n_parent, 0);
        elt = gen_const_htmlElemDesc_ptr(n_elt, 1);

        ret_val = htmlElementStatusHere(parent, elt);
        desret_htmlStatus(ret_val);
        call_tests++;
        des_const_htmlElemDesc_ptr(n_parent, parent, 0);
        des_const_htmlElemDesc_ptr(n_elt, elt, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlElementStatusHere",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_elt);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlEncodeEntities(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    unsigned char * out; /* a pointer to an array of bytes to store the result */
    int n_out;
    int * outlen; /* the length of @out */
    int n_outlen;
    unsigned char * in; /* a pointer to an array of UTF-8 chars */
    int n_in;
    int * inlen; /* the length of @in */
    int n_inlen;
    int quoteChar; /* the quote character to escape (' or ") or zero. */
    int n_quoteChar;

    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
    for (n_quoteChar = 0;n_quoteChar < gen_nb_int;n_quoteChar++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);
        quoteChar = gen_int(n_quoteChar, 4);

        ret_val = htmlEncodeEntities(out, outlen, in, inlen, quoteChar);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        des_int(n_quoteChar, quoteChar, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlEncodeEntities",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf(" %d", n_quoteChar);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlEntityLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlEntityValueLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlHandleOmittedElem(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = htmlHandleOmittedElem(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlHandleOmittedElem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlIsAutoClosed(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the HTML document */
    int n_doc;
    htmlNodePtr elem; /* the HTML element */
    int n_elem;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);

        ret_val = htmlIsAutoClosed(doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsAutoClosed",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlIsScriptAttribute(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * name; /* an attribute name */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = htmlIsScriptAttribute(name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsScriptAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_const_xmlNodePtr 1
static htmlNodePtr gen_const_xmlNodePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlNodePtr(int no ATTRIBUTE_UNUSED, const htmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_htmlNodeStatus(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlStatus ret_val;
    htmlNodePtr node; /* an htmlNodePtr in a tree */
    int n_node;
    int legacy; /* whether to allow deprecated elements (YES is faster here for Element nodes) */
    int n_legacy;

    for (n_node = 0;n_node < gen_nb_const_xmlNodePtr;n_node++) {
    for (n_legacy = 0;n_legacy < gen_nb_int;n_legacy++) {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNodePtr(n_node, 0);
        legacy = gen_int(n_legacy, 1);

        ret_val = htmlNodeStatus(node, legacy);
        desret_htmlStatus(ret_val);
        call_tests++;
        des_const_xmlNodePtr(n_node, node, 0);
        des_int(n_legacy, legacy, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeStatus",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_legacy);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseCharRef(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = htmlParseCharRef(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseCharRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseChunk(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    char * chunk; /* an char array */
    int n_chunk;
    int size; /* the size in byte of the chunk */
    int n_size;
    int terminate; /* last chunk indicator */
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        terminate = gen_int(n_terminate, 3);

        ret_val = htmlParseChunk(ctxt, chunk, size, terminate);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, chunk, 1);
        des_int(n_size, size, 2);
        des_int(n_terminate, terminate, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseChunk",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;
    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);

        ret_val = htmlParseDoc(cur, encoding);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseDocument(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = htmlParseDocument(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlParseElement(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        htmlParseElement(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_const_xmlChar_ptr_ptr 1
static xmlChar ** gen_const_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, const xmlChar ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_htmlParseEntityRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlParseFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    htmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;
    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);

        ret_val = htmlParseFile(filename, encoding);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        xmlResetLastError();
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlReadDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = htmlReadDoc(cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlReadFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_int(n_options, 2);

        ret_val = htmlReadFile(filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlReadMemory(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = htmlReadMemory(buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSAXParseDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;
    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;
    htmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    void * userData; /* if using SAX, this pointer will be provided on callbacks. */
    int n_userData;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_sax = 0;n_sax < gen_nb_htmlSAXHandlerPtr;n_sax++) {
    for (n_userData = 0;n_userData < gen_nb_userdata;n_userData++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        sax = gen_htmlSAXHandlerPtr(n_sax, 2);
        userData = gen_userdata(n_userData, 3);

        ret_val = htmlSAXParseDoc(cur, encoding, sax, userData);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_htmlSAXHandlerPtr(n_sax, sax, 2);
        des_userdata(n_userData, userData, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSAXParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_sax);
            printf(" %d", n_userData);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSAXParseFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;
    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;
    htmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    void * userData; /* if using SAX, this pointer will be provided on callbacks. */
    int n_userData;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_sax = 0;n_sax < gen_nb_htmlSAXHandlerPtr;n_sax++) {
    for (n_userData = 0;n_userData < gen_nb_userdata;n_userData++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        sax = gen_htmlSAXHandlerPtr(n_sax, 2);
        userData = gen_userdata(n_userData, 3);

        ret_val = htmlSAXParseFile(filename, encoding, sax, userData);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_htmlSAXHandlerPtr(n_sax, sax, 2);
        des_userdata(n_userData, userData, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSAXParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_sax);
            printf(" %d", n_userData);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlTagLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_HTMLparser(void) {
    int ret = 0;

    printf("Testing HTMLparser : 28 of 37 functions ...\n");
    ret += test_UTF8ToHtml();
    ret += test_htmlAttrAllowed();
    ret += test_htmlAutoCloseTag();
    ret += test_htmlCreateMemoryParserCtxt();
    ret += test_htmlCreatePushParserCtxt();
    ret += test_htmlCtxtReadDoc();
    ret += test_htmlCtxtReadFile();
    ret += test_htmlCtxtReadMemory();
    ret += test_htmlCtxtReset();
    ret += test_htmlCtxtUseOptions();
    ret += test_htmlElementAllowedHere();
    ret += test_htmlElementStatusHere();
    ret += test_htmlEncodeEntities();
    ret += test_htmlEntityLookup();
    ret += test_htmlEntityValueLookup();
    ret += test_htmlHandleOmittedElem();
    ret += test_htmlIsAutoClosed();
    ret += test_htmlIsScriptAttribute();
    ret += test_htmlNodeStatus();
    ret += test_htmlParseCharRef();
    ret += test_htmlParseChunk();
    ret += test_htmlParseDoc();
    ret += test_htmlParseDocument();
    ret += test_htmlParseElement();
    ret += test_htmlParseEntityRef();
    ret += test_htmlParseFile();
    ret += test_htmlReadDoc();
    ret += test_htmlReadFile();
    ret += test_htmlReadMemory();
    ret += test_htmlSAXParseDoc();
    ret += test_htmlSAXParseFile();
    ret += test_htmlTagLookup();

    if (ret != 0)
	printf("Module HTMLparser: %d errors\n", ret);
    return(ret);
}

static int
test_htmlDocContentDumpFormatOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    char * encoding; /* the encoding string */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        htmlDocContentDumpFormatOutput(buf, cur, encoding, format);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocContentDumpFormatOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlDocContentDumpOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    char * encoding; /* the encoding string */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        htmlDocContentDumpOutput(buf, cur, encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocContentDumpOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlDocDump(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * f; /* the FILE* */
    int n_f;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = htmlDocDump(f, cur);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlChar_ptr_ptr 1
static xmlChar ** gen_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, xmlChar ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_htmlDocDumpMemory(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlDocPtr cur; /* the document */
    int n_cur;
    xmlChar ** mem; /* OUT: the memory pointer */
    int n_mem;
    int * size; /* OUT: the memory length */
    int n_size;

    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_mem = 0;n_mem < gen_nb_xmlChar_ptr_ptr;n_mem++) {
    for (n_size = 0;n_size < gen_nb_int_ptr;n_size++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlDocPtr(n_cur, 0);
        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
        size = gen_int_ptr(n_size, 2);

        htmlDocDumpMemory(cur, mem, size);
        call_tests++;
        des_xmlDocPtr(n_cur, cur, 0);
        des_xmlChar_ptr_ptr(n_mem, mem, 1);
        des_int_ptr(n_size, size, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocDumpMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlGetMetaEncoding(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    htmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = htmlGetMetaEncoding(doc);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlGetMetaEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlIsBooleanAttr(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * name; /* the name of the attribute to check */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = htmlIsBooleanAttr(name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsBooleanAttr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNewDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * URI; /* URI for the dtd, or NULL */
    int n_URI;
    xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
    int n_ExternalID;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);

        ret_val = htmlNewDoc(URI, ExternalID);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNewDocNoDtD(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * URI; /* URI for the dtd, or NULL */
    int n_URI;
    xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
    int n_ExternalID;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);

        ret_val = htmlNewDocNoDtD(URI, ExternalID);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDocNoDtD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDump(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        ret_val = htmlNodeDump(buf, doc, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * out; /* the FILE pointer */
    int n_out;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;

    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        htmlNodeDumpFile(out, doc, cur);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpFileFormat(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * out; /* the FILE pointer */
    int n_out;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    char * encoding; /* the document encoding */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        format = gen_int(n_format, 4);

        ret_val = htmlNodeDumpFileFormat(out, doc, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFileFormat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpFormatOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    char * encoding; /* the encoding string */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        format = gen_int(n_format, 4);

        htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFormatOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlNodeDumpOutput(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the HTML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    char * encoding; /* the encoding string */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);

        htmlNodeDumpOutput(buf, doc, cur, encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSaveFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = htmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSaveFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    char * encoding; /* the document encoding */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = htmlSaveFileEnc(filename, cur, encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSaveFileFormat(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    char * encoding; /* the document encoding */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = htmlSaveFileFormat(filename, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileFormat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_htmlSetMetaEncoding(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * encoding; /* the encoding string */
    int n_encoding;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_xmlChar_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        encoding = gen_const_xmlChar_ptr(n_encoding, 1);

        ret_val = htmlSetMetaEncoding(doc, encoding);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_encoding, encoding, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSetMetaEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_HTMLtree(void) {
    int ret = 0;

    printf("Testing HTMLtree : 17 of 17 functions ...\n");
    ret += test_htmlDocContentDumpFormatOutput();
    ret += test_htmlDocContentDumpOutput();
    ret += test_htmlDocDump();
    ret += test_htmlDocDumpMemory();
    ret += test_htmlGetMetaEncoding();
    ret += test_htmlIsBooleanAttr();
    ret += test_htmlNewDoc();
    ret += test_htmlNewDocNoDtD();
    ret += test_htmlNodeDump();
    ret += test_htmlNodeDumpFile();
    ret += test_htmlNodeDumpFileFormat();
    ret += test_htmlNodeDumpFormatOutput();
    ret += test_htmlNodeDumpOutput();
    ret += test_htmlSaveFile();
    ret += test_htmlSaveFileEnc();
    ret += test_htmlSaveFileFormat();
    ret += test_htmlSetMetaEncoding();

    if (ret != 0)
	printf("Module HTMLtree: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlCatalogPtr 1
static xmlCatalogPtr gen_xmlCatalogPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlCatalogPtr(int no ATTRIBUTE_UNUSED, xmlCatalogPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlACatalogAdd(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    xmlCatalogPtr catal; /* a Catalog */
    int n_catal;
    xmlChar * type; /* the type of record to add to the catalog */
    int n_type;
    xmlChar * orig; /* the system, public or prefix to match */
    int n_orig;
    xmlChar * replace; /* the replacement value for the match */
    int n_replace;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    for (n_type = 0;n_type < gen_nb_const_xmlChar_ptr;n_type++) {
    for (n_orig = 0;n_orig < gen_nb_const_xmlChar_ptr;n_orig++) {
    for (n_replace = 0;n_replace < gen_nb_const_xmlChar_ptr;n_replace++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        type = gen_const_xmlChar_ptr(n_type, 1);
        orig = gen_const_xmlChar_ptr(n_orig, 2);
        replace = gen_const_xmlChar_ptr(n_replace, 3);

        ret_val = xmlACatalogAdd(catal, type, orig, replace);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_type, type, 1);
        des_const_xmlChar_ptr(n_orig, orig, 2);
        des_const_xmlChar_ptr(n_replace, replace, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogAdd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf(" %d", n_type);
            printf(" %d", n_orig);
            printf(" %d", n_replace);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlACatalogDump(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlCatalogPtr catal; /* a Catalog */
    int n_catal;
    FILE * out; /* the file. */
    int n_out;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        out = gen_FILE_ptr(n_out, 1);

        xmlACatalogDump(catal, out);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_FILE_ptr(n_out, out, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf(" %d", n_out);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlACatalogRemove(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    xmlCatalogPtr catal; /* a Catalog */
    int n_catal;
    xmlChar * value; /* the value to remove */
    int n_value;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = xmlACatalogRemove(catal, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogRemove",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlACatalogResolve(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal; /* a Catalog */
    int n_catal;
    xmlChar * pubID; /* the public ID string */
    int n_pubID;
    xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
        sysID = gen_const_xmlChar_ptr(n_sysID, 2);

        ret_val = xmlACatalogResolve(catal, pubID, sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_pubID, pubID, 1);
        des_const_xmlChar_ptr(n_sysID, sysID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlACatalogResolvePublic(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal; /* a Catalog */
    int n_catal;
    xmlChar * pubID; /* the public ID string */
    int n_pubID;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        pubID = gen_const_xmlChar_ptr(n_pubID, 1);

        ret_val = xmlACatalogResolvePublic(catal, pubID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_pubID, pubID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolvePublic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf(" %d", n_pubID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlACatalogResolveSystem(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal; /* a Catalog */
    int n_catal;
    xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        sysID = gen_const_xmlChar_ptr(n_sysID, 1);

        ret_val = xmlACatalogResolveSystem(catal, sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_sysID, sysID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolveSystem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlACatalogResolveURI(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal; /* a Catalog */
    int n_catal;
    xmlChar * URI; /* the URI */
    int n_URI;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        URI = gen_const_xmlChar_ptr(n_URI, 1);

        ret_val = xmlACatalogResolveURI(catal, URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_URI, URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolveURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogAdd(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * type; /* the type of record to add to the catalog */
    int n_type;
    xmlChar * orig; /* the system, public or prefix to match */
    int n_orig;
    xmlChar * replace; /* the replacement value for the match */
    int n_replace;

    for (n_type = 0;n_type < gen_nb_const_xmlChar_ptr;n_type++) {
    for (n_orig = 0;n_orig < gen_nb_const_xmlChar_ptr;n_orig++) {
    for (n_replace = 0;n_replace < gen_nb_const_xmlChar_ptr;n_replace++) {
        mem_base = xmlMemBlocks();
        type = gen_const_xmlChar_ptr(n_type, 0);
        orig = gen_const_xmlChar_ptr(n_orig, 1);
        replace = gen_const_xmlChar_ptr(n_replace, 2);

        ret_val = xmlCatalogAdd(type, orig, replace);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_type, type, 0);
        des_const_xmlChar_ptr(n_orig, orig, 1);
        des_const_xmlChar_ptr(n_replace, replace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogAdd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_orig);
            printf(" %d", n_replace);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogCleanup(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED


        xmlCatalogCleanup();
        call_tests++;
        xmlResetLastError();
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogConvert(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;


        ret_val = xmlCatalogConvert();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogDump(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * out; /* the file. */
    int n_out;

    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);

        xmlCatalogDump(out);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogGetDefaults(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlCatalogAllow ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlCatalogGetDefaults();
        desret_xmlCatalogAllow(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogGetDefaults",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogIsEmpty(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    xmlCatalogPtr catal; /* should this create an SGML catalog */
    int n_catal;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);

        ret_val = xmlCatalogIsEmpty(catal);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogIsEmpty",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogLocalResolve(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    void * catalogs; /* a document's list of catalogs */
    int n_catalogs;
    xmlChar * pubID; /* the public ID string */
    int n_pubID;
    xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_catalogs = 0;n_catalogs < gen_nb_void_ptr;n_catalogs++) {
    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        catalogs = gen_void_ptr(n_catalogs, 0);
        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
        sysID = gen_const_xmlChar_ptr(n_sysID, 2);

        ret_val = xmlCatalogLocalResolve(catalogs, pubID, sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_catalogs, catalogs, 0);
        des_const_xmlChar_ptr(n_pubID, pubID, 1);
        des_const_xmlChar_ptr(n_sysID, sysID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogLocalResolve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catalogs);
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogLocalResolveURI(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    void * catalogs; /* a document's list of catalogs */
    int n_catalogs;
    xmlChar * URI; /* the URI */
    int n_URI;

    for (n_catalogs = 0;n_catalogs < gen_nb_void_ptr;n_catalogs++) {
    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
        mem_base = xmlMemBlocks();
        catalogs = gen_void_ptr(n_catalogs, 0);
        URI = gen_const_xmlChar_ptr(n_URI, 1);

        ret_val = xmlCatalogLocalResolveURI(catalogs, URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_catalogs, catalogs, 0);
        des_const_xmlChar_ptr(n_URI, URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogLocalResolveURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catalogs);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogRemove(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;
    xmlChar * value; /* the value to remove */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlCatalogRemove(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolve(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlChar * pubID; /* the public ID string */
    int n_pubID;
    xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID, 0);
        sysID = gen_const_xmlChar_ptr(n_sysID, 1);

        ret_val = xmlCatalogResolve(pubID, sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, pubID, 0);
        des_const_xmlChar_ptr(n_sysID, sysID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolvePublic(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlChar * pubID; /* the public ID string */
    int n_pubID;

    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID, 0);

        ret_val = xmlCatalogResolvePublic(pubID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, pubID, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolvePublic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pubID);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolveSystem(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        sysID = gen_const_xmlChar_ptr(n_sysID, 0);

        ret_val = xmlCatalogResolveSystem(sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_sysID, sysID, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveSystem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogResolveURI(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlChar * URI; /* the URI */
    int n_URI;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);

        ret_val = xmlCatalogResolveURI(URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogSetDefaultPrefer(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlCatalogPrefer ret_val;
    xmlCatalogPrefer prefer; /* the default preference for delegation */
    int n_prefer;

    for (n_prefer = 0;n_prefer < gen_nb_xmlCatalogPrefer;n_prefer++) {
        mem_base = xmlMemBlocks();
        prefer = gen_xmlCatalogPrefer(n_prefer, 0);

        ret_val = xmlCatalogSetDefaultPrefer(prefer);
        desret_xmlCatalogPrefer(ret_val);
        call_tests++;
        des_xmlCatalogPrefer(n_prefer, prefer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogSetDefaultPrefer",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_prefer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCatalogSetDefaults(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlCatalogAllow allow; /* what catalogs should be accepted */
    int n_allow;

    for (n_allow = 0;n_allow < gen_nb_xmlCatalogAllow;n_allow++) {
        mem_base = xmlMemBlocks();
        allow = gen_xmlCatalogAllow(n_allow, 0);

        xmlCatalogSetDefaults(allow);
        call_tests++;
        des_xmlCatalogAllow(n_allow, allow, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogSetDefaults",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_allow);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlConvertSGMLCatalog(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    xmlCatalogPtr catal; /* the catalog */
    int n_catal;

    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);

        ret_val = xmlConvertSGMLCatalog(catal);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlConvertSGMLCatalog",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_catal);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlInitializeCatalog(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializeCatalog();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializeCatalog",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlLoadACatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlLoadCatalog(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;
    const char * filename; /* a file path */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlLoadCatalog(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlLoadCatalogs(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    char * pathss; /* a list of directories separated by a colon or a space. */
    int n_pathss;

    for (n_pathss = 0;n_pathss < gen_nb_const_char_ptr;n_pathss++) {
        pathss = gen_const_char_ptr(n_pathss, 0);

        xmlLoadCatalogs(pathss);
        call_tests++;
        des_const_char_ptr(n_pathss, pathss, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlLoadSGMLSuperCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseCatalogFile(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseCatalogFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCatalogFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_catalog(void) {
    int ret = 0;

    printf("Testing catalog : 27 of 36 functions ...\n");
    ret += test_xmlACatalogAdd();
    ret += test_xmlACatalogDump();
    ret += test_xmlACatalogRemove();
    ret += test_xmlACatalogResolve();
    ret += test_xmlACatalogResolvePublic();
    ret += test_xmlACatalogResolveSystem();
    ret += test_xmlACatalogResolveURI();
    ret += test_xmlCatalogAdd();
    ret += test_xmlCatalogCleanup();
    ret += test_xmlCatalogConvert();
    ret += test_xmlCatalogDump();
    ret += test_xmlCatalogGetDefaults();
    ret += test_xmlCatalogIsEmpty();
    ret += test_xmlCatalogLocalResolve();
    ret += test_xmlCatalogLocalResolveURI();
    ret += test_xmlCatalogRemove();
    ret += test_xmlCatalogResolve();
    ret += test_xmlCatalogResolvePublic();
    ret += test_xmlCatalogResolveSystem();
    ret += test_xmlCatalogResolveURI();
    ret += test_xmlCatalogSetDefaultPrefer();
    ret += test_xmlCatalogSetDefaults();
    ret += test_xmlConvertSGMLCatalog();
    ret += test_xmlInitializeCatalog();
    ret += test_xmlLoadACatalog();
    ret += test_xmlLoadCatalog();
    ret += test_xmlLoadCatalogs();
    ret += test_xmlLoadSGMLSuperCatalog();
    ret += test_xmlNewCatalog();
    ret += test_xmlParseCatalogFile();

    if (ret != 0)
	printf("Module catalog: %d errors\n", ret);
    return(ret);
}

#define gen_nb_const_xmlChRangeGroupPtr 1
static xmlChRangeGroupPtr gen_const_xmlChRangeGroupPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlChRangeGroupPtr(int no ATTRIBUTE_UNUSED, const xmlChRangeGroupPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlCharInRange(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int val; /* character to be validated */
    int n_val;
    xmlChRangeGroupPtr rptr; /* pointer to range to be used to validate */
    int n_rptr;

    for (n_val = 0;n_val < gen_nb_unsigned_int;n_val++) {
    for (n_rptr = 0;n_rptr < gen_nb_const_xmlChRangeGroupPtr;n_rptr++) {
        mem_base = xmlMemBlocks();
        val = gen_unsigned_int(n_val, 0);
        rptr = gen_const_xmlChRangeGroupPtr(n_rptr, 1);

        ret_val = xmlCharInRange(val, rptr);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_val, val, 0);
        des_const_xmlChRangeGroupPtr(n_rptr, rptr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharInRange",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf(" %d", n_rptr);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsBaseChar(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsBaseChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBaseChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsBlank(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsBlank(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBlank",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsChar(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsCombining(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsCombining(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsCombining",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsDigit(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsDigit(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsDigit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsExtender(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsExtender(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsExtender",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsIdeographic(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsIdeographic(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsIdeographic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsPubidChar(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch; /* character to validate */
    int n_ch;

    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsPubidChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsPubidChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}

static int
test_chvalid(void) {
    int ret = 0;

    printf("Testing chvalid : 9 of 9 functions ...\n");
    ret += test_xmlCharInRange();
    ret += test_xmlIsBaseChar();
    ret += test_xmlIsBlank();
    ret += test_xmlIsChar();
    ret += test_xmlIsCombining();
    ret += test_xmlIsDigit();
    ret += test_xmlIsExtender();
    ret += test_xmlIsIdeographic();
    ret += test_xmlIsPubidChar();

    if (ret != 0)
	printf("Module chvalid: %d errors\n", ret);
    return(ret);
}

static int
test_xmlDictCreate(void) {
    int ret = 0;

    int mem_base;
    xmlDictPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlDictCreate();
        desret_xmlDictPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictCreate",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlDictCreateSub(void) {
    int ret = 0;

    int mem_base;
    xmlDictPtr ret_val;
    xmlDictPtr sub; /* an existing dictionnary */
    int n_sub;

    for (n_sub = 0;n_sub < gen_nb_xmlDictPtr;n_sub++) {
        mem_base = xmlMemBlocks();
        sub = gen_xmlDictPtr(n_sub, 0);

        ret_val = xmlDictCreateSub(sub);
        desret_xmlDictPtr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_sub, sub, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictCreateSub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sub);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictLookup(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    int len; /* the length of the name, if -1 it is recomputed */
    int n_len;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlDictLookup(dict, name, len);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf(" %d", n_name);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictOwns(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;
    xmlChar * str; /* the string */
    int n_str;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlDictOwns(dict, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictOwns",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictQLookup(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;
    xmlChar * prefix; /* the prefix */
    int n_prefix;
    xmlChar * name; /* the name */
    int n_name;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlDictQLookup(dict, prefix, name);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictQLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictReference(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);

        ret_val = xmlDictReference(dict);
        xmlDictFree(dict);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictReference",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDictSize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict; /* the dictionnary */
    int n_dict;

    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);

        ret_val = xmlDictSize(dict);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictSize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dict);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}

static int
test_dict(void) {
    int ret = 0;

    printf("Testing dict : 7 of 8 functions ...\n");
    ret += test_xmlDictCreate();
    ret += test_xmlDictCreateSub();
    ret += test_xmlDictLookup();
    ret += test_xmlDictOwns();
    ret += test_xmlDictQLookup();
    ret += test_xmlDictReference();
    ret += test_xmlDictSize();

    if (ret != 0)
	printf("Module dict: %d errors\n", ret);
    return(ret);
}

static int
test_UTF8Toisolat1(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned char * out; /* a pointer to an array of bytes to store the result */
    int n_out;
    int * outlen; /* the length of @out */
    int n_outlen;
    unsigned char * in; /* a pointer to an array of UTF-8 chars */
    int n_in;
    int * inlen; /* the length of @in */
    int n_inlen;

    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);

        ret_val = UTF8Toisolat1(out, outlen, in, inlen);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in UTF8Toisolat1",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_isolat1ToUTF8(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned char * out; /* a pointer to an array of bytes to store the result */
    int n_out;
    int * outlen; /* the length of @out */
    int n_outlen;
    unsigned char * in; /* a pointer to an array of ISO Latin 1 chars */
    int n_in;
    int * inlen; /* the length of @in */
    int n_inlen;

    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);

        ret_val = isolat1ToUTF8(out, outlen, in, inlen);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in isolat1ToUTF8",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddEncodingAlias(void) {
    int ret = 0;

    int ret_val;
    char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
    int n_name;
    char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        name = gen_const_char_ptr(n_name, 0);
        alias = gen_const_char_ptr(n_alias, 1);

        ret_val = xmlAddEncodingAlias(name, alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_name, name, 0);
        des_const_char_ptr(n_alias, alias, 1);
        xmlResetLastError();
    }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_xmlCharEncodingHandler_ptr 1
static xmlCharEncodingHandler * gen_xmlCharEncodingHandler_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlCharEncodingHandler_ptr(int no ATTRIBUTE_UNUSED, xmlCharEncodingHandler * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlCharEncCloseFunc(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler; /* char enconding transformation data structure */
    int n_handler;

    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);

        ret_val = xmlCharEncCloseFunc(handler);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncCloseFunc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_handler);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCharEncFirstLine(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler; /* char enconding transformation data structure */
    int n_handler;
    xmlBufferPtr out; /* an xmlBuffer for the output. */
    int n_out;
    xmlBufferPtr in; /* an xmlBuffer for the input */
    int n_in;

    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
        out = gen_xmlBufferPtr(n_out, 1);
        in = gen_xmlBufferPtr(n_in, 2);

        ret_val = xmlCharEncFirstLine(handler, out, in);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        des_xmlBufferPtr(n_out, out, 1);
        des_xmlBufferPtr(n_in, in, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncFirstLine",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_handler);
            printf(" %d", n_out);
            printf(" %d", n_in);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCharEncInFunc(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
    int n_handler;
    xmlBufferPtr out; /* an xmlBuffer for the output. */
    int n_out;
    xmlBufferPtr in; /* an xmlBuffer for the input */
    int n_in;

    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
        out = gen_xmlBufferPtr(n_out, 1);
        in = gen_xmlBufferPtr(n_in, 2);

        ret_val = xmlCharEncInFunc(handler, out, in);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        des_xmlBufferPtr(n_out, out, 1);
        des_xmlBufferPtr(n_in, in, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncInFunc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_handler);
            printf(" %d", n_out);
            printf(" %d", n_in);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCharEncOutFunc(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler; /* char enconding transformation data structure */
    int n_handler;
    xmlBufferPtr out; /* an xmlBuffer for the output. */
    int n_out;
    xmlBufferPtr in; /* an xmlBuffer for the input */
    int n_in;

    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
        out = gen_xmlBufferPtr(n_out, 1);
        in = gen_xmlBufferPtr(n_in, 2);

        ret_val = xmlCharEncOutFunc(handler, out, in);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        des_xmlBufferPtr(n_out, out, 1);
        des_xmlBufferPtr(n_in, in, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncOutFunc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_handler);
            printf(" %d", n_out);
            printf(" %d", n_in);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCleanupCharEncodingHandlers(void) {
    int ret = 0;



        xmlCleanupCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();

    function_tests++;
    return(ret);
}


static int
test_xmlCleanupEncodingAliases(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupEncodingAliases();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupEncodingAliases",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlDelEncodingAlias(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0);

        ret_val = xmlDelEncodingAlias(alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, alias, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDelEncodingAlias",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDetectCharEncoding(void) {
    int ret = 0;

    int mem_base;
    xmlCharEncoding ret_val;
    unsigned char * in; /* a pointer to the first bytes of the XML entity, must be at least 2 bytes long (at least 4 if encoding is UTF4 variant). */
    int n_in;
    int len; /* pointer to the length of the buffer */
    int n_len;

    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_const_unsigned_char_ptr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlDetectCharEncoding(in, len);
        desret_xmlCharEncoding(ret_val);
        call_tests++;
        des_const_unsigned_char_ptr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDetectCharEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlFindCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCharEncodingName(void) {
    int ret = 0;

    int mem_base;
    const char * ret_val;
    xmlCharEncoding enc; /* the encoding */
    int n_enc;

    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        enc = gen_xmlCharEncoding(n_enc, 0);

        ret_val = xmlGetCharEncodingName(enc);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlCharEncoding(n_enc, enc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetCharEncodingName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_enc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetEncodingAlias(void) {
    int ret = 0;

    int mem_base;
    const char * ret_val;
    char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0);

        ret_val = xmlGetEncodingAlias(alias);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, alias, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetEncodingAlias",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlInitCharEncodingHandlers(void) {
    int ret = 0;



        xmlInitCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();

    function_tests++;
    return(ret);
}


static int
test_xmlNewCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseCharEncoding(void) {
    int ret = 0;

    int mem_base;
    xmlCharEncoding ret_val;
    char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_char_ptr(n_name, 0);

        ret_val = xmlParseCharEncoding(name);
        desret_xmlCharEncoding(ret_val);
        call_tests++;
        des_const_char_ptr(n_name, name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCharEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_xmlCharEncodingHandlerPtr 1
static xmlCharEncodingHandlerPtr gen_xmlCharEncodingHandlerPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlCharEncodingHandlerPtr(int no ATTRIBUTE_UNUSED, xmlCharEncodingHandlerPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlRegisterCharEncodingHandler(void) {
    int ret = 0;

    int mem_base;
    xmlCharEncodingHandlerPtr handler; /* the xmlCharEncodingHandlerPtr handler block */
    int n_handler;

    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandlerPtr;n_handler++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 0);

        xmlRegisterCharEncodingHandler(handler);
        call_tests++;
        des_xmlCharEncodingHandlerPtr(n_handler, handler, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterCharEncodingHandler",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_handler);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}

static int
test_encoding(void) {
    int ret = 0;

    printf("Testing encoding : 16 of 19 functions ...\n");
    ret += test_UTF8Toisolat1();
    ret += test_isolat1ToUTF8();
    ret += test_xmlAddEncodingAlias();
    ret += test_xmlCharEncCloseFunc();
    ret += test_xmlCharEncFirstLine();
    ret += test_xmlCharEncInFunc();
    ret += test_xmlCharEncOutFunc();
    ret += test_xmlCleanupCharEncodingHandlers();
    ret += test_xmlCleanupEncodingAliases();
    ret += test_xmlDelEncodingAlias();
    ret += test_xmlDetectCharEncoding();
    ret += test_xmlFindCharEncodingHandler();
    ret += test_xmlGetCharEncodingHandler();
    ret += test_xmlGetCharEncodingName();
    ret += test_xmlGetEncodingAlias();
    ret += test_xmlInitCharEncodingHandlers();
    ret += test_xmlNewCharEncodingHandler();
    ret += test_xmlParseCharEncoding();
    ret += test_xmlRegisterCharEncodingHandler();

    if (ret != 0)
	printf("Module encoding: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddDocEntity(void) {
    int ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * name; /* the entity name */
    int n_name;
    int type; /* the entity type XML_xxx_yyy_ENTITY */
    int n_type;
    xmlChar * ExternalID; /* the entity external ID if available */
    int n_ExternalID;
    xmlChar * SystemID; /* the entity system ID if available */
    int n_SystemID;
    xmlChar * content; /* the entity content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_int(n_type, 2);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
        content = gen_const_xmlChar_ptr(n_content, 5);

        ret_val = xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_int(n_type, type, 2);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 3);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 4);
        des_const_xmlChar_ptr(n_content, content, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddDocEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddDtdEntity(void) {
    int ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * name; /* the entity name */
    int n_name;
    int type; /* the entity type XML_xxx_yyy_ENTITY */
    int n_type;
    xmlChar * ExternalID; /* the entity external ID if available */
    int n_ExternalID;
    xmlChar * SystemID; /* the entity system ID if available */
    int n_SystemID;
    xmlChar * content; /* the entity content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_int(n_type, 2);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
        content = gen_const_xmlChar_ptr(n_content, 5);

        ret_val = xmlAddDtdEntity(doc, name, type, ExternalID, SystemID, content);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_int(n_type, type, 2);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 3);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 4);
        des_const_xmlChar_ptr(n_content, content, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddDtdEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCleanupPredefinedEntities(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupPredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupPredefinedEntities",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


#define gen_nb_xmlEntitiesTablePtr 1
static xmlEntitiesTablePtr gen_xmlEntitiesTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlEntitiesTablePtr(int no ATTRIBUTE_UNUSED, xmlEntitiesTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlCopyEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpEntitiesTable(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* An XML buffer. */
    int n_buf;
    xmlEntitiesTablePtr table; /* An entity table */
    int n_table;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_table = 0;n_table < gen_nb_xmlEntitiesTablePtr;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlEntitiesTablePtr(n_table, 1);

        xmlDumpEntitiesTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlEntitiesTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpEntitiesTable",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlEntityPtr 1
static xmlEntityPtr gen_xmlEntityPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlEntityPtr(int no ATTRIBUTE_UNUSED, xmlEntityPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlDumpEntityDecl(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* An XML buffer. */
    int n_buf;
    xmlEntityPtr ent; /* An entity table */
    int n_ent;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_ent = 0;n_ent < gen_nb_xmlEntityPtr;n_ent++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        ent = gen_xmlEntityPtr(n_ent, 1);

        xmlDumpEntityDecl(buf, ent);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlEntityPtr(n_ent, ent, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpEntityDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_ent);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlEncodeEntitiesReentrant(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document containing the string */
    int n_doc;
    xmlChar * input; /* A string to convert to XML. */
    int n_input;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        input = gen_const_xmlChar_ptr(n_input, 1);

        ret_val = xmlEncodeEntitiesReentrant(doc, input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_input, input, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeEntitiesReentrant",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlEncodeSpecialChars(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document containing the string */
    int n_doc;
    xmlChar * input; /* A string to convert to XML. */
    int n_input;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        input = gen_const_xmlChar_ptr(n_input, 1);

        ret_val = xmlEncodeSpecialChars(doc, input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_input, input, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeSpecialChars",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetDocEntity(void) {
    int ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc; /* the document referencing the entity */
    int n_doc;
    xmlChar * name; /* the entity name */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetDocEntity(doc, name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDocEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetDtdEntity(void) {
    int ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc; /* the document referencing the entity */
    int n_doc;
    xmlChar * name; /* the entity name */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetDtdEntity(doc, name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDtdEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetParameterEntity(void) {
    int ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc; /* the document referencing the entity */
    int n_doc;
    xmlChar * name; /* the entity name */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetParameterEntity(doc, name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetParameterEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetPredefinedEntity(void) {
    int ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlChar * name; /* the entity name */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = xmlGetPredefinedEntity(name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetPredefinedEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlInitializePredefinedEntities(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializePredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializePredefinedEntities",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}

static int
test_entities(void) {
    int ret = 0;

    printf("Testing entities : 12 of 16 functions ...\n");
    ret += test_xmlAddDocEntity();
    ret += test_xmlAddDtdEntity();
    ret += test_xmlCleanupPredefinedEntities();
    ret += test_xmlCopyEntitiesTable();
    ret += test_xmlCreateEntitiesTable();
    ret += test_xmlDumpEntitiesTable();
    ret += test_xmlDumpEntityDecl();
    ret += test_xmlEncodeEntitiesReentrant();
    ret += test_xmlEncodeSpecialChars();
    ret += test_xmlGetDocEntity();
    ret += test_xmlGetDtdEntity();
    ret += test_xmlGetParameterEntity();
    ret += test_xmlGetPredefinedEntity();
    ret += test_xmlInitializePredefinedEntities();

    if (ret != 0)
	printf("Module entities: %d errors\n", ret);
    return(ret);
}

static int
test_xmlHashAddEntry(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    void * userdata; /* a pointer to the userdata */
    int n_userdata;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        userdata = gen_userdata(n_userdata, 2);

        ret_val = xmlHashAddEntry(table, name, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_userdata(n_userdata, userdata, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashAddEntry2(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    void * userdata; /* a pointer to the userdata */
    int n_userdata;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        userdata = gen_userdata(n_userdata, 3);

        ret_val = xmlHashAddEntry2(table, name, name2, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        des_userdata(n_userdata, userdata, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry2",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashAddEntry3(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    xmlChar * name3; /* a third name of the userdata */
    int n_name3;
    void * userdata; /* a pointer to the userdata */
    int n_userdata;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);
        userdata = gen_userdata(n_userdata, 4);

        ret_val = xmlHashAddEntry3(table, name, name2, name3, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        des_const_xmlChar_ptr(n_name3, name3, 3);
        des_userdata(n_userdata, userdata, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashCopy(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashLookup(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * name; /* the name of the userdata */
    int n_name;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlHashLookup(table, name);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashLookup2(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    xmlChar * name2; /* a second name of the userdata */
    int n_name2;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);

        ret_val = xmlHashLookup2(table, name, name2);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup2",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashLookup3(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    xmlChar * name3; /* a third name of the userdata */
    int n_name3;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);

        ret_val = xmlHashLookup3(table, name, name2, name3);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_name2, name2, 2);
        des_const_xmlChar_ptr(n_name3, name3, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashQLookup(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * prefix; /* the prefix of the userdata */
    int n_prefix;
    xmlChar * name; /* the name of the userdata */
    int n_name;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlHashQLookup(table, prefix, name);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashQLookup2(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * prefix; /* the prefix of the userdata */
    int n_prefix;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    xmlChar * prefix2; /* the second prefix of the userdata */
    int n_prefix2;
    xmlChar * name2; /* a second name of the userdata */
    int n_name2;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_prefix2 = 0;n_prefix2 < gen_nb_const_xmlChar_ptr;n_prefix2++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
        name2 = gen_const_xmlChar_ptr(n_name2, 4);

        ret_val = xmlHashQLookup2(table, prefix, name, prefix2, name2);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_prefix2, prefix2, 3);
        des_const_xmlChar_ptr(n_name2, name2, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup2",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_prefix2);
            printf(" %d", n_name2);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashQLookup3(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;
    xmlChar * prefix; /* the prefix of the userdata */
    int n_prefix;
    xmlChar * name; /* the name of the userdata */
    int n_name;
    xmlChar * prefix2; /* the second prefix of the userdata */
    int n_prefix2;
    xmlChar * name2; /* a second name of the userdata */
    int n_name2;
    xmlChar * prefix3; /* the third prefix of the userdata */
    int n_prefix3;
    xmlChar * name3; /* a third name of the userdata */
    int n_name3;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_prefix2 = 0;n_prefix2 < gen_nb_const_xmlChar_ptr;n_prefix2++) {
    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    for (n_prefix3 = 0;n_prefix3 < gen_nb_const_xmlChar_ptr;n_prefix3++) {
    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
        name2 = gen_const_xmlChar_ptr(n_name2, 4);
        prefix3 = gen_const_xmlChar_ptr(n_prefix3, 5);
        name3 = gen_const_xmlChar_ptr(n_name3, 6);

        ret_val = xmlHashQLookup3(table, prefix, name, prefix2, name2, prefix3, name3);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_prefix2, prefix2, 3);
        des_const_xmlChar_ptr(n_name2, name2, 4);
        des_const_xmlChar_ptr(n_prefix3, prefix3, 5);
        des_const_xmlChar_ptr(n_name3, name3, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_prefix2);
            printf(" %d", n_name2);
            printf(" %d", n_prefix3);
            printf(" %d", n_name3);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashRemoveEntry(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashRemoveEntry2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashRemoveEntry3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScan(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScan3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScanFull(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScanFull3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashSize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table; /* the hash table */
    int n_table;

    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);

        ret_val = xmlHashSize(table);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashSize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_table);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHashUpdateEntry(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashUpdateEntry2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashUpdateEntry3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_hash(void) {
    int ret = 0;

    printf("Testing hash : 10 of 23 functions ...\n");
    ret += test_xmlHashAddEntry();
    ret += test_xmlHashAddEntry2();
    ret += test_xmlHashAddEntry3();
    ret += test_xmlHashCopy();
    ret += test_xmlHashCreate();
    ret += test_xmlHashLookup();
    ret += test_xmlHashLookup2();
    ret += test_xmlHashLookup3();
    ret += test_xmlHashQLookup();
    ret += test_xmlHashQLookup2();
    ret += test_xmlHashQLookup3();
    ret += test_xmlHashRemoveEntry();
    ret += test_xmlHashRemoveEntry2();
    ret += test_xmlHashRemoveEntry3();
    ret += test_xmlHashScan();
    ret += test_xmlHashScan3();
    ret += test_xmlHashScanFull();
    ret += test_xmlHashScanFull3();
    ret += test_xmlHashSize();
    ret += test_xmlHashUpdateEntry();
    ret += test_xmlHashUpdateEntry2();
    ret += test_xmlHashUpdateEntry3();

    if (ret != 0)
	printf("Module hash: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlLinkPtr 1
static xmlLinkPtr gen_xmlLinkPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlLinkPtr(int no ATTRIBUTE_UNUSED, xmlLinkPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlLinkGetData(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlLinkPtr lk; /* a link */
    int n_lk;

    for (n_lk = 0;n_lk < gen_nb_xmlLinkPtr;n_lk++) {
        mem_base = xmlMemBlocks();
        lk = gen_xmlLinkPtr(n_lk, 0);

        ret_val = xmlLinkGetData(lk);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlLinkPtr(n_lk, lk, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLinkGetData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_lk);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListAppend(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* the data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListAppend(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListAppend",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListClear(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListClear(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListClear",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_const_xmlListPtr 1
static xmlListPtr gen_const_xmlListPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlListPtr(int no ATTRIBUTE_UNUSED, const xmlListPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlListCopy(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr cur; /* the new list */
    int n_cur;
    xmlListPtr old; /* the old list */
    int n_old;

    for (n_cur = 0;n_cur < gen_nb_xmlListPtr;n_cur++) {
    for (n_old = 0;n_old < gen_nb_const_xmlListPtr;n_old++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlListPtr(n_cur, 0);
        old = gen_const_xmlListPtr(n_old, 1);

        ret_val = xmlListCopy(cur, old);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_cur, cur, 0);
        des_const_xmlListPtr(n_old, old, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListCopy",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_old);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListDup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListEmpty(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        ret_val = xmlListEmpty(l);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListEmpty",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListEnd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListFront(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListInsert(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* the data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListInsert(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListInsert",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListMerge(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l1; /* the original list */
    int n_l1;
    xmlListPtr l2; /* the new list */
    int n_l2;

    for (n_l1 = 0;n_l1 < gen_nb_xmlListPtr;n_l1++) {
    for (n_l2 = 0;n_l2 < gen_nb_xmlListPtr;n_l2++) {
        mem_base = xmlMemBlocks();
        l1 = gen_xmlListPtr(n_l1, 0);
        l2 = gen_xmlListPtr(n_l2, 1);

        xmlListMerge(l1, l2);
        call_tests++;
        des_xmlListPtr(n_l1, l1, 0);
        des_xmlListPtr(n_l2, l2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListMerge",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l1);
            printf(" %d", n_l2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPopBack(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListPopBack(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPopBack",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPopFront(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListPopFront(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPopFront",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPushBack(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* new data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListPushBack(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPushBack",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListPushFront(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* new data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListPushFront(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPushFront",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListRemoveAll(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* list data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveAll(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveAll",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListRemoveFirst(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* list data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveFirst(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveFirst",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListRemoveLast(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* list data */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveLast(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveLast",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListReverse(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListReverse(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListReverse",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListReverseSearch(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* a search value */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListReverseSearch(l, data);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListReverseSearch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListReverseWalk(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListSearch(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    xmlListPtr l; /* a list */
    int n_l;
    void * data; /* a search value */
    int n_data;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListSearch(l, data);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSearch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListSize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        ret_val = xmlListSize(l);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListSort(void) {
    int ret = 0;

    int mem_base;
    xmlListPtr l; /* a list */
    int n_l;

    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListSort(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSort",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlListWalk(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_list(void) {
    int ret = 0;

    printf("Testing list : 19 of 26 functions ...\n");
    ret += test_xmlLinkGetData();
    ret += test_xmlListAppend();
    ret += test_xmlListClear();
    ret += test_xmlListCopy();
    ret += test_xmlListCreate();
    ret += test_xmlListDup();
    ret += test_xmlListEmpty();
    ret += test_xmlListEnd();
    ret += test_xmlListFront();
    ret += test_xmlListInsert();
    ret += test_xmlListMerge();
    ret += test_xmlListPopBack();
    ret += test_xmlListPopFront();
    ret += test_xmlListPushBack();
    ret += test_xmlListPushFront();
    ret += test_xmlListRemoveAll();
    ret += test_xmlListRemoveFirst();
    ret += test_xmlListRemoveLast();
    ret += test_xmlListReverse();
    ret += test_xmlListReverseSearch();
    ret += test_xmlListReverseWalk();
    ret += test_xmlListSearch();
    ret += test_xmlListSize();
    ret += test_xmlListSort();
    ret += test_xmlListWalk();

    if (ret != 0)
	printf("Module list: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNanoFTPCheckResponse(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPCheckResponse(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCheckResponse",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPCleanup(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCleanup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPCloseConnection(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPCloseConnection(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCloseConnection",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPCwd(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;
    char * directory; /* a directory on the server */
    int n_directory;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    for (n_directory = 0;n_directory < gen_nb_const_char_ptr;n_directory++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        directory = gen_const_char_ptr(n_directory, 1);

        ret_val = xmlNanoFTPCwd(ctx, directory);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_const_char_ptr(n_directory, directory, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCwd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_directory);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPDele(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;
    const char * file; /* a file or directory on the server */
    int n_file;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    for (n_file = 0;n_file < gen_nb_filepath;n_file++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        file = gen_filepath(n_file, 1);

        ret_val = xmlNanoFTPDele(ctx, file);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_filepath(n_file, file, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPDele",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_file);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPGet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGetConnection(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPGetConnection(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPGetConnection",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPGetResponse(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPGetResponse(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPGetResponse",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPGetSocket(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;
    const char * filename; /* the file to retrieve (or NULL if path is in context). */
    int n_filename;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        filename = gen_filepath(n_filename, 1);

        ret_val = xmlNanoFTPGetSocket(ctx, filename);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_filepath(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPGetSocket",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPInit(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPNewCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPOpen(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * URL; /* the URL to the resource */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);

        ret_val = xmlNanoFTPOpen(URL);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URL);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPProxy(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    char * host; /* the proxy host name */
    int n_host;
    int port; /* the proxy port */
    int n_port;
    char * user; /* the proxy user name */
    int n_user;
    char * passwd; /* the proxy password */
    int n_passwd;
    int type; /* the type of proxy 1 for using SITE, 2 for USER a@b */
    int n_type;

    for (n_host = 0;n_host < gen_nb_const_char_ptr;n_host++) {
    for (n_port = 0;n_port < gen_nb_int;n_port++) {
    for (n_user = 0;n_user < gen_nb_const_char_ptr;n_user++) {
    for (n_passwd = 0;n_passwd < gen_nb_const_char_ptr;n_passwd++) {
    for (n_type = 0;n_type < gen_nb_int;n_type++) {
        host = gen_const_char_ptr(n_host, 0);
        port = gen_int(n_port, 1);
        user = gen_const_char_ptr(n_user, 2);
        passwd = gen_const_char_ptr(n_passwd, 3);
        type = gen_int(n_type, 4);

        xmlNanoFTPProxy(host, port, user, passwd, type);
        call_tests++;
        des_const_char_ptr(n_host, host, 0);
        des_int(n_port, port, 1);
        des_const_char_ptr(n_user, user, 2);
        des_const_char_ptr(n_passwd, passwd, 3);
        des_int(n_type, type, 4);
        xmlResetLastError();
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPQuit(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPQuit(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPQuit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPRead(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* the FTP context */
    int n_ctx;
    void * dest; /* a buffer */
    int n_dest;
    int len; /* the buffer length */
    int n_len;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    for (n_dest = 0;n_dest < gen_nb_void_ptr;n_dest++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        dest = gen_void_ptr(n_dest, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNanoFTPRead(ctx, dest, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_void_ptr(n_dest, dest, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_dest);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPScanProxy(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    const char * URL; /* The proxy URL used to initialize the proxy context */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        URL = gen_filepath(n_URL, 0);

        xmlNanoFTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoFTPUpdateURL(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* an FTP context */
    int n_ctx;
    const char * URL; /* The URL used to update the context */
    int n_URL;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        URL = gen_filepath(n_URL, 1);

        ret_val = xmlNanoFTPUpdateURL(ctx, URL);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_filepath(n_URL, URL, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPUpdateURL",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_URL);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_nanoftp(void) {
    int ret = 0;

    printf("Testing nanoftp : 15 of 22 functions ...\n");
    ret += test_xmlNanoFTPCheckResponse();
    ret += test_xmlNanoFTPCleanup();
    ret += test_xmlNanoFTPCloseConnection();
    ret += test_xmlNanoFTPCwd();
    ret += test_xmlNanoFTPDele();
    ret += test_xmlNanoFTPGet();
    ret += test_xmlNanoFTPGetConnection();
    ret += test_xmlNanoFTPGetResponse();
    ret += test_xmlNanoFTPGetSocket();
    ret += test_xmlNanoFTPInit();
    ret += test_xmlNanoFTPList();
    ret += test_xmlNanoFTPNewCtxt();
    ret += test_xmlNanoFTPOpen();
    ret += test_xmlNanoFTPProxy();
    ret += test_xmlNanoFTPQuit();
    ret += test_xmlNanoFTPRead();
    ret += test_xmlNanoFTPScanProxy();
    ret += test_xmlNanoFTPUpdateURL();

    if (ret != 0)
	printf("Module nanoftp: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNanoHTTPAuthHeader(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    const char * ret_val;
    void * ctx; /* the HTTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPAuthHeader(ctx);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPAuthHeader",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPCleanup(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPCleanup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPClose(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    void * ctx; /* the HTTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        xmlNanoHTTPClose(ctx);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPContentLength(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* the HTTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPContentLength(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPContentLength",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPEncoding(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    const char * ret_val;
    void * ctx; /* the HTTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPEncoding(ctx);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_char_ptr_ptr 1
static char ** gen_char_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_char_ptr_ptr(int no ATTRIBUTE_UNUSED, char ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlNanoHTTPFetch(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    const char * URL; /* The URL to load */
    int n_URL;
    const char * filename; /* the filename where the content should be saved */
    int n_filename;
    char ** contentType; /* if available the Content-Type information will be returned at that location */
    int n_contentType;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        filename = gen_filepath(n_filename, 1);
        contentType = gen_char_ptr_ptr(n_contentType, 2);

        ret_val = xmlNanoHTTPFetch(URL, filename, contentType);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_filepath(n_filename, filename, 1);
        des_char_ptr_ptr(n_contentType, contentType, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPFetch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URL);
            printf(" %d", n_filename);
            printf(" %d", n_contentType);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPInit(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPMethod(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * URL; /* The URL to load */
    int n_URL;
    char * method; /* the HTTP method to use */
    int n_method;
    char * input; /* the input string if any */
    int n_input;
    char ** contentType; /* the Content-Type information IN and OUT */
    int n_contentType;
    char * headers; /* the extra headers */
    int n_headers;
    int ilen; /* input length */
    int n_ilen;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_method = 0;n_method < gen_nb_const_char_ptr;n_method++) {
    for (n_input = 0;n_input < gen_nb_const_char_ptr;n_input++) {
    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
    for (n_headers = 0;n_headers < gen_nb_const_char_ptr;n_headers++) {
    for (n_ilen = 0;n_ilen < gen_nb_int;n_ilen++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        method = gen_const_char_ptr(n_method, 1);
        input = gen_const_char_ptr(n_input, 2);
        contentType = gen_char_ptr_ptr(n_contentType, 3);
        headers = gen_const_char_ptr(n_headers, 4);
        ilen = gen_int(n_ilen, 5);

        ret_val = xmlNanoHTTPMethod(URL, method, input, contentType, headers, ilen);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_const_char_ptr(n_method, method, 1);
        des_const_char_ptr(n_input, input, 2);
        des_char_ptr_ptr(n_contentType, contentType, 3);
        des_const_char_ptr(n_headers, headers, 4);
        des_int(n_ilen, ilen, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPMethod",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URL);
            printf(" %d", n_method);
            printf(" %d", n_input);
            printf(" %d", n_contentType);
            printf(" %d", n_headers);
            printf(" %d", n_ilen);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPMethodRedir(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * URL; /* The URL to load */
    int n_URL;
    char * method; /* the HTTP method to use */
    int n_method;
    char * input; /* the input string if any */
    int n_input;
    char ** contentType; /* the Content-Type information IN and OUT */
    int n_contentType;
    char ** redir; /* the redirected URL OUT */
    int n_redir;
    char * headers; /* the extra headers */
    int n_headers;
    int ilen; /* input length */
    int n_ilen;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_method = 0;n_method < gen_nb_const_char_ptr;n_method++) {
    for (n_input = 0;n_input < gen_nb_const_char_ptr;n_input++) {
    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
    for (n_redir = 0;n_redir < gen_nb_char_ptr_ptr;n_redir++) {
    for (n_headers = 0;n_headers < gen_nb_const_char_ptr;n_headers++) {
    for (n_ilen = 0;n_ilen < gen_nb_int;n_ilen++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        method = gen_const_char_ptr(n_method, 1);
        input = gen_const_char_ptr(n_input, 2);
        contentType = gen_char_ptr_ptr(n_contentType, 3);
        redir = gen_char_ptr_ptr(n_redir, 4);
        headers = gen_const_char_ptr(n_headers, 5);
        ilen = gen_int(n_ilen, 6);

        ret_val = xmlNanoHTTPMethodRedir(URL, method, input, contentType, redir, headers, ilen);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_const_char_ptr(n_method, method, 1);
        des_const_char_ptr(n_input, input, 2);
        des_char_ptr_ptr(n_contentType, contentType, 3);
        des_char_ptr_ptr(n_redir, redir, 4);
        des_const_char_ptr(n_headers, headers, 5);
        des_int(n_ilen, ilen, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPMethodRedir",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URL);
            printf(" %d", n_method);
            printf(" %d", n_input);
            printf(" %d", n_contentType);
            printf(" %d", n_redir);
            printf(" %d", n_headers);
            printf(" %d", n_ilen);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPMimeType(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    const char * ret_val;
    void * ctx; /* the HTTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPMimeType(ctx);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPMimeType",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPOpen(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * URL; /* The URL to load */
    int n_URL;
    char ** contentType; /* if available the Content-Type information will be returned at that location */
    int n_contentType;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        contentType = gen_char_ptr_ptr(n_contentType, 1);

        ret_val = xmlNanoHTTPOpen(URL, contentType);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_char_ptr_ptr(n_contentType, contentType, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URL);
            printf(" %d", n_contentType);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPOpenRedir(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * URL; /* The URL to load */
    int n_URL;
    char ** contentType; /* if available the Content-Type information will be returned at that location */
    int n_contentType;
    char ** redir; /* if available the redirected URL will be returned */
    int n_redir;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
    for (n_redir = 0;n_redir < gen_nb_char_ptr_ptr;n_redir++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        contentType = gen_char_ptr_ptr(n_contentType, 1);
        redir = gen_char_ptr_ptr(n_redir, 2);

        ret_val = xmlNanoHTTPOpenRedir(URL, contentType, redir);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_char_ptr_ptr(n_contentType, contentType, 1);
        des_char_ptr_ptr(n_redir, redir, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPOpenRedir",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URL);
            printf(" %d", n_contentType);
            printf(" %d", n_redir);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPRead(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* the HTTP context */
    int n_ctx;
    void * dest; /* a buffer */
    int n_dest;
    int len; /* the buffer length */
    int n_len;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
    for (n_dest = 0;n_dest < gen_nb_void_ptr;n_dest++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
        dest = gen_void_ptr(n_dest, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNanoHTTPRead(ctx, dest, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        des_void_ptr(n_dest, dest, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_dest);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPRedir(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPReturnCode(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    void * ctx; /* the HTTP context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPReturnCode(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPReturnCode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPSave(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    void * ctxt; /* the HTTP context */
    int n_ctxt;
    const char * filename; /* the filename where the content should be saved */
    int n_filename;

    for (n_ctxt = 0;n_ctxt < gen_nb_void_ptr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_void_ptr(n_ctxt, 0);
        filename = gen_fileoutput(n_filename, 1);

        ret_val = xmlNanoHTTPSave(ctxt, filename);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctxt, ctxt, 0);
        des_fileoutput(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPSave",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNanoHTTPScanProxy(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    const char * URL; /* The proxy URL used to initialize the proxy context */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        URL = gen_filepath(n_URL, 0);

        xmlNanoHTTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_nanohttp(void) {
    int ret = 0;

    printf("Testing nanohttp : 16 of 17 functions ...\n");
    ret += test_xmlNanoHTTPAuthHeader();
    ret += test_xmlNanoHTTPCleanup();
    ret += test_xmlNanoHTTPClose();
    ret += test_xmlNanoHTTPContentLength();
    ret += test_xmlNanoHTTPEncoding();
    ret += test_xmlNanoHTTPFetch();
    ret += test_xmlNanoHTTPInit();
    ret += test_xmlNanoHTTPMethod();
    ret += test_xmlNanoHTTPMethodRedir();
    ret += test_xmlNanoHTTPMimeType();
    ret += test_xmlNanoHTTPOpen();
    ret += test_xmlNanoHTTPOpenRedir();
    ret += test_xmlNanoHTTPRead();
    ret += test_xmlNanoHTTPRedir();
    ret += test_xmlNanoHTTPReturnCode();
    ret += test_xmlNanoHTTPSave();
    ret += test_xmlNanoHTTPScanProxy();

    if (ret != 0)
	printf("Module nanohttp: %d errors\n", ret);
    return(ret);
}

static int
test_xmlByteConsumed(void) {
    int ret = 0;

    int mem_base;
    long ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlByteConsumed(ctxt);
        desret_long(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlByteConsumed",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_xmlParserNodeInfoSeqPtr 1
static xmlParserNodeInfoSeqPtr gen_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, xmlParserNodeInfoSeqPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlClearNodeInfoSeq(void) {
    int ret = 0;

    int mem_base;
    xmlParserNodeInfoSeqPtr seq; /* a node info sequence pointer */
    int n_seq;

    for (n_seq = 0;n_seq < gen_nb_xmlParserNodeInfoSeqPtr;n_seq++) {
        mem_base = xmlMemBlocks();
        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0);

        xmlClearNodeInfoSeq(seq);
        call_tests++;
        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlClearNodeInfoSeq",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_seq);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlClearParserCtxt(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlClearParserCtxt(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlClearParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCreateDocParserCtxt(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlCreateDocParserCtxt(cur);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateDocParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCreateIOParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreatePushParserCtxt(void) {
    int ret = 0;

#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    xmlParserCtxtPtr ret_val;
    xmlSAXHandlerPtr sax; /* a SAX handler */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks */
    int n_user_data;
    char * chunk; /* a pointer to an array of chars */
    int n_chunk;
    int size; /* number of chars in the array */
    int n_size;
    const char * filename; /* an optional file name or URI */
    int n_filename;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        chunk = gen_const_char_ptr(n_chunk, 2);
        size = gen_int(n_size, 3);
        filename = gen_filepath(n_filename, 4);

        ret_val = xmlCreatePushParserCtxt(sax, user_data, chunk, size, filename);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_chunk, chunk, 2);
        des_int(n_size, size, 3);
        des_filepath(n_filename, filename, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreatePushParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReadDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_cur, cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReadFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * filename; /* a file or URL */
    int n_filename;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlCtxtReadFile(ctxt, filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReadMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_int(n_options, 5);

        ret_val = xmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtReset(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlCtxtReset(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtResetPush(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    char * chunk; /* a pointer to an array of chars */
    int n_chunk;
    int size; /* number of chars in the array */
    int n_size;
    const char * filename; /* an optional file name or URI */
    int n_filename;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        filename = gen_filepath(n_filename, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);

        ret_val = xmlCtxtResetPush(ctxt, chunk, size, filename, encoding);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, chunk, 1);
        des_int(n_size, size, 2);
        des_filepath(n_filename, filename, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtResetPush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtUseOptions(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        options = gen_int(n_options, 1);

        ret_val = xmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtUseOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetFeature(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML/HTML parser context */
    int n_ctxt;
    char * name; /* the feature name */
    int n_name;
    void * result; /* location to store the result */
    int n_result;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    for (n_result = 0;n_result < gen_nb_void_ptr;n_result++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        name = gen_const_char_ptr(n_name, 1);
        result = gen_void_ptr(n_result, 2);

        ret_val = xmlGetFeature(ctxt, name, result);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_name, name, 1);
        des_void_ptr(n_result, result, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetFeature",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_result);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_const_char_ptr_ptr 1
static char ** gen_const_char_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_char_ptr_ptr(int no ATTRIBUTE_UNUSED, const char ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlGetFeaturesList(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int * len; /* the length of the features name array (input/output) */
    int n_len;
    char ** result; /* an array of string to be filled with the features name. */
    int n_result;

    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    for (n_result = 0;n_result < gen_nb_const_char_ptr_ptr;n_result++) {
        mem_base = xmlMemBlocks();
        len = gen_int_ptr(n_len, 0);
        result = gen_const_char_ptr_ptr(n_result, 1);

        ret_val = xmlGetFeaturesList(len, result);
        desret_int(ret_val);
        call_tests++;
        des_int_ptr(n_len, len, 0);
        des_const_char_ptr_ptr(n_result, result, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetFeaturesList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_len);
            printf(" %d", n_result);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIOParseDTD(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block or NULL */
    int n_sax;
    xmlParserInputBufferPtr input; /* an Input Buffer */
    int n_input;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        input = gen_xmlParserInputBufferPtr(n_input, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlIOParseDTD(sax, input, enc);
        input = NULL;
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_xmlParserInputBufferPtr(n_input, input, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOParseDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_input);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlInitNodeInfoSeq(void) {
    int ret = 0;

    int mem_base;
    xmlParserNodeInfoSeqPtr seq; /* a node info sequence pointer */
    int n_seq;

    for (n_seq = 0;n_seq < gen_nb_xmlParserNodeInfoSeqPtr;n_seq++) {
        mem_base = xmlMemBlocks();
        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0);

        xmlInitNodeInfoSeq(seq);
        call_tests++;
        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitNodeInfoSeq",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_seq);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlInitParser(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitParser();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParser",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlInitParserCtxt(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlInitParserCtxt(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlKeepBlanksDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlKeepBlanksDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlKeepBlanksDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlLineNumbersDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlLineNumbersDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLineNumbersDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlLoadExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewIOInputStream(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewParserCtxt(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlNewParserCtxt();
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


#define gen_nb_xmlNodePtr_ptr 1
static xmlNodePtr * gen_xmlNodePtr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlNodePtr_ptr(int no ATTRIBUTE_UNUSED, xmlNodePtr * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlParseBalancedChunkMemory(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document the chunk pertains to */
    int n_doc;
    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
    int n_user_data;
    int depth; /* Used for loop detection, use 0 */
    int n_depth;
    xmlChar * string; /* the input string in UTF8 or ISO-Latin (zero terminated) */
    int n_string;
    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
    int n_lst;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
        user_data = gen_userdata(n_user_data, 2);
        depth = gen_int(n_depth, 3);
        string = gen_const_xmlChar_ptr(n_string, 4);
        lst = gen_xmlNodePtr_ptr(n_lst, 5);
        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;

        ret_val = xmlParseBalancedChunkMemory(doc, sax, user_data, depth, string, lst);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlSAXHandlerPtr(n_sax, sax, 1);
        des_userdata(n_user_data, user_data, 2);
        des_int(n_depth, depth, 3);
        des_const_xmlChar_ptr(n_string, string, 4);
        des_xmlNodePtr_ptr(n_lst, lst, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseBalancedChunkMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_depth);
            printf(" %d", n_string);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseBalancedChunkMemoryRecover(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document the chunk pertains to */
    int n_doc;
    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
    int n_user_data;
    int depth; /* Used for loop detection, use 0 */
    int n_depth;
    xmlChar * string; /* the input string in UTF8 or ISO-Latin (zero terminated) */
    int n_string;
    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
    int n_lst;
    int recover; /* return nodes even if the data is broken (use 0) */
    int n_recover;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
    for (n_recover = 0;n_recover < gen_nb_int;n_recover++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
        user_data = gen_userdata(n_user_data, 2);
        depth = gen_int(n_depth, 3);
        string = gen_const_xmlChar_ptr(n_string, 4);
        lst = gen_xmlNodePtr_ptr(n_lst, 5);
        recover = gen_int(n_recover, 6);
        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;

        ret_val = xmlParseBalancedChunkMemoryRecover(doc, sax, user_data, depth, string, lst, recover);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlSAXHandlerPtr(n_sax, sax, 1);
        des_userdata(n_user_data, user_data, 2);
        des_int(n_depth, depth, 3);
        des_const_xmlChar_ptr(n_string, string, 4);
        des_xmlNodePtr_ptr(n_lst, lst, 5);
        des_int(n_recover, recover, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseBalancedChunkMemoryRecover",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_depth);
            printf(" %d", n_string);
            printf(" %d", n_lst);
            printf(" %d", n_recover);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseChunk(void) {
    int ret = 0;

#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    char * chunk; /* an char array */
    int n_chunk;
    int size; /* the size in byte of the chunk */
    int n_size;
    int terminate; /* last chunk indicator */
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        terminate = gen_int(n_terminate, 3);

        ret_val = xmlParseChunk(ctxt, chunk, size, terminate);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, chunk, 1);
        des_int(n_size, size, 2);
        des_int(n_terminate, terminate, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseChunk",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlParseCtxtExternalEntity(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctx; /* the existing parsing context */
    int n_ctx;
    xmlChar * URL; /* the URL for the entity to load */
    int n_URL;
    xmlChar * ID; /* the System ID for the entity to load */
    int n_ID;
    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
    int n_lst;

    for (n_ctx = 0;n_ctx < gen_nb_xmlParserCtxtPtr;n_ctx++) {
    for (n_URL = 0;n_URL < gen_nb_const_xmlChar_ptr;n_URL++) {
    for (n_ID = 0;n_ID < gen_nb_const_xmlChar_ptr;n_ID++) {
    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlParserCtxtPtr(n_ctx, 0);
        URL = gen_const_xmlChar_ptr(n_URL, 1);
        ID = gen_const_xmlChar_ptr(n_ID, 2);
        lst = gen_xmlNodePtr_ptr(n_lst, 3);

        ret_val = xmlParseCtxtExternalEntity(ctx, URL, ID, lst);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_URL, URL, 1);
        des_const_xmlChar_ptr(n_ID, ID, 2);
        des_xmlNodePtr_ptr(n_lst, lst, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCtxtExternalEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_URL);
            printf(" %d", n_ID);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseDTD(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlChar * ExternalID; /* a NAME* containing the External ID of the DTD */
    int n_ExternalID;
    xmlChar * SystemID; /* a NAME* containing the URL to the DTD */
    int n_SystemID;

    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 0);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 1);

        ret_val = xmlParseDTD(ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 0);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);

        ret_val = xmlParseDoc(cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseDocument(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlParseDocument(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseEntity(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseEntity(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseExtParsedEnt(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlParseExtParsedEnt(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseExtParsedEnt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseExternalEntity(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document the chunk pertains to */
    int n_doc;
    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
    int n_user_data;
    int depth; /* Used for loop detection, use 0 */
    int n_depth;
    xmlChar * URL; /* the URL for the entity to load */
    int n_URL;
    xmlChar * ID; /* the System ID for the entity to load */
    int n_ID;
    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
    int n_lst;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    for (n_URL = 0;n_URL < gen_nb_const_xmlChar_ptr;n_URL++) {
    for (n_ID = 0;n_ID < gen_nb_const_xmlChar_ptr;n_ID++) {
    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
        user_data = gen_userdata(n_user_data, 2);
        depth = gen_int(n_depth, 3);
        URL = gen_const_xmlChar_ptr(n_URL, 4);
        ID = gen_const_xmlChar_ptr(n_ID, 5);
        lst = gen_xmlNodePtr_ptr(n_lst, 6);

        ret_val = xmlParseExternalEntity(doc, sax, user_data, depth, URL, ID, lst);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlSAXHandlerPtr(n_sax, sax, 1);
        des_userdata(n_user_data, user_data, 2);
        des_int(n_depth, depth, 3);
        des_const_xmlChar_ptr(n_URL, URL, 4);
        des_const_xmlChar_ptr(n_ID, ID, 5);
        des_xmlNodePtr_ptr(n_lst, lst, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseExternalEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_depth);
            printf(" %d", n_URL);
            printf(" %d", n_ID);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseInNodeContext(void) {
    int ret = 0;

    int mem_base;
    xmlParserErrors ret_val;
    xmlNodePtr node; /* the context node */
    int n_node;
    char * data; /* the input string */
    int n_data;
    int datalen; /* the input string length in bytes */
    int n_datalen;
    int options; /* a combination of xmlParserOption */
    int n_options;
    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
    int n_lst;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    for (n_datalen = 0;n_datalen < gen_nb_int;n_datalen++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        data = gen_const_char_ptr(n_data, 1);
        datalen = gen_int(n_datalen, 2);
        options = gen_int(n_options, 3);
        lst = gen_xmlNodePtr_ptr(n_lst, 4);

        ret_val = xmlParseInNodeContext(node, data, datalen, options, lst);
        desret_xmlParserErrors(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_char_ptr(n_data, data, 1);
        des_int(n_datalen, datalen, 2);
        des_int(n_options, options, 3);
        des_xmlNodePtr_ptr(n_lst, lst, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseInNodeContext",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_data);
            printf(" %d", n_datalen);
            printf(" %d", n_options);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlParseMemory(buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_const_xmlParserNodeInfoPtr 1
static xmlParserNodeInfoPtr gen_const_xmlParserNodeInfoPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlParserNodeInfoPtr(int no ATTRIBUTE_UNUSED, const xmlParserNodeInfoPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlParserAddNodeInfo(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    xmlParserNodeInfoPtr info; /* a node info sequence pointer */
    int n_info;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_info = 0;n_info < gen_nb_const_xmlParserNodeInfoPtr;n_info++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        info = gen_const_xmlParserNodeInfoPtr(n_info, 1);

        xmlParserAddNodeInfo(ctxt, info);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlParserNodeInfoPtr(n_info, info, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserAddNodeInfo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_info);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_const_xmlParserCtxtPtr 1
static xmlParserCtxtPtr gen_const_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, const xmlParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlParserFindNodeInfo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_const_xmlParserNodeInfoSeqPtr 1
static xmlParserNodeInfoSeqPtr gen_const_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, const xmlParserNodeInfoSeqPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlParserFindNodeInfoIndex(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlParserInputPtr 1
static xmlParserInputPtr gen_xmlParserInputPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlParserInputPtr(int no ATTRIBUTE_UNUSED, xmlParserInputPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlParserInputGrow(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputPtr in; /* an XML parser input */
    int n_in;
    int len; /* an indicative size for the lookahead */
    int n_len;

    for (n_in = 0;n_in < gen_nb_xmlParserInputPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputGrow(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputGrow",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputRead(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputPtr in; /* an XML parser input */
    int n_in;
    int len; /* an indicative size for the lookahead */
    int n_len;

    for (n_in = 0;n_in < gen_nb_xmlParserInputPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputRead(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlPedanticParserDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlPedanticParserDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPedanticParserDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlReadDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlReadDoc(cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlReadFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_int(n_options, 2);

        ret_val = xmlReadFile(filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlReadMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlReadMemory(buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRecoverDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);

        ret_val = xmlRecoverDoc(cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRecoverFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlRecoverFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRecoverMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlRecoverMemory(buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseDTD(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    xmlChar * ExternalID; /* a NAME* containing the External ID of the DTD */
    int n_ExternalID;
    xmlChar * SystemID; /* a NAME* containing the URL to the DTD */
    int n_SystemID;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 2);

        ret_val = xmlSAXParseDTD(sax, ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 1);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        cur = gen_xmlChar_ptr(n_cur, 1);
        recovery = gen_int(n_recovery, 2);

        ret_val = xmlSAXParseDoc(sax, cur, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_xmlChar_ptr(n_cur, cur, 1);
        des_int(n_recovery, recovery, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_cur);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseEntity(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * filename; /* the filename */
    int n_filename;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);

        ret_val = xmlSAXParseEntity(sax, filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * filename; /* the filename */
    int n_filename;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);
        recovery = gen_int(n_recovery, 2);

        ret_val = xmlSAXParseFile(sax, filename, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        des_int(n_recovery, recovery, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseFileWithData(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    const char * filename; /* the filename */
    int n_filename;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;
    void * data; /* the userdata */
    int n_data;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);
        recovery = gen_int(n_recovery, 2);
        data = gen_userdata(n_data, 3);

        ret_val = xmlSAXParseFileWithData(sax, filename, recovery, data);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        des_int(n_recovery, recovery, 2);
        des_userdata(n_data, data, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseFileWithData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf(" %d", n_recovery);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    int recovery; /* work in recovery mode, i.e. tries to read not Well Formed documents */
    int n_recovery;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        recovery = gen_int(n_recovery, 3);

        ret_val = xmlSAXParseMemory(sax, buffer, size, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_int(n_recovery, recovery, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXParseMemoryWithData(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax; /* the SAX handler block */
    int n_sax;
    char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
    int n_recovery;
    void * data; /* the userdata */
    int n_data;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        recovery = gen_int(n_recovery, 3);
        data = gen_userdata(n_data, 4);

        ret_val = xmlSAXParseMemoryWithData(sax, buffer, size, recovery, data);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_int(n_recovery, recovery, 3);
        des_userdata(n_data, data, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseMemoryWithData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_recovery);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXUserParseFile(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlSAXHandlerPtr sax; /* a SAX handler */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks */
    int n_user_data;
    const char * filename; /* a file name */
    int n_filename;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        filename = gen_filepath(n_filename, 2);
        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;

        ret_val = xmlSAXUserParseFile(sax, user_data, filename);
        desret_int(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_filepath(n_filename, filename, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXUserParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSAXUserParseMemory(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlSAXHandlerPtr sax; /* a SAX handler */
    int n_sax;
    void * user_data; /* The user data returned on SAX callbacks */
    int n_user_data;
    char * buffer; /* an in-memory XML document input */
    int n_buffer;
    int size; /* the length of the XML document in bytes */
    int n_size;

    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        buffer = gen_const_char_ptr(n_buffer, 2);
        size = gen_int(n_size, 3);
        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;

        ret_val = xmlSAXUserParseMemory(sax, user_data, buffer, size);
        desret_int(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_buffer, buffer, 2);
        des_int(n_size, size, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXUserParseMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetFeature(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML/HTML parser context */
    int n_ctxt;
    char * name; /* the feature name */
    int n_name;
    void * value; /* pointer to the location of the new value */
    int n_value;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_void_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        name = gen_const_char_ptr(n_name, 1);
        value = gen_void_ptr(n_value, 2);

        ret_val = xmlSetFeature(ctxt, name, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_name, name, 1);
        des_void_ptr(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetFeature",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetupParserForBuffer(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    xmlChar * buffer; /* a xmlChar * buffer */
    int n_buffer;
    const char * filename; /* a file name */
    int n_filename;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_xmlChar_ptr;n_buffer++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_xmlChar_ptr(n_buffer, 1);
        filename = gen_filepath(n_filename, 2);

        xmlSetupParserForBuffer(ctxt, buffer, filename);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_buffer, buffer, 1);
        des_filepath(n_filename, filename, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetupParserForBuffer",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStopParser(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlStopParser(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStopParser",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSubstituteEntitiesDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlSubstituteEntitiesDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSubstituteEntitiesDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}

static int
test_parser(void) {
    int ret = 0;

    printf("Testing parser : 56 of 69 functions ...\n");
    ret += test_xmlByteConsumed();
    ret += test_xmlClearNodeInfoSeq();
    ret += test_xmlClearParserCtxt();
    ret += test_xmlCreateDocParserCtxt();
    ret += test_xmlCreateIOParserCtxt();
    ret += test_xmlCreatePushParserCtxt();
    ret += test_xmlCtxtReadDoc();
    ret += test_xmlCtxtReadFile();
    ret += test_xmlCtxtReadMemory();
    ret += test_xmlCtxtReset();
    ret += test_xmlCtxtResetPush();
    ret += test_xmlCtxtUseOptions();
    ret += test_xmlGetExternalEntityLoader();
    ret += test_xmlGetFeature();
    ret += test_xmlGetFeaturesList();
    ret += test_xmlIOParseDTD();
    ret += test_xmlInitNodeInfoSeq();
    ret += test_xmlInitParser();
    ret += test_xmlInitParserCtxt();
    ret += test_xmlKeepBlanksDefault();
    ret += test_xmlLineNumbersDefault();
    ret += test_xmlLoadExternalEntity();
    ret += test_xmlNewIOInputStream();
    ret += test_xmlNewParserCtxt();
    ret += test_xmlParseBalancedChunkMemory();
    ret += test_xmlParseBalancedChunkMemoryRecover();
    ret += test_xmlParseChunk();
    ret += test_xmlParseCtxtExternalEntity();
    ret += test_xmlParseDTD();
    ret += test_xmlParseDoc();
    ret += test_xmlParseDocument();
    ret += test_xmlParseEntity();
    ret += test_xmlParseExtParsedEnt();
    ret += test_xmlParseExternalEntity();
    ret += test_xmlParseFile();
    ret += test_xmlParseInNodeContext();
    ret += test_xmlParseMemory();
    ret += test_xmlParserAddNodeInfo();
    ret += test_xmlParserFindNodeInfo();
    ret += test_xmlParserFindNodeInfoIndex();
    ret += test_xmlParserInputGrow();
    ret += test_xmlParserInputRead();
    ret += test_xmlPedanticParserDefault();
    ret += test_xmlReadDoc();
    ret += test_xmlReadFile();
    ret += test_xmlReadMemory();
    ret += test_xmlRecoverDoc();
    ret += test_xmlRecoverFile();
    ret += test_xmlRecoverMemory();
    ret += test_xmlSAXParseDTD();
    ret += test_xmlSAXParseDoc();
    ret += test_xmlSAXParseEntity();
    ret += test_xmlSAXParseFile();
    ret += test_xmlSAXParseFileWithData();
    ret += test_xmlSAXParseMemory();
    ret += test_xmlSAXParseMemoryWithData();
    ret += test_xmlSAXUserParseFile();
    ret += test_xmlSAXUserParseMemory();
    ret += test_xmlSetExternalEntityLoader();
    ret += test_xmlSetFeature();
    ret += test_xmlSetupParserForBuffer();
    ret += test_xmlStopParser();
    ret += test_xmlSubstituteEntitiesDefault();

    if (ret != 0)
	printf("Module parser: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlPatternPtr 1
static xmlPatternPtr gen_xmlPatternPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlPatternPtr(int no ATTRIBUTE_UNUSED, xmlPatternPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlPatternMatch(void) {
    int ret = 0;

#ifdef LIBXML_PATTERN_ENABLED
    int mem_base;
    int ret_val;
    xmlPatternPtr comp; /* the precompiled pattern */
    int n_comp;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_comp = 0;n_comp < gen_nb_xmlPatternPtr;n_comp++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlPatternMatch(comp, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlPatternPtr(n_comp, comp, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPatternMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_comp);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlPatterncompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_pattern(void) {
    int ret = 0;

    printf("Testing pattern : 1 of 4 functions ...\n");
    ret += test_xmlPatternMatch();
    ret += test_xmlPatterncompile();

    if (ret != 0)
	printf("Module pattern: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlRelaxNGPtr 1
static xmlRelaxNGPtr gen_xmlRelaxNGPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlRelaxNGPtr(int no ATTRIBUTE_UNUSED, xmlRelaxNGPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlRelaxNGDump(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * output; /* the file output */
    int n_output;
    xmlRelaxNGPtr schema; /* a schema structure */
    int n_schema;

    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        schema = gen_xmlRelaxNGPtr(n_schema, 1);

        xmlRelaxNGDump(output, schema);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlRelaxNGPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_output);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGDumpTree(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * output; /* the file output */
    int n_output;
    xmlRelaxNGPtr schema; /* a schema structure */
    int n_schema;

    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        schema = gen_xmlRelaxNGPtr(n_schema, 1);

        xmlRelaxNGDumpTree(output, schema);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlRelaxNGPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGDumpTree",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_output);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlRelaxNGParserCtxtPtr 1
static xmlRelaxNGParserCtxtPtr gen_xmlRelaxNGParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlRelaxNGParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlRelaxNGParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlRelaxNGValidityErrorFunc_ptr 1
static xmlRelaxNGValidityErrorFunc * gen_xmlRelaxNGValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlRelaxNGValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlRelaxNGValidityErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlRelaxNGValidityWarningFunc_ptr 1
static xmlRelaxNGValidityWarningFunc * gen_xmlRelaxNGValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlRelaxNGValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, xmlRelaxNGValidityWarningFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_void_ptr_ptr 1
static void ** gen_void_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_void_ptr_ptr(int no ATTRIBUTE_UNUSED, void ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlRelaxNGGetParserErrors(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGParserCtxtPtr ctxt; /* a Relax-NG validation context */
    int n_ctxt;
    xmlRelaxNGValidityErrorFunc * err; /* the error callback result */
    int n_err;
    xmlRelaxNGValidityWarningFunc * warn; /* the warning callback result */
    int n_warn;
    void ** ctx; /* contextual data for the callbacks result */
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGParserCtxtPtr;n_ctxt++) {
    for (n_err = 0;n_err < gen_nb_xmlRelaxNGValidityErrorFunc_ptr;n_err++) {
    for (n_warn = 0;n_warn < gen_nb_xmlRelaxNGValidityWarningFunc_ptr;n_warn++) {
    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0);
        err = gen_xmlRelaxNGValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlRelaxNGGetParserErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGGetParserErrors",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlRelaxNGValidCtxtPtr 1
static xmlRelaxNGValidCtxtPtr gen_xmlRelaxNGValidCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlRelaxNGValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlRelaxNGValidCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlRelaxNGGetValidErrors(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt; /* a Relax-NG validation context */
    int n_ctxt;
    xmlRelaxNGValidityErrorFunc * err; /* the error function result */
    int n_err;
    xmlRelaxNGValidityWarningFunc * warn; /* the warning function result */
    int n_warn;
    void ** ctx; /* the functions context result */
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    for (n_err = 0;n_err < gen_nb_xmlRelaxNGValidityErrorFunc_ptr;n_err++) {
    for (n_warn = 0;n_warn < gen_nb_xmlRelaxNGValidityWarningFunc_ptr;n_warn++) {
    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        err = gen_xmlRelaxNGValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlRelaxNGGetValidErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGGetValidErrors",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGInitTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlRelaxNGInitTypes();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGInitTypes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGNewDocParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewMemParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGParse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGSetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGSetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidateDoc(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt; /* a Relax-NG validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a parsed document tree */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlRelaxNGValidateDoc(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidateDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGValidateFullElement(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlRelaxNGValidateFullElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidateFullElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGValidatePopElement(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt; /* the RelaxNG validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlRelaxNGValidatePopElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidatePopElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGValidatePushCData(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt; /* the RelaxNG validation context */
    int n_ctxt;
    xmlChar * data; /* some character data read */
    int n_data;
    int len; /* the lenght of the data */
    int n_len;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    for (n_data = 0;n_data < gen_nb_const_xmlChar_ptr;n_data++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        data = gen_const_xmlChar_ptr(n_data, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlRelaxNGValidatePushCData(ctxt, data, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_data, data, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidatePushCData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_data);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxNGValidatePushElement(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlRelaxNGValidatePushElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidatePushElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRelaxParserSetFlag(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlRelaxNGParserCtxtPtr ctxt; /* a RelaxNG parser context */
    int n_ctxt;
    int flags; /* a set of flags values */
    int n_flags;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGParserCtxtPtr;n_ctxt++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlRelaxParserSetFlag(ctxt, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxParserSetFlag",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_relaxng(void) {
    int ret = 0;

    printf("Testing relaxng : 11 of 22 functions ...\n");
    ret += test_xmlRelaxNGDump();
    ret += test_xmlRelaxNGDumpTree();
    ret += test_xmlRelaxNGGetParserErrors();
    ret += test_xmlRelaxNGGetValidErrors();
    ret += test_xmlRelaxNGInitTypes();
    ret += test_xmlRelaxNGNewDocParserCtxt();
    ret += test_xmlRelaxNGNewMemParserCtxt();
    ret += test_xmlRelaxNGNewParserCtxt();
    ret += test_xmlRelaxNGNewValidCtxt();
    ret += test_xmlRelaxNGParse();
    ret += test_xmlRelaxNGSetParserErrors();
    ret += test_xmlRelaxNGSetValidErrors();
    ret += test_xmlRelaxNGValidateDoc();
    ret += test_xmlRelaxNGValidateFullElement();
    ret += test_xmlRelaxNGValidatePopElement();
    ret += test_xmlRelaxNGValidatePushCData();
    ret += test_xmlRelaxNGValidatePushElement();
    ret += test_xmlRelaxParserSetFlag();

    if (ret != 0)
	printf("Module relaxng: %d errors\n", ret);
    return(ret);
}
static int
test_schemasInternals(void) {
    int ret = 0;

    printf("Testing schemasInternals : 0 of 2 functions ...\n");

    if (ret != 0)
	printf("Module schemasInternals: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNodePtr cur; /* the child node */
    int n_cur;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlAddChild(parent, cur);
        if (ret_val == NULL) { xmlFreeNode(cur) ; cur = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddChildList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNodePtr cur; /* the first node in the list */
    int n_cur;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlAddChildList(parent, cur);
        if (ret_val == NULL) { xmlFreeNodeList(cur) ; cur = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChildList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddNextSibling(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddNextSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddNextSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAddPrevSibling(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddPrevSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddPrevSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlAddSibling(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlAttrSerializeTxtContent(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlAttrPtr attr; /* the attribute node */
    int n_attr;
    xmlChar * string; /* the text content */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);
        string = gen_const_xmlChar_ptr(n_string, 3);

        xmlAttrSerializeTxtContent(buf, doc, attr, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        des_const_xmlChar_ptr(n_string, string, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAttrSerializeTxtContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferAdd(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to dump */
    int n_buf;
    xmlChar * str; /* the #xmlChar string */
    int n_str;
    int len; /* the number of #xmlChar to add */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlBufferAdd(buf, str, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferAdd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferAddHead(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;
    xmlChar * str; /* the #xmlChar string */
    int n_str;
    int len; /* the number of #xmlChar to add */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlBufferAddHead(buf, str, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferAddHead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferCCat(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to dump */
    int n_buf;
    char * str; /* the C char string */
    int n_str;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlBufferCCat(buf, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_char_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCCat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferCat(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to add to */
    int n_buf;
    xmlChar * str; /* the #xmlChar string */
    int n_str;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlBufferCat(buf, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_const_xmlBufferPtr 1
static xmlBufferPtr gen_const_xmlBufferPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_const_xmlBufferPtr(int no ATTRIBUTE_UNUSED, const xmlBufferPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlBufferContent(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;

    for (n_buf = 0;n_buf < gen_nb_const_xmlBufferPtr;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBufferPtr(n_buf, 0);

        ret_val = xmlBufferContent(buf);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlBufferPtr(n_buf, buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferCreate(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlBufferCreate();
        desret_xmlBufferPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCreate",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferCreateSize(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCreateStatic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferEmpty(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);

        xmlBufferEmpty(buf);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferEmpty",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferGrow(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;
    unsigned int len; /* the minimum free size to allocate */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_len = 0;n_len < gen_nb_unsigned_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        len = gen_unsigned_int(n_len, 1);

        ret_val = xmlBufferGrow(buf, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferGrow",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferLength(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer */
    int n_buf;

    for (n_buf = 0;n_buf < gen_nb_const_xmlBufferPtr;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBufferPtr(n_buf, 0);

        ret_val = xmlBufferLength(buf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlBufferPtr(n_buf, buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferLength",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferResize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to resize */
    int n_buf;
    unsigned int size; /* the desired size */
    int n_size;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_size = 0;n_size < gen_nb_unsigned_int;n_size++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        size = gen_unsigned_int(n_size, 1);

        ret_val = xmlBufferResize(buf, size);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferResize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferSetAllocationScheme(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the buffer to tune */
    int n_buf;
    xmlBufferAllocationScheme scheme; /* allocation scheme to use */
    int n_scheme;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_scheme = 0;n_scheme < gen_nb_xmlBufferAllocationScheme;n_scheme++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        scheme = gen_xmlBufferAllocationScheme(n_scheme, 1);

        xmlBufferSetAllocationScheme(buf, scheme);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlBufferAllocationScheme(n_scheme, scheme, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferSetAllocationScheme",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_scheme);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferShrink(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the buffer to dump */
    int n_buf;
    unsigned int len; /* the number of xmlChar to remove */
    int n_len;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_len = 0;n_len < gen_nb_unsigned_int;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        len = gen_unsigned_int(n_len, 1);

        ret_val = xmlBufferShrink(buf, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferShrink",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferWriteCHAR(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer */
    int n_buf;
    xmlChar * string; /* the string to add */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_xmlChar_ptr(n_string, 1);

        xmlBufferWriteCHAR(buf, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_string, string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteCHAR",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferWriteChar(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    char * string; /* the string to add */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_string = 0;n_string < gen_nb_const_char_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_char_ptr(n_string, 1);

        xmlBufferWriteChar(buf, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_char_ptr(n_string, string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBufferWriteQuotedString(void) {
    int ret = 0;

    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlChar * string; /* the string to add */
    int n_string;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_xmlChar_ptr(n_string, 1);

        xmlBufferWriteQuotedString(buf, string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_string, string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteQuotedString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBuildQName(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * ncname; /* the Name */
    int n_ncname;
    xmlChar * prefix; /* the prefix */
    int n_prefix;
    xmlChar * memory; /* preallocated memory */
    int n_memory;
    int len; /* preallocated memory length */
    int n_len;

    for (n_ncname = 0;n_ncname < gen_nb_const_xmlChar_ptr;n_ncname++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_memory = 0;n_memory < gen_nb_xmlChar_ptr;n_memory++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ncname = gen_const_xmlChar_ptr(n_ncname, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        memory = gen_xmlChar_ptr(n_memory, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlBuildQName(ncname, prefix, memory, len);
        if ((ret_val != NULL) && (ret_val != ncname) &&
              (ret_val != prefix) && (ret_val != memory))
              xmlFree(ret_val);
	  ret_val = NULL;
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_ncname, ncname, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_xmlChar_ptr(n_memory, memory, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildQName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ncname);
            printf(" %d", n_prefix);
            printf(" %d", n_memory);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyDoc(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    int recursive; /* if not zero do a recursive copy. */
    int n_recursive;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_recursive = 0;n_recursive < gen_nb_int;n_recursive++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        recursive = gen_int(n_recursive, 1);

        ret_val = xmlCopyDoc(doc, recursive);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_recursive, recursive, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_recursive);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCopyDtd(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlDtdPtr ret_val;
    xmlDtdPtr dtd; /* the dtd */
    int n_dtd;

    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
        mem_base = xmlMemBlocks();
        dtd = gen_xmlDtdPtr(n_dtd, 0);

        ret_val = xmlCopyDtd(dtd);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDtdPtr(n_dtd, dtd, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyDtd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_dtd);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlCopyNamespace(void) {
    int ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlNsPtr cur; /* the namespace */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNsPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNsPtr(n_cur, 0);

        ret_val = xmlCopyNamespace(cur);
        if (ret_val != NULL) xmlFreeNs(ret_val);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNamespace",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyNamespaceList(void) {
    int ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlNsPtr cur; /* the first namespace */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNsPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNsPtr(n_cur, 0);

        ret_val = xmlCopyNamespaceList(cur);
        if (ret_val != NULL) xmlFreeNsList(ret_val);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNamespaceList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyNode(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    int extended; /* if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable) */
    int n_extended;

    for (n_node = 0;n_node < gen_nb_const_xmlNodePtr;n_node++) {
    for (n_extended = 0;n_extended < gen_nb_int;n_extended++) {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNodePtr(n_node, 0);
        extended = gen_int(n_extended, 1);

        ret_val = xmlCopyNode(node, extended);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlNodePtr(n_node, node, 0);
        des_int(n_extended, extended, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_extended);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node; /* the first node in the list. */
    int n_node;

    for (n_node = 0;n_node < gen_nb_const_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNodePtr(n_node, 0);

        ret_val = xmlCopyNodeList(node);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyProp(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr target; /* the element where the attribute will be grafted */
    int n_target;
    xmlAttrPtr cur; /* the attribute */
    int n_cur;

    for (n_target = 0;n_target < gen_nb_xmlNodePtr;n_target++) {
    for (n_cur = 0;n_cur < gen_nb_xmlAttrPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        target = gen_xmlNodePtr(n_target, 0);
        cur = gen_xmlAttrPtr(n_cur, 1);

        ret_val = xmlCopyProp(target, cur);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_target, target, 0);
        des_xmlAttrPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_target);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCopyPropList(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr target; /* the element where the attributes will be grafted */
    int n_target;
    xmlAttrPtr cur; /* the first attribute */
    int n_cur;

    for (n_target = 0;n_target < gen_nb_xmlNodePtr;n_target++) {
    for (n_cur = 0;n_cur < gen_nb_xmlAttrPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        target = gen_xmlNodePtr(n_target, 0);
        cur = gen_xmlAttrPtr(n_cur, 1);

        ret_val = xmlCopyPropList(target, cur);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_target, target, 0);
        des_xmlAttrPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyPropList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_target);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCreateIntSubset(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc; /* the document pointer */
    int n_doc;
    xmlChar * name; /* the DTD name */
    int n_name;
    xmlChar * ExternalID; /* the external (PUBLIC) ID */
    int n_ExternalID;
    xmlChar * SystemID; /* the system ID */
    int n_SystemID;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        ret_val = xmlCreateIntSubset(doc, name, ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateIntSubset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDocCopyNode(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlDocPtr doc; /* the document */
    int n_doc;
    int extended; /* if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable) */
    int n_extended;

    for (n_node = 0;n_node < gen_nb_const_xmlNodePtr;n_node++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_extended = 0;n_extended < gen_nb_int;n_extended++) {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNodePtr(n_node, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        extended = gen_int(n_extended, 2);

        ret_val = xmlDocCopyNode(node, doc, extended);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlNodePtr(n_node, node, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_int(n_extended, extended, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocCopyNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_doc);
            printf(" %d", n_extended);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDocCopyNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the target document */
    int n_doc;
    xmlNodePtr node; /* the first node in the list. */
    int n_node;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_node = 0;n_node < gen_nb_const_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_const_xmlNodePtr(n_node, 1);

        ret_val = xmlDocCopyNodeList(doc, node);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocCopyNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDocDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * f; /* the FILE* */
    int n_f;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = xmlDocDump(f, cur);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocDumpFormatMemory(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlDocPtr cur; /* the document */
    int n_cur;
    xmlChar ** mem; /* OUT: the memory pointer */
    int n_mem;
    int * size; /* OUT: the memory length */
    int n_size;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_mem = 0;n_mem < gen_nb_xmlChar_ptr_ptr;n_mem++) {
    for (n_size = 0;n_size < gen_nb_int_ptr;n_size++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlDocPtr(n_cur, 0);
        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
        size = gen_int_ptr(n_size, 2);
        format = gen_int(n_format, 3);

        xmlDocDumpFormatMemory(cur, mem, size, format);
        call_tests++;
        des_xmlDocPtr(n_cur, cur, 0);
        des_xmlChar_ptr_ptr(n_mem, mem, 1);
        des_int_ptr(n_size, size, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpFormatMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocDumpFormatMemoryEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlDocPtr out_doc; /* Document to generate XML text from */
    int n_out_doc;
    xmlChar ** doc_txt_ptr; /* Memory pointer for allocated XML text */
    int n_doc_txt_ptr;
    int * doc_txt_len; /* Length of the generated XML text */
    int n_doc_txt_len;
    char * txt_encoding; /* Character encoding to use when generating XML text */
    int n_txt_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_out_doc = 0;n_out_doc < gen_nb_xmlDocPtr;n_out_doc++) {
    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < gen_nb_xmlChar_ptr_ptr;n_doc_txt_ptr++) {
    for (n_doc_txt_len = 0;n_doc_txt_len < gen_nb_int_ptr;n_doc_txt_len++) {
    for (n_txt_encoding = 0;n_txt_encoding < gen_nb_const_char_ptr;n_txt_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        out_doc = gen_xmlDocPtr(n_out_doc, 0);
        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 1);
        doc_txt_len = gen_int_ptr(n_doc_txt_len, 2);
        txt_encoding = gen_const_char_ptr(n_txt_encoding, 3);
        format = gen_int(n_format, 4);

        xmlDocDumpFormatMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len, txt_encoding, format);
        call_tests++;
        des_xmlDocPtr(n_out_doc, out_doc, 0);
        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 1);
        des_int_ptr(n_doc_txt_len, doc_txt_len, 2);
        des_const_char_ptr(n_txt_encoding, txt_encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpFormatMemoryEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out_doc);
            printf(" %d", n_doc_txt_ptr);
            printf(" %d", n_doc_txt_len);
            printf(" %d", n_txt_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocDumpMemory(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlDocPtr cur; /* the document */
    int n_cur;
    xmlChar ** mem; /* OUT: the memory pointer */
    int n_mem;
    int * size; /* OUT: the memory length */
    int n_size;

    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_mem = 0;n_mem < gen_nb_xmlChar_ptr_ptr;n_mem++) {
    for (n_size = 0;n_size < gen_nb_int_ptr;n_size++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlDocPtr(n_cur, 0);
        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
        size = gen_int_ptr(n_size, 2);

        xmlDocDumpMemory(cur, mem, size);
        call_tests++;
        des_xmlDocPtr(n_cur, cur, 0);
        des_xmlChar_ptr_ptr(n_mem, mem, 1);
        des_int_ptr(n_size, size, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocDumpMemoryEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlDocPtr out_doc; /* Document to generate XML text from */
    int n_out_doc;
    xmlChar ** doc_txt_ptr; /* Memory pointer for allocated XML text */
    int n_doc_txt_ptr;
    int * doc_txt_len; /* Length of the generated XML text */
    int n_doc_txt_len;
    char * txt_encoding; /* Character encoding to use when generating XML text */
    int n_txt_encoding;

    for (n_out_doc = 0;n_out_doc < gen_nb_xmlDocPtr;n_out_doc++) {
    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < gen_nb_xmlChar_ptr_ptr;n_doc_txt_ptr++) {
    for (n_doc_txt_len = 0;n_doc_txt_len < gen_nb_int_ptr;n_doc_txt_len++) {
    for (n_txt_encoding = 0;n_txt_encoding < gen_nb_const_char_ptr;n_txt_encoding++) {
        mem_base = xmlMemBlocks();
        out_doc = gen_xmlDocPtr(n_out_doc, 0);
        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 1);
        doc_txt_len = gen_int_ptr(n_doc_txt_len, 2);
        txt_encoding = gen_const_char_ptr(n_txt_encoding, 3);

        xmlDocDumpMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len, txt_encoding);
        call_tests++;
        des_xmlDocPtr(n_out_doc, out_doc, 0);
        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 1);
        des_int_ptr(n_doc_txt_len, doc_txt_len, 2);
        des_const_char_ptr(n_txt_encoding, txt_encoding, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpMemoryEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out_doc);
            printf(" %d", n_doc_txt_ptr);
            printf(" %d", n_doc_txt_len);
            printf(" %d", n_txt_encoding);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocFormatDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    FILE * f; /* the FILE* */
    int n_f;
    xmlDocPtr cur; /* the document */
    int n_cur;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        format = gen_int(n_format, 2);

        ret_val = xmlDocFormatDump(f, cur, format);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_int(n_format, format, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocFormatDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDocGetRootElement(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlDocGetRootElement(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocGetRootElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlDocSetRootElement(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr root; /* the new document root element */
    int n_root;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_root = 0;n_root < gen_nb_xmlNodePtr_in;n_root++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        root = gen_xmlNodePtr_in(n_root, 1);

        ret_val = xmlDocSetRootElement(doc, root);
        if (doc == NULL) { xmlFreeNode(root) ; root = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr_in(n_root, root, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocSetRootElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_root);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlElemDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * f; /* the FILE * for the output */
    int n_f;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;

    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        xmlElemDump(f, doc, cur);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlElemDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_f);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlGetBufferAllocationScheme(void) {
    int ret = 0;

    int mem_base;
    xmlBufferAllocationScheme ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlGetBufferAllocationScheme();
        desret_xmlBufferAllocationScheme(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetBufferAllocationScheme",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlGetCompressMode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlGetCompressMode();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlGetDocCompressMode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlGetDocCompressMode(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDocCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetIntSubset(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc; /* the document pointer */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlGetIntSubset(doc);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetIntSubset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetLastChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);

        ret_val = xmlGetLastChild(parent);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetLastChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetLineNo(void) {
    int ret = 0;

    int mem_base;
    long ret_val;
    xmlNodePtr node; /* valid node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlGetLineNo(node);
        desret_long(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetLineNo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetNoNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetNoNsProp(node, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNoNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetNodePath(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlGetNodePath(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNodePath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlGetNsList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * name; /* the attribute name */
    int n_name;
    xmlChar * nameSpace; /* the URI of the namespace */
    int n_nameSpace;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);

        ret_val = xmlGetNsProp(node, name, nameSpace);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_nameSpace, nameSpace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetProp(node, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHasNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * name; /* the attribute name */
    int n_name;
    xmlChar * nameSpace; /* the URI of the namespace */
    int n_nameSpace;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);

        ret_val = xmlHasNsProp(node, name, nameSpace);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_nameSpace, nameSpace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHasNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlHasProp(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlHasProp(node, name);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHasProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsBlankNode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlIsBlankNode(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBlankNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsXHTML(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * systemID; /* the system identifier */
    int n_systemID;
    xmlChar * publicID; /* the public identifier */
    int n_publicID;

    for (n_systemID = 0;n_systemID < gen_nb_const_xmlChar_ptr;n_systemID++) {
    for (n_publicID = 0;n_publicID < gen_nb_const_xmlChar_ptr;n_publicID++) {
        mem_base = xmlMemBlocks();
        systemID = gen_const_xmlChar_ptr(n_systemID, 0);
        publicID = gen_const_xmlChar_ptr(n_publicID, 1);

        ret_val = xmlIsXHTML(systemID, publicID);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_systemID, systemID, 0);
        des_const_xmlChar_ptr(n_publicID, publicID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsXHTML",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_systemID);
            printf(" %d", n_publicID);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewCDataBlock(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * content; /* the CDATA block content content */
    int n_content;
    int len; /* the length of the block */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNewCDataBlock(doc, content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCDataBlock",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewCharRef(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * name; /* the char ref string, starting with # or "&# ... ;" */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewCharRef(doc, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCharRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNsPtr ns; /* a namespace if any */
    int n_ns;
    xmlChar * name; /* the name of the child */
    int n_name;
    xmlChar * content; /* the XML content of the child if any. */
    int n_content;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewChild(parent, ns, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewComment(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * content; /* the comment content */
    int n_content;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);

        ret_val = xmlNewComment(content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * version; /* xmlChar string giving the version of XML "1.0" */
    int n_version;

    for (n_version = 0;n_version < gen_nb_const_xmlChar_ptr;n_version++) {
        mem_base = xmlMemBlocks();
        version = gen_const_xmlChar_ptr(n_version, 0);

        ret_val = xmlNewDoc(version);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_version, version, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_version);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocComment(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * content; /* the comment content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewDocComment(doc, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocFragment(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document owning the fragment */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlNewDocFragment(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocFragment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocNode(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNsPtr ns; /* namespace if any */
    int n_ns;
    xmlChar * name; /* the node name */
    int n_name;
    xmlChar * content; /* the XML text content if any */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewDocNode(doc, ns, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocNodeEatName(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNsPtr ns; /* namespace if any */
    int n_ns;
    xmlChar * name; /* the node name */
    int n_name;
    xmlChar * content; /* the XML text content if any */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_eaten_name;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_eaten_name(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewDocNodeEatName(doc, ns, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_eaten_name(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocNodeEatName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocPI(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the target document */
    int n_doc;
    xmlChar * name; /* the processing instruction name */
    int n_name;
    xmlChar * content; /* the PI content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlNewDocPI(doc, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocProp(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * name; /* the name of the attribute */
    int n_name;
    xmlChar * value; /* the value of the attribute */
    int n_value;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);

        ret_val = xmlNewDocProp(doc, name, value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocRawNode(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNsPtr ns; /* namespace if any */
    int n_ns;
    xmlChar * name; /* the node name */
    int n_name;
    xmlChar * content; /* the text content if any */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewDocRawNode(doc, ns, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocRawNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocText(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * content; /* the text content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewDocText(doc, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDocTextLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * content; /* the text content */
    int n_content;
    int len; /* the text len. */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNewDocTextLen(doc, content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocTextLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewDtd(void) {
    int ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc; /* the document pointer */
    int n_doc;
    xmlChar * name; /* the DTD name */
    int n_name;
    xmlChar * ExternalID; /* the external ID */
    int n_ExternalID;
    xmlChar * SystemID; /* the system ID */
    int n_SystemID;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        ret_val = xmlNewDtd(doc, name, ExternalID, SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDtd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewNode(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNsPtr ns; /* namespace if any */
    int n_ns;
    xmlChar * name; /* the node name */
    int n_name;

    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNsPtr(n_ns, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewNode(ns, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_ns, ns, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewNodeEatName(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNsPtr ns; /* namespace if any */
    int n_ns;
    xmlChar * name; /* the node name */
    int n_name;

    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_eaten_name;n_name++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNsPtr(n_ns, 0);
        name = gen_eaten_name(n_name, 1);

        ret_val = xmlNewNodeEatName(ns, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_ns, ns, 0);
        des_eaten_name(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNodeEatName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewNs(void) {
    int ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlNodePtr node; /* the element carrying the namespace */
    int n_node;
    xmlChar * href; /* the URI associated */
    int n_href;
    xmlChar * prefix; /* the prefix for the namespace */
    int n_prefix;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_href = 0;n_href < gen_nb_const_xmlChar_ptr;n_href++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        href = gen_const_xmlChar_ptr(n_href, 1);
        prefix = gen_const_xmlChar_ptr(n_prefix, 2);

        ret_val = xmlNewNs(node, href, prefix);
        if ((node == NULL) && (ret_val != NULL)) xmlFreeNs(ret_val);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_href, href, 1);
        des_const_xmlChar_ptr(n_prefix, prefix, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_href);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node; /* the holding node */
    int n_node;
    xmlNsPtr ns; /* the namespace */
    int n_ns;
    xmlChar * name; /* the name of the attribute */
    int n_name;
    xmlChar * value; /* the value of the attribute */
    int n_value;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlNewNsProp(node, ns, name, value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_value, value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewNsPropEatName(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node; /* the holding node */
    int n_node;
    xmlNsPtr ns; /* the namespace */
    int n_ns;
    xmlChar * name; /* the name of the attribute */
    int n_name;
    xmlChar * value; /* the value of the attribute */
    int n_value;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_eaten_name;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_eaten_name(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlNewNsPropEatName(node, ns, name, value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_eaten_name(n_name, name, 2);
        des_const_xmlChar_ptr(n_value, value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNsPropEatName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewPI(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * name; /* the processing instruction name */
    int n_name;
    xmlChar * content; /* the PI content */
    int n_content;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewPI(name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewProp(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node; /* the holding node */
    int n_node;
    xmlChar * name; /* the name of the attribute */
    int n_name;
    xmlChar * value; /* the value of the attribute */
    int n_value;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);

        ret_val = xmlNewProp(node, name, value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewReference(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * name; /* the reference name, or the reference string with & and ; */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewReference(doc, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewReference",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewText(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * content; /* the text content */
    int n_content;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);

        ret_val = xmlNewText(content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNsPtr ns; /* a namespace if any */
    int n_ns;
    xmlChar * name; /* the name of the child */
    int n_name;
    xmlChar * content; /* the text content of the child if any. */
    int n_content;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewTextChild(parent, ns, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * content; /* the text content */
    int n_content;
    int len; /* the text len. */
    int n_len;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlNewTextLen(content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeAddContent(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    xmlChar * content; /* extra content */
    int n_content;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        xmlNodeAddContent(cur, content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeAddContentLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    xmlChar * content; /* extra content */
    int n_content;
    int len; /* the size of @content */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        xmlNodeAddContentLen(cur, content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContentLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeBufGetContent(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buffer; /* a buffer */
    int n_buffer;
    xmlNodePtr cur; /* the node being read */
    int n_cur;

    for (n_buffer = 0;n_buffer < gen_nb_xmlBufferPtr;n_buffer++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        buffer = gen_xmlBufferPtr(n_buffer, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlNodeBufGetContent(buffer, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buffer, buffer, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeBufGetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeDump(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    int level; /* the imbrication level for indenting */
    int n_level;
    int format; /* is formatting allowed */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_level = 0;n_level < gen_nb_int;n_level++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        level = gen_int(n_level, 3);
        format = gen_int(n_format, 4);

        ret_val = xmlNodeDump(buf, doc, cur, level, format);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_int(n_level, level, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_level);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeDumpOutput(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr cur; /* the current node */
    int n_cur;
    int level; /* the imbrication level for indenting */
    int n_level;
    int format; /* is formatting allowed */
    int n_format;
    char * encoding; /* an optional encoding string */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_level = 0;n_level < gen_nb_int;n_level++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        level = gen_int(n_level, 3);
        format = gen_int(n_format, 4);
        encoding = gen_const_char_ptr(n_encoding, 5);

        xmlNodeDumpOutput(buf, doc, cur, level, format, encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_int(n_level, level, 3);
        des_int(n_format, format, 4);
        des_const_char_ptr(n_encoding, encoding, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeDumpOutput",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_level);
            printf(" %d", n_format);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetBase(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document the node pertains to */
    int n_doc;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlNodeGetBase(doc, cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetBase",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetContent(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur; /* the node being read */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetContent(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetLang(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetLang(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeGetSpacePreserve(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetSpacePreserve(cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetSpacePreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeIsText(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlNodeIsText(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeIsText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeListGetRawString(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr list; /* a Node list */
    int n_list;
    int inLine; /* should we replace entity contents or show their external form */
    int n_inLine;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_list = 0;n_list < gen_nb_xmlNodePtr;n_list++) {
    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        list = gen_xmlNodePtr(n_list, 1);
        inLine = gen_int(n_inLine, 2);

        ret_val = xmlNodeListGetRawString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_list, list, 1);
        des_int(n_inLine, inLine, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetRawString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeListGetString(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr list; /* a Node list */
    int n_list;
    int inLine; /* should we replace entity contents or show their external form */
    int n_inLine;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_list = 0;n_list < gen_nb_xmlNodePtr;n_list++) {
    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        list = gen_xmlNodePtr(n_list, 1);
        inLine = gen_int(n_inLine, 2);

        ret_val = xmlNodeListGetString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_list, list, 1);
        des_int(n_inLine, inLine, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetBase(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    xmlChar * uri; /* the new base URI */
    int n_uri;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_uri = 0;n_uri < gen_nb_const_xmlChar_ptr;n_uri++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        uri = gen_const_xmlChar_ptr(n_uri, 1);

        xmlNodeSetBase(cur, uri);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_uri, uri, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetBase",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_uri);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetContent(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    xmlChar * content; /* the new value of the content */
    int n_content;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        xmlNodeSetContent(cur, content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetContentLen(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    xmlChar * content; /* the new value of the content */
    int n_content;
    int len; /* the size of @content */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        xmlNodeSetContentLen(cur, content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContentLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetLang(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    xmlChar * lang; /* the language description */
    int n_lang;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_lang = 0;n_lang < gen_nb_const_xmlChar_ptr;n_lang++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        lang = gen_const_xmlChar_ptr(n_lang, 1);

        xmlNodeSetLang(cur, lang);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_lang, lang, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_lang);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetName(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    xmlChar * name; /* the new tag name */
    int n_name;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        xmlNodeSetName(cur, name);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNodeSetSpacePreserve(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    int val; /* the xml:space value ("0": default, 1: "preserve") */
    int n_val;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        val = gen_int(n_val, 1);

        xmlNodeSetSpacePreserve(cur, val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_int(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetSpacePreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReconciliateNs(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr tree; /* a node defining the subtree to reconciliate */
    int n_tree;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        tree = gen_xmlNodePtr(n_tree, 1);

        ret_val = xmlReconciliateNs(doc, tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_tree, tree, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReconciliateNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_tree);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRemoveProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    int ret_val;
    xmlAttrPtr cur; /* an attribute */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlAttrPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlAttrPtr(n_cur, 0);

        ret_val = xmlRemoveProp(cur);
        cur = NULL;
        desret_int(ret_val);
        call_tests++;
        des_xmlAttrPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReplaceNode(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr old; /* the old node */
    int n_old;
    xmlNodePtr cur; /* the node */
    int n_cur;

    for (n_old = 0;n_old < gen_nb_xmlNodePtr;n_old++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        old = gen_xmlNodePtr(n_old, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlReplaceNode(old, cur);
        if (cur != NULL) {
              xmlUnlinkNode(cur);
              xmlFreeNode(cur) ; cur = NULL ; }
          if (old != NULL) {
              xmlUnlinkNode(old);
              xmlFreeNode(old) ; old = NULL ; }
	  ret_val = NULL;
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_old, old, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReplaceNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_old);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFile(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = xmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    char * encoding; /* the name of an encoding (or NULL) */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = xmlSaveFileEnc(filename, cur, encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFileTo(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr buf; /* an output I/O buffer */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    char * encoding; /* the encoding if any assuming the I/O layer handles the trancoding */
    int n_encoding;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = xmlSaveFileTo(buf, cur, encoding);
        buf = NULL;
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFileTo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFormatFile(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        format = gen_int(n_format, 2);

        ret_val = xmlSaveFormatFile(filename, cur, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_int(n_format, format, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFormatFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename or URL to output */
    int n_filename;
    xmlDocPtr cur; /* the document being saved */
    int n_cur;
    char * encoding; /* the name of the encoding to use or NULL. */
    int n_encoding;
    int format; /* should formatting spaces be added. */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = xmlSaveFormatFileEnc(filename, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFormatFileTo(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr buf; /* an output I/O buffer */
    int n_buf;
    xmlDocPtr cur; /* the document */
    int n_cur;
    char * encoding; /* the encoding if any assuming the I/O layer handles the trancoding */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = xmlSaveFormatFileTo(buf, cur, encoding, format);
        buf = NULL;
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFileTo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSearchNs(void) {
    int ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr node; /* the current node */
    int n_node;
    xmlChar * nameSpace; /* the namespace prefix */
    int n_nameSpace;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_xmlNodePtr(n_node, 1);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);

        ret_val = xmlSearchNs(doc, node, nameSpace);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_const_xmlChar_ptr(n_nameSpace, nameSpace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSearchNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSearchNsByHref(void) {
    int ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr node; /* the current node */
    int n_node;
    xmlChar * href; /* the namespace value */
    int n_href;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_href = 0;n_href < gen_nb_const_xmlChar_ptr;n_href++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_xmlNodePtr(n_node, 1);
        href = gen_const_xmlChar_ptr(n_href, 2);

        ret_val = xmlSearchNsByHref(doc, node, href);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_const_xmlChar_ptr(n_href, href, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSearchNsByHref",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf(" %d", n_href);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetBufferAllocationScheme(void) {
    int ret = 0;

    int mem_base;
    xmlBufferAllocationScheme scheme; /* allocation method to use */
    int n_scheme;

    for (n_scheme = 0;n_scheme < gen_nb_xmlBufferAllocationScheme;n_scheme++) {
        mem_base = xmlMemBlocks();
        scheme = gen_xmlBufferAllocationScheme(n_scheme, 0);

        xmlSetBufferAllocationScheme(scheme);
        call_tests++;
        des_xmlBufferAllocationScheme(n_scheme, scheme, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetBufferAllocationScheme",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_scheme);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetCompressMode(void) {
    int ret = 0;

    int mem_base;
    int mode; /* the compression ratio */
    int n_mode;

    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
        mem_base = xmlMemBlocks();
        mode = gen_int(n_mode, 0);

        xmlSetCompressMode(mode);
        call_tests++;
        des_int(n_mode, mode, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_mode);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetDocCompressMode(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr doc; /* the document */
    int n_doc;
    int mode; /* the compression ratio */
    int n_mode;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        mode = gen_int(n_mode, 1);

        xmlSetDocCompressMode(doc, mode);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_mode, mode, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetDocCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_mode);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetNs(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr node; /* a node in the document */
    int n_node;
    xmlNsPtr ns; /* a namespace pointer */
    int n_ns;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);

        xmlSetNs(node, ns);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSetNsProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlNsPtr ns; /* the namespace definition */
    int n_ns;
    xmlChar * name; /* the attribute name */
    int n_name;
    xmlChar * value; /* the attribute value */
    int n_value;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlSetNsProp(node, ns, name, value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_value, value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSetProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * name; /* the attribute name */
    int n_name;
    xmlChar * value; /* the attribute value */
    int n_value;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);

        ret_val = xmlSetProp(node, name, value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSplitQName2(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * name; /* the full QName */
    int n_name;
    xmlChar ** prefix; /* a xmlChar ** */
    int n_prefix;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_prefix = 0;n_prefix < gen_nb_xmlChar_ptr_ptr;n_prefix++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        prefix = gen_xmlChar_ptr_ptr(n_prefix, 1);

        ret_val = xmlSplitQName2(name, prefix);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        des_xmlChar_ptr_ptr(n_prefix, prefix, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSplitQName2",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSplitQName3(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * name; /* the full QName */
    int n_name;
    int * len; /* an int * */
    int n_len;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        len = gen_int_ptr(n_len, 1);

        ret_val = xmlSplitQName3(name, len);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name, 0);
        des_int_ptr(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSplitQName3",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStringGetNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * value; /* the value of the attribute */
    int n_value;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = xmlStringGetNodeList(doc, value);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringGetNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStringLenGetNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * value; /* the value of the text */
    int n_value;
    int len; /* the length of the string value */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStringLenGetNodeList(doc, value, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringLenGetNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlTextConcat(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * content; /* the content */
    int n_content;
    int len; /* @content length */
    int n_len;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlTextConcat(node, content, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextConcat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlTextMerge(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr first; /* the first text node */
    int n_first;
    xmlNodePtr second; /* the second text node being merged */
    int n_second;

    for (n_first = 0;n_first < gen_nb_xmlNodePtr_in;n_first++) {
    for (n_second = 0;n_second < gen_nb_xmlNodePtr_in;n_second++) {
        mem_base = xmlMemBlocks();
        first = gen_xmlNodePtr_in(n_first, 0);
        second = gen_xmlNodePtr_in(n_second, 1);

        ret_val = xmlTextMerge(first, second);
        if ((first != NULL) && (first->type != XML_TEXT_NODE)) {
              xmlUnlinkNode(second);
              xmlFreeNode(second) ; second = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr_in(n_first, first, 0);
        des_xmlNodePtr_in(n_second, second, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextMerge",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_first);
            printf(" %d", n_second);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUnsetNsProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlNsPtr ns; /* the namespace definition */
    int n_ns;
    xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlUnsetNsProp(node, ns, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUnsetNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUnsetProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlUnsetProp(node, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUnsetProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNCName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateNCName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNCName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNMToken(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateNMToken(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNMToken",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidateName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidateQName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateQName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateQName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}

static int
test_tree(void) {
    int ret = 0;

    printf("Testing tree : 129 of 146 functions ...\n");
    ret += test_xmlAddChild();
    ret += test_xmlAddChildList();
    ret += test_xmlAddNextSibling();
    ret += test_xmlAddPrevSibling();
    ret += test_xmlAddSibling();
    ret += test_xmlAttrSerializeTxtContent();
    ret += test_xmlBufferAdd();
    ret += test_xmlBufferAddHead();
    ret += test_xmlBufferCCat();
    ret += test_xmlBufferCat();
    ret += test_xmlBufferContent();
    ret += test_xmlBufferCreate();
    ret += test_xmlBufferCreateSize();
    ret += test_xmlBufferCreateStatic();
    ret += test_xmlBufferEmpty();
    ret += test_xmlBufferGrow();
    ret += test_xmlBufferLength();
    ret += test_xmlBufferResize();
    ret += test_xmlBufferSetAllocationScheme();
    ret += test_xmlBufferShrink();
    ret += test_xmlBufferWriteCHAR();
    ret += test_xmlBufferWriteChar();
    ret += test_xmlBufferWriteQuotedString();
    ret += test_xmlBuildQName();
    ret += test_xmlCopyDoc();
    ret += test_xmlCopyDtd();
    ret += test_xmlCopyNamespace();
    ret += test_xmlCopyNamespaceList();
    ret += test_xmlCopyNode();
    ret += test_xmlCopyNodeList();
    ret += test_xmlCopyProp();
    ret += test_xmlCopyPropList();
    ret += test_xmlCreateIntSubset();
    ret += test_xmlDocCopyNode();
    ret += test_xmlDocCopyNodeList();
    ret += test_xmlDocDump();
    ret += test_xmlDocDumpFormatMemory();
    ret += test_xmlDocDumpFormatMemoryEnc();
    ret += test_xmlDocDumpMemory();
    ret += test_xmlDocDumpMemoryEnc();
    ret += test_xmlDocFormatDump();
    ret += test_xmlDocGetRootElement();
    ret += test_xmlDocSetRootElement();
    ret += test_xmlElemDump();
    ret += test_xmlGetBufferAllocationScheme();
    ret += test_xmlGetCompressMode();
    ret += test_xmlGetDocCompressMode();
    ret += test_xmlGetIntSubset();
    ret += test_xmlGetLastChild();
    ret += test_xmlGetLineNo();
    ret += test_xmlGetNoNsProp();
    ret += test_xmlGetNodePath();
    ret += test_xmlGetNsList();
    ret += test_xmlGetNsProp();
    ret += test_xmlGetProp();
    ret += test_xmlHasNsProp();
    ret += test_xmlHasProp();
    ret += test_xmlIsBlankNode();
    ret += test_xmlIsXHTML();
    ret += test_xmlNewCDataBlock();
    ret += test_xmlNewCharRef();
    ret += test_xmlNewChild();
    ret += test_xmlNewComment();
    ret += test_xmlNewDoc();
    ret += test_xmlNewDocComment();
    ret += test_xmlNewDocFragment();
    ret += test_xmlNewDocNode();
    ret += test_xmlNewDocNodeEatName();
    ret += test_xmlNewDocPI();
    ret += test_xmlNewDocProp();
    ret += test_xmlNewDocRawNode();
    ret += test_xmlNewDocText();
    ret += test_xmlNewDocTextLen();
    ret += test_xmlNewDtd();
    ret += test_xmlNewNode();
    ret += test_xmlNewNodeEatName();
    ret += test_xmlNewNs();
    ret += test_xmlNewNsProp();
    ret += test_xmlNewNsPropEatName();
    ret += test_xmlNewPI();
    ret += test_xmlNewProp();
    ret += test_xmlNewReference();
    ret += test_xmlNewText();
    ret += test_xmlNewTextChild();
    ret += test_xmlNewTextLen();
    ret += test_xmlNodeAddContent();
    ret += test_xmlNodeAddContentLen();
    ret += test_xmlNodeBufGetContent();
    ret += test_xmlNodeDump();
    ret += test_xmlNodeDumpOutput();
    ret += test_xmlNodeGetBase();
    ret += test_xmlNodeGetContent();
    ret += test_xmlNodeGetLang();
    ret += test_xmlNodeGetSpacePreserve();
    ret += test_xmlNodeIsText();
    ret += test_xmlNodeListGetRawString();
    ret += test_xmlNodeListGetString();
    ret += test_xmlNodeSetBase();
    ret += test_xmlNodeSetContent();
    ret += test_xmlNodeSetContentLen();
    ret += test_xmlNodeSetLang();
    ret += test_xmlNodeSetName();
    ret += test_xmlNodeSetSpacePreserve();
    ret += test_xmlReconciliateNs();
    ret += test_xmlRemoveProp();
    ret += test_xmlReplaceNode();
    ret += test_xmlSaveFile();
    ret += test_xmlSaveFileEnc();
    ret += test_xmlSaveFileTo();
    ret += test_xmlSaveFormatFile();
    ret += test_xmlSaveFormatFileEnc();
    ret += test_xmlSaveFormatFileTo();
    ret += test_xmlSearchNs();
    ret += test_xmlSearchNsByHref();
    ret += test_xmlSetBufferAllocationScheme();
    ret += test_xmlSetCompressMode();
    ret += test_xmlSetDocCompressMode();
    ret += test_xmlSetNs();
    ret += test_xmlSetNsProp();
    ret += test_xmlSetProp();
    ret += test_xmlSplitQName2();
    ret += test_xmlSplitQName3();
    ret += test_xmlStringGetNodeList();
    ret += test_xmlStringLenGetNodeList();
    ret += test_xmlTextConcat();
    ret += test_xmlTextMerge();
    ret += test_xmlUnsetNsProp();
    ret += test_xmlUnsetProp();
    ret += test_xmlValidateNCName();
    ret += test_xmlValidateNMToken();
    ret += test_xmlValidateName();
    ret += test_xmlValidateQName();

    if (ret != 0)
	printf("Module tree: %d errors\n", ret);
    return(ret);
}

static int
test_xmlBuildRelativeURI(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * URI; /* the URI reference under consideration */
    int n_URI;
    xmlChar * base; /* the base value */
    int n_base;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        base = gen_const_xmlChar_ptr(n_base, 1);

        ret_val = xmlBuildRelativeURI(URI, base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_base, base, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildRelativeURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlBuildURI(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * URI; /* the URI instance found in the document */
    int n_URI;
    xmlChar * base; /* the base value */
    int n_base;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        base = gen_const_xmlChar_ptr(n_base, 1);

        ret_val = xmlBuildURI(URI, base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI, 0);
        des_const_xmlChar_ptr(n_base, base, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCanonicPath(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * path; /* the resource locator in a filesystem notation */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0);

        ret_val = xmlCanonicPath(path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCanonicPath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCreateURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_char_ptr 1
static char * gen_char_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_char_ptr(int no ATTRIBUTE_UNUSED, char * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlNormalizeURIPath(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    char * path; /* pointer to the path string */
    int n_path;

    for (n_path = 0;n_path < gen_nb_char_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_char_ptr(n_path, 0);

        ret_val = xmlNormalizeURIPath(path);
        desret_int(ret_val);
        call_tests++;
        des_char_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNormalizeURIPath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParseURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlURIPtr 1
static xmlURIPtr gen_xmlURIPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlURIPtr(int no ATTRIBUTE_UNUSED, xmlURIPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlParseURIReference(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlURIPtr uri; /* pointer to an URI structure */
    int n_uri;
    char * str; /* the string to analyze */
    int n_str;

    for (n_uri = 0;n_uri < gen_nb_xmlURIPtr;n_uri++) {
    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        uri = gen_xmlURIPtr(n_uri, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlParseURIReference(uri, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlURIPtr(n_uri, uri, 0);
        des_const_char_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseURIReference",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_uri);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlPrintURI(void) {
    int ret = 0;

    int mem_base;
    FILE * stream; /* a FILE* for the output */
    int n_stream;
    xmlURIPtr uri; /* pointer to an xmlURI */
    int n_uri;

    for (n_stream = 0;n_stream < gen_nb_FILE_ptr;n_stream++) {
    for (n_uri = 0;n_uri < gen_nb_xmlURIPtr;n_uri++) {
        mem_base = xmlMemBlocks();
        stream = gen_FILE_ptr(n_stream, 0);
        uri = gen_xmlURIPtr(n_uri, 1);

        xmlPrintURI(stream, uri);
        call_tests++;
        des_FILE_ptr(n_stream, stream, 0);
        des_xmlURIPtr(n_uri, uri, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPrintURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_stream);
            printf(" %d", n_uri);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSaveUri(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlURIPtr uri; /* pointer to an xmlURI */
    int n_uri;

    for (n_uri = 0;n_uri < gen_nb_xmlURIPtr;n_uri++) {
        mem_base = xmlMemBlocks();
        uri = gen_xmlURIPtr(n_uri, 0);

        ret_val = xmlSaveUri(uri);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlURIPtr(n_uri, uri, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_uri);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlURIEscape(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str; /* the string of the URI to escape */
    int n_str;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);

        ret_val = xmlURIEscape(str);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscape",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlURIEscapeStr(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str; /* string to escape */
    int n_str;
    xmlChar * list; /* exception list string of chars not to escape */
    int n_list;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_list = 0;n_list < gen_nb_const_xmlChar_ptr;n_list++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        list = gen_const_xmlChar_ptr(n_list, 1);

        ret_val = xmlURIEscapeStr(str, list);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_const_xmlChar_ptr(n_list, list, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscapeStr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_list);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlURIUnescapeString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_uri(void) {
    int ret = 0;

    printf("Testing uri : 9 of 13 functions ...\n");
    ret += test_xmlBuildRelativeURI();
    ret += test_xmlBuildURI();
    ret += test_xmlCanonicPath();
    ret += test_xmlCreateURI();
    ret += test_xmlNormalizeURIPath();
    ret += test_xmlParseURI();
    ret += test_xmlParseURIReference();
    ret += test_xmlPrintURI();
    ret += test_xmlSaveUri();
    ret += test_xmlURIEscape();
    ret += test_xmlURIEscapeStr();
    ret += test_xmlURIUnescapeString();

    if (ret != 0)
	printf("Module uri: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlEnumerationPtr 1
static xmlEnumerationPtr gen_xmlEnumerationPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlEnumerationPtr(int no ATTRIBUTE_UNUSED, xmlEnumerationPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlAddAttributeDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlElementContentPtr 1
static xmlElementContentPtr gen_xmlElementContentPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlElementContentPtr(int no ATTRIBUTE_UNUSED, xmlElementContentPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlAddElementDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddID(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddNotationDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlAttributeTablePtr 1
static xmlAttributeTablePtr gen_xmlAttributeTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlAttributeTablePtr(int no ATTRIBUTE_UNUSED, xmlAttributeTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlCopyAttributeTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlElementTablePtr 1
static xmlElementTablePtr gen_xmlElementTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlElementTablePtr(int no ATTRIBUTE_UNUSED, xmlElementTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlCopyElementTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyEnumeration(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlNotationTablePtr 1
static xmlNotationTablePtr gen_xmlNotationTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlNotationTablePtr(int no ATTRIBUTE_UNUSED, xmlNotationTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlCopyNotationTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateEnumeration(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlAttributePtr 1
static xmlAttributePtr gen_xmlAttributePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlAttributePtr(int no ATTRIBUTE_UNUSED, xmlAttributePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlDumpAttributeDecl(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlAttributePtr attr; /* An attribute declaration */
    int n_attr;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttributePtr;n_attr++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        attr = gen_xmlAttributePtr(n_attr, 1);

        xmlDumpAttributeDecl(buf, attr);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlAttributePtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpAttributeDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDumpAttributeTable(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlAttributeTablePtr table; /* An attribute table */
    int n_table;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_table = 0;n_table < gen_nb_xmlAttributeTablePtr;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlAttributeTablePtr(n_table, 1);

        xmlDumpAttributeTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlAttributeTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpAttributeTable",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlElementPtr 1
static xmlElementPtr gen_xmlElementPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlElementPtr(int no ATTRIBUTE_UNUSED, xmlElementPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlDumpElementDecl(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlElementPtr elem; /* An element table */
    int n_elem;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_elem = 0;n_elem < gen_nb_xmlElementPtr;n_elem++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        elem = gen_xmlElementPtr(n_elem, 1);

        xmlDumpElementDecl(buf, elem);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlElementPtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpElementDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDumpElementTable(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlElementTablePtr table; /* An element table */
    int n_table;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_table = 0;n_table < gen_nb_xmlElementTablePtr;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlElementTablePtr(n_table, 1);

        xmlDumpElementTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlElementTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpElementTable",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlNotationPtr 1
static xmlNotationPtr gen_xmlNotationPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlNotationPtr(int no ATTRIBUTE_UNUSED, xmlNotationPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlDumpNotationDecl(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlNotationPtr nota; /* A notation declaration */
    int n_nota;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_nota = 0;n_nota < gen_nb_xmlNotationPtr;n_nota++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        nota = gen_xmlNotationPtr(n_nota, 1);

        xmlDumpNotationDecl(buf, nota);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlNotationPtr(n_nota, nota, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpNotationDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_nota);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlDumpNotationTable(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlBufferPtr buf; /* the XML buffer output */
    int n_buf;
    xmlNotationTablePtr table; /* A notation table */
    int n_table;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_table = 0;n_table < gen_nb_xmlNotationTablePtr;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlNotationTablePtr(n_table, 1);

        xmlDumpNotationTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlNotationTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpNotationTable",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlGetDtdAttrDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdElementDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdNotationDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdQAttrDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdQElementDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetID(void) {
    int ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlDocPtr doc; /* pointer to the document */
    int n_doc;
    xmlChar * ID; /* the ID value */
    int n_ID;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_ID = 0;n_ID < gen_nb_const_xmlChar_ptr;n_ID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ID = gen_const_xmlChar_ptr(n_ID, 1);

        ret_val = xmlGetID(doc, ID);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_ID, ID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetID",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ID);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetRefs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsID(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the element carrying the attribute */
    int n_elem;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);

        ret_val = xmlIsID(doc, elem, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsID",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsMixedElement(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * name; /* the element name */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlIsMixedElement(doc, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsMixedElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIsRef(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the element carrying the attribute */
    int n_elem;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);

        ret_val = xmlIsRef(doc, elem, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlNewElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRemoveID(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);

        ret_val = xmlRemoveID(doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveID",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlRemoveRef(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlAttrPtr attr; /* the attribute */
    int n_attr;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);

        ret_val = xmlRemoveRef(doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSnprintfElementContent(void) {
    int ret = 0;

    int mem_base;
    char * buf; /* an output buffer */
    int n_buf;
    int size; /* the buffer size */
    int n_size;
    xmlElementContentPtr content; /* An element table */
    int n_content;
    int glob; /* 1 if one must print the englobing parenthesis, 0 otherwise */
    int n_glob;

    for (n_buf = 0;n_buf < gen_nb_char_ptr;n_buf++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    for (n_glob = 0;n_glob < gen_nb_int;n_glob++) {
        mem_base = xmlMemBlocks();
        buf = gen_char_ptr(n_buf, 0);
        size = gen_int(n_size, 1);
        content = gen_xmlElementContentPtr(n_content, 2);
        glob = gen_int(n_glob, 3);

        xmlSnprintfElementContent(buf, size, content, glob);
        call_tests++;
        des_char_ptr(n_buf, buf, 0);
        des_int(n_size, size, 1);
        des_xmlElementContentPtr(n_content, content, 2);
        des_int(n_glob, glob, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSnprintfElementContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_size);
            printf(" %d", n_content);
            printf(" %d", n_glob);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlSprintfElementContent(void) {
    int ret = 0;

    int mem_base;
    char * buf; /* an output buffer */
    int n_buf;
    xmlElementContentPtr content; /* An element table */
    int n_content;
    int glob; /* 1 if one must print the englobing parenthesis, 0 otherwise */
    int n_glob;

    for (n_buf = 0;n_buf < gen_nb_char_ptr;n_buf++) {
    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    for (n_glob = 0;n_glob < gen_nb_int;n_glob++) {
        mem_base = xmlMemBlocks();
        buf = gen_char_ptr(n_buf, 0);
        content = gen_xmlElementContentPtr(n_content, 1);
        glob = gen_int(n_glob, 2);

        xmlSprintfElementContent(buf, content, glob);
        call_tests++;
        des_char_ptr(n_buf, buf, 0);
        des_xmlElementContentPtr(n_content, content, 1);
        des_int(n_glob, glob, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSprintfElementContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_content);
            printf(" %d", n_glob);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidBuildContentModel(void) {
    int ret = 0;

#ifdef LIBXML_REGEXP_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* a validation context */
    int n_ctxt;
    xmlElementPtr elem; /* an element declaration node */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_elem = 0;n_elem < gen_nb_xmlElementPtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        elem = gen_xmlElementPtr(n_elem, 1);

        ret_val = xmlValidBuildContentModel(ctxt, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlElementPtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidBuildContentModel",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidCtxtNormalizeAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context or NULL */
    int n_ctxt;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the parent */
    int n_elem;
    xmlChar * name; /* the attribute name */
    int n_name;
    xmlChar * value; /* the attribute value */
    int n_value;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        name = gen_const_xmlChar_ptr(n_name, 3);
        value = gen_const_xmlChar_ptr(n_value, 4);

        ret_val = xmlValidCtxtNormalizeAttributeValue(ctxt, doc, elem, name, value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_name, name, 3);
        des_const_xmlChar_ptr(n_value, value, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidCtxtNormalizeAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlElementContent_ptr 1
static xmlElementContent * gen_xmlElementContent_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlElementContent_ptr(int no ATTRIBUTE_UNUSED, xmlElementContent * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlValidGetPotentialChildren(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlElementContent * ctree; /* an element content tree */
    int n_ctree;
    xmlChar ** list; /* an array to store the list of child names */
    int n_list;
    int * len; /* a pointer to the number of element in the list */
    int n_len;
    int max; /* the size of the array */
    int n_max;

    for (n_ctree = 0;n_ctree < gen_nb_xmlElementContent_ptr;n_ctree++) {
    for (n_list = 0;n_list < gen_nb_const_xmlChar_ptr_ptr;n_list++) {
    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    for (n_max = 0;n_max < gen_nb_int;n_max++) {
        mem_base = xmlMemBlocks();
        ctree = gen_xmlElementContent_ptr(n_ctree, 0);
        list = gen_const_xmlChar_ptr_ptr(n_list, 1);
        len = gen_int_ptr(n_len, 2);
        max = gen_int(n_max, 3);

        ret_val = xmlValidGetPotentialChildren(ctree, list, len, max);
        desret_int(ret_val);
        call_tests++;
        des_xmlElementContent_ptr(n_ctree, ctree, 0);
        des_const_xmlChar_ptr_ptr(n_list, list, 1);
        des_int_ptr(n_len, len, 2);
        des_int(n_max, max, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidGetPotentialChildren",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctree);
            printf(" %d", n_list);
            printf(" %d", n_len);
            printf(" %d", n_max);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidGetValidElements(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNode * prev; /* an element to insert after */
    int n_prev;
    xmlNode * next; /* an element to insert next */
    int n_next;
    xmlChar ** names; /* an array to store the list of child names */
    int n_names;
    int max; /* the size of the array */
    int n_max;

    for (n_prev = 0;n_prev < gen_nb_xmlNodePtr;n_prev++) {
    for (n_next = 0;n_next < gen_nb_xmlNodePtr;n_next++) {
    for (n_names = 0;n_names < gen_nb_const_xmlChar_ptr_ptr;n_names++) {
    for (n_max = 0;n_max < gen_nb_int;n_max++) {
        mem_base = xmlMemBlocks();
        prev = gen_xmlNodePtr(n_prev, 0);
        next = gen_xmlNodePtr(n_next, 1);
        names = gen_const_xmlChar_ptr_ptr(n_names, 2);
        max = gen_int(n_max, 3);

        ret_val = xmlValidGetValidElements(prev, next, names, max);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_prev, prev, 0);
        des_xmlNodePtr(n_next, next, 1);
        des_const_xmlChar_ptr_ptr(n_names, names, 2);
        des_int(n_max, max, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidGetValidElements",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_prev);
            printf(" %d", n_next);
            printf(" %d", n_names);
            printf(" %d", n_max);
            printf("\n");
        }
    }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlValidNormalizeAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the parent */
    int n_elem;
    xmlChar * name; /* the attribute name */
    int n_name;
    xmlChar * value; /* the attribute value */
    int n_value;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlValidNormalizeAttributeValue(doc, elem, name, value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_value, value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidNormalizeAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateAttributeDecl(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlAttributePtr attr; /* an attribute definition */
    int n_attr;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttributePtr;n_attr++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        attr = gen_xmlAttributePtr(n_attr, 2);

        ret_val = xmlValidateAttributeDecl(ctxt, doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlAttributePtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateAttributeDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlAttributeType type; /* an attribute type */
    int n_type;
    xmlChar * value; /* an attribute value */
    int n_value;

    for (n_type = 0;n_type < gen_nb_xmlAttributeType;n_type++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlAttributeType(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = xmlValidateAttributeValue(type, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlAttributeType(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateDocument(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDocument(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateDocumentFinal(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDocumentFinal(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDocumentFinal",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateDtd(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlDtdPtr dtd; /* a dtd instance */
    int n_dtd;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        dtd = gen_xmlDtdPtr(n_dtd, 2);

        ret_val = xmlValidateDtd(ctxt, doc, dtd);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlDtdPtr(n_dtd, dtd, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDtd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_dtd);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateDtdFinal(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDtdFinal(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDtdFinal",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateElement(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlValidateElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateElementDecl(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlElementPtr elem; /* an element definition */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlElementPtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlElementPtr(n_elem, 2);

        ret_val = xmlValidateElementDecl(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlElementPtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateElementDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNameValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * value; /* an Name value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNameValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNameValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNamesValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * value; /* an Names value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNamesValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNamesValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNmtokenValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * value; /* an Nmtoken value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNmtokenValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokenValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNmtokensValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * value; /* an Nmtokens value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNmtokensValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokensValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNotationDecl(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNotationPtr nota; /* a notation definition */
    int n_nota;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_nota = 0;n_nota < gen_nb_xmlNotationPtr;n_nota++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        nota = gen_xmlNotationPtr(n_nota, 2);

        ret_val = xmlValidateNotationDecl(ctxt, doc, nota);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNotationPtr(n_nota, nota, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNotationDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_nota);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateNotationUse(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlChar * notationName; /* the notation name to check */
    int n_notationName;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_notationName = 0;n_notationName < gen_nb_const_xmlChar_ptr;n_notationName++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        notationName = gen_const_xmlChar_ptr(n_notationName, 2);

        ret_val = xmlValidateNotationUse(ctxt, doc, notationName);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_const_xmlChar_ptr(n_notationName, notationName, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNotationUse",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_notationName);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateOneAttribute(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;
    xmlAttrPtr attr; /* an attribute instance */
    int n_attr;
    xmlChar * value; /* the attribute value (without entities processing) */
    int n_value;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        attr = gen_xmlAttrPtr(n_attr, 3);
        value = gen_const_xmlChar_ptr(n_value, 4);

        ret_val = xmlValidateOneAttribute(ctxt, doc, elem, attr, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_xmlAttrPtr(n_attr, attr, 3);
        des_const_xmlChar_ptr(n_value, value, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateOneElement(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlValidateOneElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateOneNamespace(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;
    xmlChar * prefix; /* the namespace prefix */
    int n_prefix;
    xmlNsPtr ns; /* an namespace declaration instance */
    int n_ns;
    xmlChar * value; /* the attribute value (without entities processing) */
    int n_value;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        prefix = gen_const_xmlChar_ptr(n_prefix, 3);
        ns = gen_xmlNsPtr(n_ns, 4);
        value = gen_const_xmlChar_ptr(n_value, 5);

        ret_val = xmlValidateOneNamespace(ctxt, doc, elem, prefix, ns, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_prefix, prefix, 3);
        des_xmlNsPtr(n_ns, ns, 4);
        des_const_xmlChar_ptr(n_value, value, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneNamespace",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_prefix);
            printf(" %d", n_ns);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidatePopElement(void) {
    int ret = 0;

#ifdef LIBXML_REGEXP_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;
    xmlChar * qname; /* the qualified name as appearing in the serialization */
    int n_qname;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_qname = 0;n_qname < gen_nb_const_xmlChar_ptr;n_qname++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        qname = gen_const_xmlChar_ptr(n_qname, 3);

        ret_val = xmlValidatePopElement(ctxt, doc, elem, qname);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_qname, qname, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePopElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_qname);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidatePushCData(void) {
    int ret = 0;

#ifdef LIBXML_REGEXP_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlChar * data; /* some character data read */
    int n_data;
    int len; /* the lenght of the data */
    int n_len;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_data = 0;n_data < gen_nb_const_xmlChar_ptr;n_data++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        data = gen_const_xmlChar_ptr(n_data, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlValidatePushCData(ctxt, data, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_data, data, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePushCData",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_data);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidatePushElement(void) {
    int ret = 0;

#ifdef LIBXML_REGEXP_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;
    xmlNodePtr elem; /* an element instance */
    int n_elem;
    xmlChar * qname; /* the qualified name as appearing in the serialization */
    int n_qname;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_qname = 0;n_qname < gen_nb_const_xmlChar_ptr;n_qname++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        qname = gen_const_xmlChar_ptr(n_qname, 3);

        ret_val = xmlValidatePushElement(ctxt, doc, elem, qname);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_qname, qname, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePushElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_qname);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlValidateRoot(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt; /* the validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a document instance */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateRoot(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateRoot",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_valid(void) {
    int ret = 0;

    printf("Testing valid : 40 of 67 functions ...\n");
    ret += test_xmlAddAttributeDecl();
    ret += test_xmlAddElementDecl();
    ret += test_xmlAddID();
    ret += test_xmlAddNotationDecl();
    ret += test_xmlAddRef();
    ret += test_xmlCopyAttributeTable();
    ret += test_xmlCopyElementContent();
    ret += test_xmlCopyElementTable();
    ret += test_xmlCopyEnumeration();
    ret += test_xmlCopyNotationTable();
    ret += test_xmlCreateEnumeration();
    ret += test_xmlDumpAttributeDecl();
    ret += test_xmlDumpAttributeTable();
    ret += test_xmlDumpElementDecl();
    ret += test_xmlDumpElementTable();
    ret += test_xmlDumpNotationDecl();
    ret += test_xmlDumpNotationTable();
    ret += test_xmlGetDtdAttrDesc();
    ret += test_xmlGetDtdElementDesc();
    ret += test_xmlGetDtdNotationDesc();
    ret += test_xmlGetDtdQAttrDesc();
    ret += test_xmlGetDtdQElementDesc();
    ret += test_xmlGetID();
    ret += test_xmlGetRefs();
    ret += test_xmlIsID();
    ret += test_xmlIsMixedElement();
    ret += test_xmlIsRef();
    ret += test_xmlNewElementContent();
    ret += test_xmlNewValidCtxt();
    ret += test_xmlRemoveID();
    ret += test_xmlRemoveRef();
    ret += test_xmlSnprintfElementContent();
    ret += test_xmlSprintfElementContent();
    ret += test_xmlValidBuildContentModel();
    ret += test_xmlValidCtxtNormalizeAttributeValue();
    ret += test_xmlValidGetPotentialChildren();
    ret += test_xmlValidGetValidElements();
    ret += test_xmlValidNormalizeAttributeValue();
    ret += test_xmlValidateAttributeDecl();
    ret += test_xmlValidateAttributeValue();
    ret += test_xmlValidateDocument();
    ret += test_xmlValidateDocumentFinal();
    ret += test_xmlValidateDtd();
    ret += test_xmlValidateDtdFinal();
    ret += test_xmlValidateElement();
    ret += test_xmlValidateElementDecl();
    ret += test_xmlValidateNameValue();
    ret += test_xmlValidateNamesValue();
    ret += test_xmlValidateNmtokenValue();
    ret += test_xmlValidateNmtokensValue();
    ret += test_xmlValidateNotationDecl();
    ret += test_xmlValidateNotationUse();
    ret += test_xmlValidateOneAttribute();
    ret += test_xmlValidateOneElement();
    ret += test_xmlValidateOneNamespace();
    ret += test_xmlValidatePopElement();
    ret += test_xmlValidatePushCData();
    ret += test_xmlValidatePushElement();
    ret += test_xmlValidateRoot();

    if (ret != 0)
	printf("Module valid: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXIncludeNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXIncludeProcess(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* an XML document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlXIncludeProcess(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcess",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeProcessFlags(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* an XML document */
    int n_doc;
    int flags; /* a set of xmlParserOption used for parsing XML includes */
    int n_flags;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeProcessFlags(doc, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessFlags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlXIncludeCtxtPtr 1
static xmlXIncludeCtxtPtr gen_xmlXIncludeCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlXIncludeCtxtPtr(int no ATTRIBUTE_UNUSED, xmlXIncludeCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlXIncludeProcessNode(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlXIncludeCtxtPtr ctxt; /* an existing XInclude context */
    int n_ctxt;
    xmlNodePtr node; /* a node in an XML document */
    int n_node;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXIncludeCtxtPtr;n_ctxt++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlXIncludeProcessNode(ctxt, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeProcessTree(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr tree; /* a node in an XML document */
    int n_tree;

    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0);

        ret_val = xmlXIncludeProcessTree(tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTree",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_tree);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeProcessTreeFlags(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr tree; /* a node in an XML document */
    int n_tree;
    int flags; /* a set of xmlParserOption used for parsing XML includes */
    int n_flags;

    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeProcessTreeFlags(tree, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTreeFlags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_tree);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXIncludeSetFlags(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlXIncludeCtxtPtr ctxt; /* an XInclude processing context */
    int n_ctxt;
    int flags; /* a set of xmlParserOption used for parsing XML includes */
    int n_flags;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXIncludeCtxtPtr;n_ctxt++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeSetFlags(ctxt, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeSetFlags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xinclude(void) {
    int ret = 0;

    printf("Testing xinclude : 6 of 8 functions ...\n");
    ret += test_xmlXIncludeNewContext();
    ret += test_xmlXIncludeProcess();
    ret += test_xmlXIncludeProcessFlags();
    ret += test_xmlXIncludeProcessNode();
    ret += test_xmlXIncludeProcessTree();
    ret += test_xmlXIncludeProcessTreeFlags();
    ret += test_xmlXIncludeSetFlags();

    if (ret != 0)
	printf("Module xinclude: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAllocOutputBuffer(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr ret_val;
    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
    int n_encoder;

    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
        mem_base = xmlMemBlocks();
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 0);

        ret_val = xmlAllocOutputBuffer(encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAllocOutputBuffer",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_encoder);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlAllocParserInputBuffer(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        enc = gen_xmlCharEncoding(n_enc, 0);

        ret_val = xmlAllocParserInputBuffer(enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_xmlCharEncoding(n_enc, enc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAllocParserInputBuffer",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_enc);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCheckFilename(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    char * path; /* the path to check */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_char_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_char_ptr(n_path, 0);

        ret_val = xmlCheckFilename(path);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCheckHTTPInput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCleanupInputCallbacks(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlCleanupOutputCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupOutputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlFileClose(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlFileClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlFileMatch(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlFileMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlFileOpen(void) {
    int ret = 0;

    int mem_base;
    void * ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlFileOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlFileRead(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;
    char * buffer; /* where to drop data */
    int n_buffer;
    int len; /* number of bytes to write */
    int n_len;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);
        buffer = gen_char_ptr(n_buffer, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlFileRead(context, buffer, len);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        des_char_ptr(n_buffer, buffer, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf(" %d", n_buffer);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlIOFTPClose(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlIOFTPClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOFTPMatch(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOFTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOFTPOpen(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOFTPOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOFTPRead(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;
    char * buffer; /* where to drop data */
    int n_buffer;
    int len; /* number of bytes to write */
    int n_len;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);
        buffer = gen_char_ptr(n_buffer, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlIOFTPRead(context, buffer, len);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        des_char_ptr(n_buffer, buffer, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf(" %d", n_buffer);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOHTTPClose(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlIOHTTPClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOHTTPMatch(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOHTTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOHTTPOpen(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    void * ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOHTTPOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPOpen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlIOHTTPOpenW(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOHTTPRead(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    void * context; /* the I/O context */
    int n_context;
    char * buffer; /* where to drop data */
    int n_buffer;
    int len; /* number of bytes to write */
    int n_len;

    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);
        buffer = gen_char_ptr(n_buffer, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlIOHTTPRead(context, buffer, len);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        des_char_ptr(n_buffer, buffer, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_context);
            printf(" %d", n_buffer);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNoNetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNormalizeWindowsPath(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * path; /* the input file path */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0);

        ret_val = xmlNormalizeWindowsPath(path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNormalizeWindowsPath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferCreateFd(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr ret_val;
    int fd; /* a file descriptor number */
    int n_fd;
    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
    int n_encoder;

    for (n_fd = 0;n_fd < gen_nb_int;n_fd++) {
    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
        mem_base = xmlMemBlocks();
        fd = gen_int(n_fd, 0);
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);

        ret_val = xmlOutputBufferCreateFd(fd, encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_int(n_fd, fd, 0);
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferCreateFd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_fd);
            printf(" %d", n_encoder);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferCreateFile(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr ret_val;
    FILE * file; /* a FILE* */
    int n_file;
    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
    int n_encoder;

    for (n_file = 0;n_file < gen_nb_FILE_ptr;n_file++) {
    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
        mem_base = xmlMemBlocks();
        file = gen_FILE_ptr(n_file, 0);
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);

        ret_val = xmlOutputBufferCreateFile(file, encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_FILE_ptr(n_file, file, 0);
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferCreateFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_file);
            printf(" %d", n_encoder);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferCreateFilename(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    xmlOutputBufferPtr ret_val;
    const char * URI; /* a C string containing the URI or filename */
    int n_URI;
    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
    int n_encoder;
    int compression; /* the compression ration (0 none, 9 max). */
    int n_compression;

    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
        mem_base = xmlMemBlocks();
        URI = gen_filepath(n_URI, 0);
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);
        compression = gen_int(n_compression, 2);

        ret_val = xmlOutputBufferCreateFilename(URI, encoder, compression);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_filepath(n_URI, URI, 0);
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
        des_int(n_compression, compression, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferCreateFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_encoder);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferCreateIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferFlush(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out; /* a buffered output */
    int n_out;

    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);

        ret_val = xmlOutputBufferFlush(out);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferFlush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferWrite(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out; /* a buffered parser output */
    int n_out;
    int len; /* the size in bytes of the array. */
    int n_len;
    char * buf; /* an char array */
    int n_buf;

    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    for (n_buf = 0;n_buf < gen_nb_const_char_ptr;n_buf++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);
        len = gen_int(n_len, 1);
        buf = gen_const_char_ptr(n_buf, 2);

        ret_val = xmlOutputBufferWrite(out, len, buf);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        des_int(n_len, len, 1);
        des_const_char_ptr(n_buf, buf, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferWrite",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_len);
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlOutputBufferWriteEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferWriteString(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out; /* a buffered parser output */
    int n_out;
    char * str; /* a zero terminated C string */
    int n_str;

    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlOutputBufferWriteString(out, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        des_const_char_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferWriteString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlParserGetDirectory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateFd(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    int fd; /* a file descriptor number */
    int n_fd;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_fd = 0;n_fd < gen_nb_int;n_fd++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        fd = gen_int(n_fd, 0);
        enc = gen_xmlCharEncoding(n_enc, 1);
        if (fd >= 0) fd = -1;

        ret_val = xmlParserInputBufferCreateFd(fd, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_int(n_fd, fd, 0);
        des_xmlCharEncoding(n_enc, enc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateFd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_fd);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferCreateFile(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    FILE * file; /* a FILE* */
    int n_file;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_file = 0;n_file < gen_nb_FILE_ptr;n_file++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        file = gen_FILE_ptr(n_file, 0);
        enc = gen_xmlCharEncoding(n_enc, 1);

        ret_val = xmlParserInputBufferCreateFile(file, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_FILE_ptr(n_file, file, 0);
        des_xmlCharEncoding(n_enc, enc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_file);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferCreateFilename(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    const char * URI; /* a C string containing the URI or filename */
    int n_URI;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        URI = gen_filepath(n_URI, 0);
        enc = gen_xmlCharEncoding(n_enc, 1);

        ret_val = xmlParserInputBufferCreateFilename(URI, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_filepath(n_URI, URI, 0);
        des_xmlCharEncoding(n_enc, enc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferCreateIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateMem(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    char * mem; /* the memory input */
    int n_mem;
    int size; /* the length of the memory block */
    int n_size;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_mem = 0;n_mem < gen_nb_const_char_ptr;n_mem++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        mem = gen_const_char_ptr(n_mem, 0);
        size = gen_int(n_size, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlParserInputBufferCreateMem(mem, size, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_mem, mem, 0);
        des_int(n_size, size, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateMem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferCreateStatic(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    char * mem; /* the memory input */
    int n_mem;
    int size; /* the length of the memory block */
    int n_size;
    xmlCharEncoding enc; /* the charset encoding if known */
    int n_enc;

    for (n_mem = 0;n_mem < gen_nb_const_char_ptr;n_mem++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
        mem_base = xmlMemBlocks();
        mem = gen_const_char_ptr(n_mem, 0);
        size = gen_int(n_size, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlParserInputBufferCreateStatic(mem, size, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_mem, mem, 0);
        des_int(n_size, size, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateStatic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferGrow(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in; /* a buffered parser input */
    int n_in;
    int len; /* indicative value of the amount of chars to read */
    int n_len;

    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputBufferGrow(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferGrow",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferPush(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in; /* a buffered parser input */
    int n_in;
    int len; /* the size in bytes of the array. */
    int n_len;
    char * buf; /* an char array */
    int n_buf;

    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    for (n_buf = 0;n_buf < gen_nb_const_char_ptr;n_buf++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);
        buf = gen_const_char_ptr(n_buf, 2);

        ret_val = xmlParserInputBufferPush(in, len, buf);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        des_const_char_ptr(n_buf, buf, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferPush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserInputBufferRead(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in; /* a buffered parser input */
    int n_in;
    int len; /* indicative value of the amount of chars to read */
    int n_len;

    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputBufferRead(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlPopInputCallbacks(void) {
    int ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlPopInputCallbacks();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPopInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterDefaultInputCallbacks(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterDefaultOutputCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultOutputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterHTTPPostCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterHTTPPostCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterHTTPPostCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlRegisterInputCallbacks(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegisterOutputCallbacks(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlIO(void) {
    int ret = 0;

    printf("Testing xmlIO : 36 of 47 functions ...\n");
    ret += test_xmlAllocOutputBuffer();
    ret += test_xmlAllocParserInputBuffer();
    ret += test_xmlCheckFilename();
    ret += test_xmlCheckHTTPInput();
    ret += test_xmlCleanupInputCallbacks();
    ret += test_xmlCleanupOutputCallbacks();
    ret += test_xmlFileClose();
    ret += test_xmlFileMatch();
    ret += test_xmlFileOpen();
    ret += test_xmlFileRead();
    ret += test_xmlIOFTPClose();
    ret += test_xmlIOFTPMatch();
    ret += test_xmlIOFTPOpen();
    ret += test_xmlIOFTPRead();
    ret += test_xmlIOHTTPClose();
    ret += test_xmlIOHTTPMatch();
    ret += test_xmlIOHTTPOpen();
    ret += test_xmlIOHTTPOpenW();
    ret += test_xmlIOHTTPRead();
    ret += test_xmlNoNetExternalEntityLoader();
    ret += test_xmlNormalizeWindowsPath();
    ret += test_xmlOutputBufferCreateFd();
    ret += test_xmlOutputBufferCreateFile();
    ret += test_xmlOutputBufferCreateFilename();
    ret += test_xmlOutputBufferCreateIO();
    ret += test_xmlOutputBufferFlush();
    ret += test_xmlOutputBufferWrite();
    ret += test_xmlOutputBufferWriteEscape();
    ret += test_xmlOutputBufferWriteString();
    ret += test_xmlParserGetDirectory();
    ret += test_xmlParserInputBufferCreateFd();
    ret += test_xmlParserInputBufferCreateFile();
    ret += test_xmlParserInputBufferCreateFilename();
    ret += test_xmlParserInputBufferCreateIO();
    ret += test_xmlParserInputBufferCreateMem();
    ret += test_xmlParserInputBufferCreateStatic();
    ret += test_xmlParserInputBufferGrow();
    ret += test_xmlParserInputBufferPush();
    ret += test_xmlParserInputBufferRead();
    ret += test_xmlPopInputCallbacks();
    ret += test_xmlRegisterDefaultInputCallbacks();
    ret += test_xmlRegisterDefaultOutputCallbacks();
    ret += test_xmlRegisterHTTPPostCallbacks();
    ret += test_xmlRegisterInputCallbacks();
    ret += test_xmlRegisterOutputCallbacks();

    if (ret != 0)
	printf("Module xmlIO: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlGenericErrorFunc_ptr 1
static xmlGenericErrorFunc * gen_xmlGenericErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlGenericErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlGenericErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_initGenericErrorDefaultFunc(void) {
    int ret = 0;

    int mem_base;
    xmlGenericErrorFunc * handler; /* the handler */
    int n_handler;

    for (n_handler = 0;n_handler < gen_nb_xmlGenericErrorFunc_ptr;n_handler++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlGenericErrorFunc_ptr(n_handler, 0);

        initGenericErrorDefaultFunc(handler);
        call_tests++;
        des_xmlGenericErrorFunc_ptr(n_handler, handler, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in initGenericErrorDefaultFunc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_handler);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


#define gen_nb_xmlErrorPtr 1
static xmlErrorPtr gen_xmlErrorPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlErrorPtr(int no ATTRIBUTE_UNUSED, xmlErrorPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlCopyError(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlErrorPtr from; /* a source error */
    int n_from;
    xmlErrorPtr to; /* a target error */
    int n_to;

    for (n_from = 0;n_from < gen_nb_xmlErrorPtr;n_from++) {
    for (n_to = 0;n_to < gen_nb_xmlErrorPtr;n_to++) {
        mem_base = xmlMemBlocks();
        from = gen_xmlErrorPtr(n_from, 0);
        to = gen_xmlErrorPtr(n_to, 1);

        ret_val = xmlCopyError(from, to);
        desret_int(ret_val);
        call_tests++;
        des_xmlErrorPtr(n_from, from, 0);
        des_xmlErrorPtr(n_to, to, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyError",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_from);
            printf(" %d", n_to);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCtxtGetLastError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCtxtResetLastError(void) {
    int ret = 0;

    int mem_base;
    void * ctx; /* an XML parser context */
    int n_ctx;

    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        xmlCtxtResetLastError(ctx);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtResetLastError",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetLastError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserPrintFileContext(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputPtr input; /* an xmlParserInputPtr input */
    int n_input;

    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputPtr(n_input, 0);

        xmlParserPrintFileContext(input);
        call_tests++;
        des_xmlParserInputPtr(n_input, input, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserPrintFileContext",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_input);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserPrintFileInfo(void) {
    int ret = 0;

    int mem_base;
    xmlParserInputPtr input; /* an xmlParserInputPtr input */
    int n_input;

    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputPtr(n_input, 0);

        xmlParserPrintFileInfo(input);
        call_tests++;
        des_xmlParserInputPtr(n_input, input, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserPrintFileInfo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_input);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlParserValidityError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserValidityWarning(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserWarning(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlResetError(void) {
    int ret = 0;

    int mem_base;
    xmlErrorPtr err; /* pointer to the error. */
    int n_err;

    for (n_err = 0;n_err < gen_nb_xmlErrorPtr;n_err++) {
        mem_base = xmlMemBlocks();
        err = gen_xmlErrorPtr(n_err, 0);

        xmlResetError(err);
        call_tests++;
        des_xmlErrorPtr(n_err, err, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlResetError",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_err);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlResetLastError(void) {
    int ret = 0;



        xmlResetLastError();
        call_tests++;
        xmlResetLastError();

    function_tests++;
    return(ret);
}


static int
test_xmlSetGenericErrorFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetStructuredErrorFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlerror(void) {
    int ret = 0;

    printf("Testing xmlerror : 7 of 15 functions ...\n");
    ret += test_initGenericErrorDefaultFunc();
    ret += test_xmlCopyError();
    ret += test_xmlCtxtGetLastError();
    ret += test_xmlCtxtResetLastError();
    ret += test_xmlGetLastError();
    ret += test_xmlParserError();
    ret += test_xmlParserPrintFileContext();
    ret += test_xmlParserPrintFileInfo();
    ret += test_xmlParserValidityError();
    ret += test_xmlParserValidityWarning();
    ret += test_xmlParserWarning();
    ret += test_xmlResetError();
    ret += test_xmlResetLastError();
    ret += test_xmlSetGenericErrorFunc();
    ret += test_xmlSetStructuredErrorFunc();

    if (ret != 0)
	printf("Module xmlerror: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNewTextReader(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlParserInputBufferPtr input; /* the xmlParserInputBufferPtr used to read data */
    int n_input;
    const char * URI; /* the URI information for the source if available */
    int n_URI;

    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputBufferPtr(n_input, 0);
        URI = gen_filepath(n_URI, 1);

        ret_val = xmlNewTextReader(input, URI);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_input, input, 0);
        des_filepath(n_URI, URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextReader",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_input);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextReaderFilename(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    const char * URI; /* the URI of the resource to process */
    int n_URI;

    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
        mem_base = xmlMemBlocks();
        URI = gen_filepath(n_URI, 0);

        ret_val = xmlNewTextReaderFilename(URI);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_filepath(n_URI, URI, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextReaderFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderForDoc(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlReaderForDoc(cur, URL, encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderForFile(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_int(n_options, 2);

        ret_val = xmlReaderForFile(filename, encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, encoding, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderForIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderForMemory(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlReaderForMemory(buffer, size, URL, encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewDoc(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = xmlReaderNewDoc(reader, cur, URL, encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_cur, cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewFile(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    const char * filename; /* a file or URL */
    int n_filename;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlReaderNewFile(reader, filename, encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewMemory(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_int(n_options, 5);

        ret_val = xmlReaderNewMemory(reader, buffer, size, URL, encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_char_ptr(n_buffer, buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, encoding, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderNewWalker(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* an XML reader */
    int n_reader;
    xmlDocPtr doc; /* a preparsed document */
    int n_doc;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlReaderNewWalker(reader, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewWalker",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlReaderWalker(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlDocPtr doc; /* a preparsed document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlReaderWalker(doc);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderWalker",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderAttributeCount(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderAttributeCount(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderAttributeCount",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderBaseUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderBaseUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderBaseUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderClose(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderClose(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstBaseUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstBaseUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstBaseUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstEncoding(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstEncoding(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstLocalName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstLocalName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstLocalName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstNamespaceUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstNamespaceUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstNamespaceUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstPrefix(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstPrefix(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstPrefix",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstString(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlChar * str; /* the string to intern. */
    int n_str;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlTextReaderConstString(reader, str);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstValue(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstXmlLang(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstXmlLang(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstXmlLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderConstXmlVersion(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstXmlVersion(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstXmlVersion",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderCurrentDoc(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderCurrentDoc(reader);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderCurrentDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderCurrentNode(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderCurrentNode(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderCurrentNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderDepth(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderDepth(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderDepth",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderExpand(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderExpand(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderExpand",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlChar * name; /* the qualified name of the attribute. */
    int n_name;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextReaderGetAttribute(reader, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetAttributeNo(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int no; /* the zero-based index of the attribute relative to the containing element */
    int n_no;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_no = 0;n_no < gen_nb_int;n_no++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        no = gen_int(n_no, 1);

        ret_val = xmlTextReaderGetAttributeNo(reader, no);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_no, no, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_no);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetAttributeNs(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlChar * localName; /* the local name of the attribute. */
    int n_localName;
    xmlChar * namespaceURI; /* the namespace URI of the attribute. */
    int n_namespaceURI;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        localName = gen_const_xmlChar_ptr(n_localName, 1);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);

        ret_val = xmlTextReaderGetAttributeNs(reader, localName, namespaceURI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_localName, localName, 1);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_localName);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlTextReaderErrorFunc_ptr 1
static xmlTextReaderErrorFunc * gen_xmlTextReaderErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlTextReaderErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlTextReaderErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlTextReaderGetErrorHandler(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlTextReaderErrorFunc * f; /* the callback function or NULL is no callback has been registered */
    int n_f;
    void ** arg; /* a user argument */
    int n_arg;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_f = 0;n_f < gen_nb_xmlTextReaderErrorFunc_ptr;n_f++) {
    for (n_arg = 0;n_arg < gen_nb_void_ptr_ptr;n_arg++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        f = gen_xmlTextReaderErrorFunc_ptr(n_f, 1);
        arg = gen_void_ptr_ptr(n_arg, 2);

        xmlTextReaderGetErrorHandler(reader, f, arg);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlTextReaderErrorFunc_ptr(n_f, f, 1);
        des_void_ptr_ptr(n_arg, arg, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetErrorHandler",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_f);
            printf(" %d", n_arg);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetParserProp(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int prop; /* the xmlParserProperties to get */
    int n_prop;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prop = gen_int(n_prop, 1);

        ret_val = xmlTextReaderGetParserProp(reader, prop);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_prop, prop, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetParserProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prop);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderGetRemainder(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlParserInputBufferPtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderGetRemainder(reader);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetRemainder",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderHasAttributes(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderHasAttributes(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderHasAttributes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderHasValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderHasValue(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderHasValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsDefault(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsDefault(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsEmptyElement(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsEmptyElement(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsEmptyElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsNamespaceDecl(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsNamespaceDecl(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsNamespaceDecl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderIsValid(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsValid(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsValid",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderLocalName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderLocalName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLocalName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlTextReaderLocatorPtr 1
static xmlTextReaderLocatorPtr gen_xmlTextReaderLocatorPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlTextReaderLocatorPtr(int no ATTRIBUTE_UNUSED, xmlTextReaderLocatorPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlTextReaderLocatorBaseURI(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
    int n_locator;

    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
        mem_base = xmlMemBlocks();
        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);

        ret_val = xmlTextReaderLocatorBaseURI(locator);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLocatorBaseURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_locator);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderLocatorLineNumber(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
    int n_locator;

    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
        mem_base = xmlMemBlocks();
        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);

        ret_val = xmlTextReaderLocatorLineNumber(locator);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLocatorLineNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_locator);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderLookupNamespace(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlChar * prefix; /* the prefix whose namespace URI is to be resolved. To return the default namespace, specify NULL */
    int n_prefix;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);

        ret_val = xmlTextReaderLookupNamespace(reader, prefix);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLookupNamespace",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlChar * name; /* the qualified name of the attribute. */
    int n_name;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextReaderMoveToAttribute(reader, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToAttributeNo(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int no; /* the zero-based index of the attribute relative to the containing element. */
    int n_no;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_no = 0;n_no < gen_nb_int;n_no++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        no = gen_int(n_no, 1);

        ret_val = xmlTextReaderMoveToAttributeNo(reader, no);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_no, no, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_no);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToAttributeNs(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlChar * localName; /* the local name of the attribute. */
    int n_localName;
    xmlChar * namespaceURI; /* the namespace URI of the attribute. */
    int n_namespaceURI;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        localName = gen_const_xmlChar_ptr(n_localName, 1);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);

        ret_val = xmlTextReaderMoveToAttributeNs(reader, localName, namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_localName, localName, 1);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_localName);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToElement(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToElement(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToFirstAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToFirstAttribute(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToFirstAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderMoveToNextAttribute(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToNextAttribute(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToNextAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderName(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNamespaceUri(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNamespaceUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNamespaceUri",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNext(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNext(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNext",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNextSibling(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNextSibling(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNextSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNodeType(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNodeType(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNodeType",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderNormalization(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNormalization(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNormalization",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderPrefix(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderPrefix(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPrefix",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderPreserve(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderPreserve(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderPreservePattern(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlChar * pattern; /* an XPath subset pattern */
    int n_pattern;
    xmlChar ** namespaces; /* the prefix definitions, array of [URI, prefix] or NULL */
    int n_namespaces;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_pattern = 0;n_pattern < gen_nb_const_xmlChar_ptr;n_pattern++) {
    for (n_namespaces = 0;n_namespaces < gen_nb_const_xmlChar_ptr_ptr;n_namespaces++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        pattern = gen_const_xmlChar_ptr(n_pattern, 1);
        namespaces = gen_const_xmlChar_ptr_ptr(n_namespaces, 2);

        ret_val = xmlTextReaderPreservePattern(reader, pattern, namespaces);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_pattern, pattern, 1);
        des_const_xmlChar_ptr_ptr(n_namespaces, namespaces, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPreservePattern",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_pattern);
            printf(" %d", n_namespaces);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderQuoteChar(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderQuoteChar(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderQuoteChar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderRead(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderRead(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRead",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderReadAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderReadAttributeValue(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderReadAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderReadState(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderReadState(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderReadState",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderRelaxNGSetSchema(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    xmlRelaxNGPtr schema; /* a precompiled RelaxNG schema */
    int n_schema;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        schema = gen_xmlRelaxNGPtr(n_schema, 1);

        ret_val = xmlTextReaderRelaxNGSetSchema(reader, schema);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlRelaxNGPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRelaxNGSetSchema",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderRelaxNGValidate(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    char * rng; /* the path to a RelaxNG schema or NULL */
    int n_rng;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_rng = 0;n_rng < gen_nb_const_char_ptr;n_rng++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        rng = gen_const_char_ptr(n_rng, 1);

        ret_val = xmlTextReaderRelaxNGValidate(reader, rng);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_char_ptr(n_rng, rng, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidate",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_rng);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderSetErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderSetParserProp(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;
    int prop; /* the xmlParserProperties to set */
    int n_prop;
    int value; /* usually 0 or 1 to (de)activate it */
    int n_value;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
    for (n_value = 0;n_value < gen_nb_int;n_value++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prop = gen_int(n_prop, 1);
        value = gen_int(n_value, 2);

        ret_val = xmlTextReaderSetParserProp(reader, prop, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_prop, prop, 1);
        des_int(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderSetParserProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prop);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderSetStructuredErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderStandalone(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderStandalone(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderStandalone",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderValue(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderValue(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextReaderXmlLang(void) {
    int ret = 0;

#ifdef LIBXML_READER_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
    int n_reader;

    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderXmlLang(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderXmlLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xmlreader(void) {
    int ret = 0;

    printf("Testing xmlreader : 68 of 78 functions ...\n");
    ret += test_xmlNewTextReader();
    ret += test_xmlNewTextReaderFilename();
    ret += test_xmlReaderForDoc();
    ret += test_xmlReaderForFile();
    ret += test_xmlReaderForIO();
    ret += test_xmlReaderForMemory();
    ret += test_xmlReaderNewDoc();
    ret += test_xmlReaderNewFile();
    ret += test_xmlReaderNewMemory();
    ret += test_xmlReaderNewWalker();
    ret += test_xmlReaderWalker();
    ret += test_xmlTextReaderAttributeCount();
    ret += test_xmlTextReaderBaseUri();
    ret += test_xmlTextReaderClose();
    ret += test_xmlTextReaderConstBaseUri();
    ret += test_xmlTextReaderConstEncoding();
    ret += test_xmlTextReaderConstLocalName();
    ret += test_xmlTextReaderConstName();
    ret += test_xmlTextReaderConstNamespaceUri();
    ret += test_xmlTextReaderConstPrefix();
    ret += test_xmlTextReaderConstString();
    ret += test_xmlTextReaderConstValue();
    ret += test_xmlTextReaderConstXmlLang();
    ret += test_xmlTextReaderConstXmlVersion();
    ret += test_xmlTextReaderCurrentDoc();
    ret += test_xmlTextReaderCurrentNode();
    ret += test_xmlTextReaderDepth();
    ret += test_xmlTextReaderExpand();
    ret += test_xmlTextReaderGetAttribute();
    ret += test_xmlTextReaderGetAttributeNo();
    ret += test_xmlTextReaderGetAttributeNs();
    ret += test_xmlTextReaderGetErrorHandler();
    ret += test_xmlTextReaderGetParserProp();
    ret += test_xmlTextReaderGetRemainder();
    ret += test_xmlTextReaderHasAttributes();
    ret += test_xmlTextReaderHasValue();
    ret += test_xmlTextReaderIsDefault();
    ret += test_xmlTextReaderIsEmptyElement();
    ret += test_xmlTextReaderIsNamespaceDecl();
    ret += test_xmlTextReaderIsValid();
    ret += test_xmlTextReaderLocalName();
    ret += test_xmlTextReaderLocatorBaseURI();
    ret += test_xmlTextReaderLocatorLineNumber();
    ret += test_xmlTextReaderLookupNamespace();
    ret += test_xmlTextReaderMoveToAttribute();
    ret += test_xmlTextReaderMoveToAttributeNo();
    ret += test_xmlTextReaderMoveToAttributeNs();
    ret += test_xmlTextReaderMoveToElement();
    ret += test_xmlTextReaderMoveToFirstAttribute();
    ret += test_xmlTextReaderMoveToNextAttribute();
    ret += test_xmlTextReaderName();
    ret += test_xmlTextReaderNamespaceUri();
    ret += test_xmlTextReaderNext();
    ret += test_xmlTextReaderNextSibling();
    ret += test_xmlTextReaderNodeType();
    ret += test_xmlTextReaderNormalization();
    ret += test_xmlTextReaderPrefix();
    ret += test_xmlTextReaderPreserve();
    ret += test_xmlTextReaderPreservePattern();
    ret += test_xmlTextReaderQuoteChar();
    ret += test_xmlTextReaderRead();
    ret += test_xmlTextReaderReadAttributeValue();
    ret += test_xmlTextReaderReadState();
    ret += test_xmlTextReaderRelaxNGSetSchema();
    ret += test_xmlTextReaderRelaxNGValidate();
    ret += test_xmlTextReaderSetErrorHandler();
    ret += test_xmlTextReaderSetParserProp();
    ret += test_xmlTextReaderSetStructuredErrorHandler();
    ret += test_xmlTextReaderStandalone();
    ret += test_xmlTextReaderValue();
    ret += test_xmlTextReaderXmlLang();

    if (ret != 0)
	printf("Module xmlreader: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlSaveCtxtPtr 1
static xmlSaveCtxtPtr gen_xmlSaveCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSaveCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSaveCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlSaveClose(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlSaveCtxtPtr ctxt; /* a document saving context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);

        ret_val = xmlSaveClose(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveClose",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveDoc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    long ret_val;
    xmlSaveCtxtPtr ctxt; /* a document saving context */
    int n_ctxt;
    xmlDocPtr doc; /* a document */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlSaveDoc(ctxt, doc);
        desret_long(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveFlush(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    xmlSaveCtxtPtr ctxt; /* a document saving context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);

        ret_val = xmlSaveFlush(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFlush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSaveSetAttrEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveSetEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveTree(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    long ret_val;
    xmlSaveCtxtPtr ctxt; /* a document saving context */
    int n_ctxt;
    xmlNodePtr node; /* a document */
    int n_node;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlSaveTree(ctxt, node);
        desret_long(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveTree",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xmlsave(void) {
    int ret = 0;

    printf("Testing xmlsave : 4 of 9 functions ...\n");
    ret += test_xmlSaveClose();
    ret += test_xmlSaveDoc();
    ret += test_xmlSaveFlush();
    ret += test_xmlSaveSetAttrEscape();
    ret += test_xmlSaveSetEscape();
    ret += test_xmlSaveToFd();
    ret += test_xmlSaveToFilename();
    ret += test_xmlSaveToIO();
    ret += test_xmlSaveTree();

    if (ret != 0)
	printf("Module xmlsave: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlSchemaPtr 1
static xmlSchemaPtr gen_xmlSchemaPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaPtr(int no ATTRIBUTE_UNUSED, xmlSchemaPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlSchemaDump(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    FILE * output; /* the file output */
    int n_output;
    xmlSchemaPtr schema; /* a schema structure */
    int n_schema;

    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    for (n_schema = 0;n_schema < gen_nb_xmlSchemaPtr;n_schema++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        schema = gen_xmlSchemaPtr(n_schema, 1);

        xmlSchemaDump(output, schema);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlSchemaPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaDump",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_output);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
#endif
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlSchemaParserCtxtPtr 1
static xmlSchemaParserCtxtPtr gen_xmlSchemaParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSchemaParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaValidityErrorFunc_ptr 1
static xmlSchemaValidityErrorFunc * gen_xmlSchemaValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlSchemaValidityErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaValidityWarningFunc_ptr 1
static xmlSchemaValidityWarningFunc * gen_xmlSchemaValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, xmlSchemaValidityWarningFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlSchemaGetParserErrors(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaParserCtxtPtr ctxt; /* a XMl-Schema parser context */
    int n_ctxt;
    xmlSchemaValidityErrorFunc * err; /* the error callback result */
    int n_err;
    xmlSchemaValidityWarningFunc * warn; /* the warning callback result */
    int n_warn;
    void ** ctx; /* contextual data for the callbacks result */
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaParserCtxtPtr;n_ctxt++) {
    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaParserCtxtPtr(n_ctxt, 0);
        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlSchemaGetParserErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetParserErrors",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlSchemaValidCtxtPtr 1
static xmlSchemaValidCtxtPtr gen_xmlSchemaValidCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSchemaValidCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlSchemaGetValidErrors(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt; /* a XML-Schema validation context */
    int n_ctxt;
    xmlSchemaValidityErrorFunc * err; /* the error function result */
    int n_err;
    xmlSchemaValidityWarningFunc * warn; /* the warning function result */
    int n_warn;
    void ** ctx; /* the functions context result */
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlSchemaGetValidErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetValidErrors",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaNewDocParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewMemParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaParse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetValidOptions(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
    int n_ctxt;
    int options; /* a combination of xmlSchemaValidOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        options = gen_int(n_options, 1);

        ret_val = xmlSchemaSetValidOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaSetValidOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidCtxtGetOptions(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);

        ret_val = xmlSchemaValidCtxtGetOptions(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidateDoc(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
    int n_ctxt;
    xmlDocPtr doc; /* a parsed document tree */
    int n_doc;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlSchemaValidateDoc(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidateOneElement(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
    int n_ctxt;
    xmlNodePtr elem; /* an element node */
    int n_elem;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        elem = gen_xmlNodePtr(n_elem, 1);

        ret_val = xmlSchemaValidateOneElement(ctxt, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateOneElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidateStream(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
    int n_ctxt;
    xmlParserInputBufferPtr input; /* the input to use for reading the data */
    int n_input;
    xmlCharEncoding enc; /* an optional encoding information */
    int n_enc;
    xmlSAXHandlerPtr sax; /* a SAX handler for the resulting events */
    int n_sax;
    void * user_data; /* the context to provide to the SAX handler. */
    int n_user_data;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        input = gen_xmlParserInputBufferPtr(n_input, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);
        sax = gen_xmlSAXHandlerPtr(n_sax, 3);
        user_data = gen_userdata(n_user_data, 4);

        ret_val = xmlSchemaValidateStream(ctxt, input, enc, sax, user_data);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlParserInputBufferPtr(n_input, input, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        des_xmlSAXHandlerPtr(n_sax, sax, 3);
        des_userdata(n_user_data, user_data, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateStream",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_input);
            printf(" %d", n_enc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xmlschemas(void) {
    int ret = 0;

    printf("Testing xmlschemas : 8 of 18 functions ...\n");
    ret += test_xmlSchemaDump();
    ret += test_xmlSchemaGetParserErrors();
    ret += test_xmlSchemaGetValidErrors();
    ret += test_xmlSchemaNewDocParserCtxt();
    ret += test_xmlSchemaNewMemParserCtxt();
    ret += test_xmlSchemaNewParserCtxt();
    ret += test_xmlSchemaNewValidCtxt();
    ret += test_xmlSchemaParse();
    ret += test_xmlSchemaSetParserErrors();
    ret += test_xmlSchemaSetValidErrors();
    ret += test_xmlSchemaSetValidOptions();
    ret += test_xmlSchemaValidCtxtGetOptions();
    ret += test_xmlSchemaValidateDoc();
    ret += test_xmlSchemaValidateOneElement();
    ret += test_xmlSchemaValidateStream();

    if (ret != 0)
	printf("Module xmlschemas: %d errors\n", ret);
    return(ret);
}

#define gen_nb_xmlSchemaFacetPtr 1
static xmlSchemaFacetPtr gen_xmlSchemaFacetPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaFacetPtr(int no ATTRIBUTE_UNUSED, xmlSchemaFacetPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlSchemaTypePtr 1
static xmlSchemaTypePtr gen_xmlSchemaTypePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaTypePtr(int no ATTRIBUTE_UNUSED, xmlSchemaTypePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlSchemaCheckFacet(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaFacetPtr facet; /* the facet */
    int n_facet;
    xmlSchemaTypePtr typeDecl; /* the schema type definition */
    int n_typeDecl;
    xmlSchemaParserCtxtPtr ctxt; /* the schema parser context or NULL */
    int n_ctxt;
    xmlChar * name; /* name of the type */
    int n_name;

    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    for (n_typeDecl = 0;n_typeDecl < gen_nb_xmlSchemaTypePtr;n_typeDecl++) {
    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaParserCtxtPtr;n_ctxt++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
        typeDecl = gen_xmlSchemaTypePtr(n_typeDecl, 1);
        ctxt = gen_xmlSchemaParserCtxtPtr(n_ctxt, 2);
        name = gen_const_xmlChar_ptr(n_name, 3);

        ret_val = xmlSchemaCheckFacet(facet, typeDecl, ctxt, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaFacetPtr(n_facet, facet, 0);
        des_xmlSchemaTypePtr(n_typeDecl, typeDecl, 1);
        des_xmlSchemaParserCtxtPtr(n_ctxt, ctxt, 2);
        des_const_xmlChar_ptr(n_name, name, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCheckFacet",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_facet);
            printf(" %d", n_typeDecl);
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaCleanupTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlSchemaCleanupTypes();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCleanupTypes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaCollapseString(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlChar * value; /* a value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlSchemaCollapseString(value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCollapseString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlSchemaValPtr 1
static xmlSchemaValPtr gen_xmlSchemaValPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaValPtr(int no ATTRIBUTE_UNUSED, xmlSchemaValPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlSchemaCompareValues(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaValPtr x; /* a first value */
    int n_x;
    xmlSchemaValPtr y; /* a second value */
    int n_y;

    for (n_x = 0;n_x < gen_nb_xmlSchemaValPtr;n_x++) {
    for (n_y = 0;n_y < gen_nb_xmlSchemaValPtr;n_y++) {
        mem_base = xmlMemBlocks();
        x = gen_xmlSchemaValPtr(n_x, 0);
        y = gen_xmlSchemaValPtr(n_y, 1);

        ret_val = xmlSchemaCompareValues(x, y);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_x, x, 0);
        des_xmlSchemaValPtr(n_y, y, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCompareValues",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_x);
            printf(" %d", n_y);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaGetBuiltInListSimpleTypeItemType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetBuiltInType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetFacetValueAsULong(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetPredefinedType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaInitTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED


        xmlSchemaInitTypes();
        call_tests++;
        xmlResetLastError();
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaIsBuiltInTypeFacet(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type; /* the built-in type */
    int n_type;
    int facetType; /* the facet type */
    int n_facetType;

    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    for (n_facetType = 0;n_facetType < gen_nb_int;n_facetType++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        facetType = gen_int(n_facetType, 1);

        ret_val = xmlSchemaIsBuiltInTypeFacet(type, facetType);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_int(n_facetType, facetType, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaIsBuiltInTypeFacet",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_facetType);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaNewFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlSchemaValPtr_ptr 1
static xmlSchemaValPtr * gen_xmlSchemaValPtr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlSchemaValPtr_ptr(int no ATTRIBUTE_UNUSED, xmlSchemaValPtr * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlSchemaValPredefTypeNode(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type; /* the predefined type */
    int n_type;
    xmlChar * value; /* the value to check */
    int n_value;
    xmlSchemaValPtr * val; /* the return computed value */
    int n_val;
    xmlNodePtr node; /* the node containing the value */
    int n_node;

    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
        node = gen_xmlNodePtr(n_node, 3);

        ret_val = xmlSchemaValPredefTypeNode(type, value, val, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        des_xmlSchemaValPtr_ptr(n_val, val, 2);
        des_xmlNodePtr(n_node, node, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValPredefTypeNodeNoNorm(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type; /* the predefined type */
    int n_type;
    xmlChar * value; /* the value to check */
    int n_value;
    xmlSchemaValPtr * val; /* the return computed value */
    int n_val;
    xmlNodePtr node; /* the node containing the value */
    int n_node;

    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
        node = gen_xmlNodePtr(n_node, 3);

        ret_val = xmlSchemaValPredefTypeNodeNoNorm(type, value, val, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        des_xmlSchemaValPtr_ptr(n_val, val, 2);
        des_xmlNodePtr(n_node, node, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNodeNoNorm",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidateFacet(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaTypePtr base; /* the base type */
    int n_base;
    xmlSchemaFacetPtr facet; /* the facet to check */
    int n_facet;
    xmlChar * value; /* the lexical repr of the value to validate */
    int n_value;
    xmlSchemaValPtr val; /* the precomputed value */
    int n_val;

    for (n_base = 0;n_base < gen_nb_xmlSchemaTypePtr;n_base++) {
    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
        mem_base = xmlMemBlocks();
        base = gen_xmlSchemaTypePtr(n_base, 0);
        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);
        val = gen_xmlSchemaValPtr(n_val, 3);

        ret_val = xmlSchemaValidateFacet(base, facet, value, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_base, base, 0);
        des_xmlSchemaFacetPtr(n_facet, facet, 1);
        des_const_xmlChar_ptr(n_value, value, 2);
        des_xmlSchemaValPtr(n_val, val, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateFacet",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_base);
            printf(" %d", n_facet);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidateLengthFacet(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type; /* the built-in type */
    int n_type;
    xmlSchemaFacetPtr facet; /* the facet to check */
    int n_facet;
    xmlChar * value; /* the lexical repr. of the value to be validated */
    int n_value;
    xmlSchemaValPtr val; /* the precomputed value */
    int n_val;
    unsigned long * length; /* the actual length of the value */
    int n_length;

    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    for (n_length = 0;n_length < gen_nb_unsigned_long_ptr;n_length++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);
        val = gen_xmlSchemaValPtr(n_val, 3);
        length = gen_unsigned_long_ptr(n_length, 4);

        ret_val = xmlSchemaValidateLengthFacet(type, facet, value, val, length);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_xmlSchemaFacetPtr(n_facet, facet, 1);
        des_const_xmlChar_ptr(n_value, value, 2);
        des_xmlSchemaValPtr(n_val, val, 3);
        des_unsigned_long_ptr(n_length, length, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacet",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_facet);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_length);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidateListSimpleTypeFacet(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaFacetPtr facet; /* the facet to check */
    int n_facet;
    xmlChar * value; /* the lexical repr of the value to validate */
    int n_value;
    unsigned long actualLen; /* the number of list items */
    int n_actualLen;
    unsigned long * expectedLen; /* the resulting expected number of list items */
    int n_expectedLen;

    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_actualLen = 0;n_actualLen < gen_nb_unsigned_long;n_actualLen++) {
    for (n_expectedLen = 0;n_expectedLen < gen_nb_unsigned_long_ptr;n_expectedLen++) {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        actualLen = gen_unsigned_long(n_actualLen, 2);
        expectedLen = gen_unsigned_long_ptr(n_expectedLen, 3);

        ret_val = xmlSchemaValidateListSimpleTypeFacet(facet, value, actualLen, expectedLen);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaFacetPtr(n_facet, facet, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        des_unsigned_long(n_actualLen, actualLen, 2);
        des_unsigned_long_ptr(n_expectedLen, expectedLen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateListSimpleTypeFacet",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_facet);
            printf(" %d", n_value);
            printf(" %d", n_actualLen);
            printf(" %d", n_expectedLen);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlSchemaValidatePredefinedType(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type; /* the predefined type */
    int n_type;
    xmlChar * value; /* the value to check */
    int n_value;
    xmlSchemaValPtr * val; /* the return computed value */
    int n_val;

    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        val = gen_xmlSchemaValPtr_ptr(n_val, 2);

        ret_val = xmlSchemaValidatePredefinedType(type, value, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, value, 1);
        des_xmlSchemaValPtr_ptr(n_val, val, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidatePredefinedType",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xmlschemastypes(void) {
    int ret = 0;

    printf("Testing xmlschemastypes : 12 of 19 functions ...\n");
    ret += test_xmlSchemaCheckFacet();
    ret += test_xmlSchemaCleanupTypes();
    ret += test_xmlSchemaCollapseString();
    ret += test_xmlSchemaCompareValues();
    ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
    ret += test_xmlSchemaGetBuiltInType();
    ret += test_xmlSchemaGetFacetValueAsULong();
    ret += test_xmlSchemaGetPredefinedType();
    ret += test_xmlSchemaInitTypes();
    ret += test_xmlSchemaIsBuiltInTypeFacet();
    ret += test_xmlSchemaNewFacet();
    ret += test_xmlSchemaValPredefTypeNode();
    ret += test_xmlSchemaValPredefTypeNodeNoNorm();
    ret += test_xmlSchemaValidateFacet();
    ret += test_xmlSchemaValidateLengthFacet();
    ret += test_xmlSchemaValidateListSimpleTypeFacet();
    ret += test_xmlSchemaValidatePredefinedType();

    if (ret != 0)
	printf("Module xmlschemastypes: %d errors\n", ret);
    return(ret);
}

static int
test_xmlCharStrdup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    char * cur; /* the input char * */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur, 0);

        ret_val = xmlCharStrdup(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrdup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCharStrndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    char * cur; /* the input char * */
    int n_cur;
    int len; /* the len of @cur */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlCharStrndup(cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, cur, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlCheckUTF8(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned char * utf; /* Pointer to putative UTF-8 encoded string. */
    int n_utf;

    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_unsigned_char_ptr(n_utf, 0);

        ret_val = xmlCheckUTF8(utf);
        desret_int(ret_val);
        call_tests++;
        des_const_unsigned_char_ptr(n_utf, utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckUTF8",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlGetUTF8Char(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    unsigned char * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;
    int * len; /* a pointer to the minimum number of bytes present in the sequence.  This is used to assure the next character is completely contained within the sequence. */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_unsigned_char_ptr(n_utf, 0);
        len = gen_int_ptr(n_len, 1);

        ret_val = xmlGetUTF8Char(utf, len);
        desret_int(ret_val);
        call_tests++;
        des_const_unsigned_char_ptr(n_utf, utf, 0);
        des_int_ptr(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetUTF8Char",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrEqual(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrEqual(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrEqual",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrPrintf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrQEqual(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * pref; /* the prefix of the QName */
    int n_pref;
    xmlChar * name; /* the localname of the QName */
    int n_name;
    xmlChar * str; /* the second xmlChar * */
    int n_str;

    for (n_pref = 0;n_pref < gen_nb_const_xmlChar_ptr;n_pref++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        pref = gen_const_xmlChar_ptr(n_pref, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        str = gen_const_xmlChar_ptr(n_str, 2);

        ret_val = xmlStrQEqual(pref, name, str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pref, pref, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_str, str, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrQEqual",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pref);
            printf(" %d", n_name);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrVPrintf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrcasecmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrcasecmp(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcasecmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrcasestr(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * str; /* the xmlChar * array (haystack) */
    int n_str;
    xmlChar * val; /* the xmlChar to search (needle) */
    int n_val;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_val = 0;n_val < gen_nb_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        val = gen_xmlChar_ptr(n_val, 1);

        ret_val = xmlStrcasestr(str, val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_xmlChar_ptr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcasestr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrchr(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrcmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrcmp(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrdup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * cur; /* the input xmlChar * */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlStrdup(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrdup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrlen(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str; /* the xmlChar * array */
    int n_str;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);

        ret_val = xmlStrlen(str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrlen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrncasecmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    xmlChar * str2; /* the second xmlChar * */
    int n_str2;
    int len; /* the max comparison length */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncasecmp(str1, str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncasecmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrncatNew(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str1; /* first xmlChar string */
    int n_str1;
    xmlChar * str2; /* second xmlChar string */
    int n_str2;
    int len; /* the len of @str2 */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncatNew(str1, str2, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncatNew",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrncmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    xmlChar * str2; /* the second xmlChar * */
    int n_str2;
    int len; /* the max comparison length */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncmp(str1, str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1, 0);
        des_const_xmlChar_ptr(n_str2, str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * cur; /* the input xmlChar * */
    int n_cur;
    int len; /* the len of @cur */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlStrndup(cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrstr(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * str; /* the xmlChar * array (haystack) */
    int n_str;
    xmlChar * val; /* the xmlChar to search (needle) */
    int n_val;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        val = gen_const_xmlChar_ptr(n_val, 1);

        ret_val = xmlStrstr(str, val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_const_xmlChar_ptr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrstr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlStrsub(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str; /* the xmlChar * array (haystack) */
    int n_str;
    int start; /* the index of the first char (zero based) */
    int n_start;
    int len; /* the length of the substring */
    int n_len;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        start = gen_int(n_start, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrsub(str, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_int(n_start, start, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrsub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Charcmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf1; /* pointer to first UTF8 char */
    int n_utf1;
    xmlChar * utf2; /* pointer to second UTF8 char */
    int n_utf2;

    for (n_utf1 = 0;n_utf1 < gen_nb_const_xmlChar_ptr;n_utf1++) {
    for (n_utf2 = 0;n_utf2 < gen_nb_const_xmlChar_ptr;n_utf2++) {
        mem_base = xmlMemBlocks();
        utf1 = gen_const_xmlChar_ptr(n_utf1, 0);
        utf2 = gen_const_xmlChar_ptr(n_utf2, 1);

        ret_val = xmlUTF8Charcmp(utf1, utf2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf1, utf1, 0);
        des_const_xmlChar_ptr(n_utf2, utf2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Charcmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf1);
            printf(" %d", n_utf2);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Size(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf; /* pointer to the UTF8 character */
    int n_utf;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);

        ret_val = xmlUTF8Size(utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Size",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strlen(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);

        ret_val = xmlUTF8Strlen(utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strlen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strloc(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    xmlChar * utfchar; /* the UTF8 character to be found */
    int n_utfchar;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_utfchar = 0;n_utfchar < gen_nb_const_xmlChar_ptr;n_utfchar++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        utfchar = gen_const_xmlChar_ptr(n_utfchar, 1);

        ret_val = xmlUTF8Strloc(utf, utfchar);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_const_xmlChar_ptr(n_utfchar, utfchar, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strloc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_utfchar);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    int len; /* the len of @utf (in chars) */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlUTF8Strndup(utf, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strpos(void) {
    int ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    int pos; /* the position of the desired UTF8 char (in chars) */
    int n_pos;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_pos = 0;n_pos < gen_nb_int;n_pos++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        pos = gen_int(n_pos, 1);

        ret_val = xmlUTF8Strpos(utf, pos);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_pos, pos, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strpos",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_pos);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strsize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;
    int len; /* the number of characters in the array */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlUTF8Strsize(utf, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    function_tests++;
    return(ret);
}


static int
test_xmlUTF8Strsub(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;
    int start; /* relative pos of first char */
    int n_start;
    int len; /* total number to copy */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        start = gen_int(n_start, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlUTF8Strsub(utf, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf, 0);
        des_int(n_start, start, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    function_tests++;
    return(ret);
}

static int
test_xmlstring(void) {
    int ret = 0;

    printf("Testing xmlstring : 25 of 30 functions ...\n");
    ret += test_xmlCharStrdup();
    ret += test_xmlCharStrndup();
    ret += test_xmlCheckUTF8();
    ret += test_xmlGetUTF8Char();
    ret += test_xmlStrEqual();
    ret += test_xmlStrPrintf();
    ret += test_xmlStrQEqual();
    ret += test_xmlStrVPrintf();
    ret += test_xmlStrcasecmp();
    ret += test_xmlStrcasestr();
    ret += test_xmlStrchr();
    ret += test_xmlStrcmp();
    ret += test_xmlStrdup();
    ret += test_xmlStrlen();
    ret += test_xmlStrncasecmp();
    ret += test_xmlStrncatNew();
    ret += test_xmlStrncmp();
    ret += test_xmlStrndup();
    ret += test_xmlStrstr();
    ret += test_xmlStrsub();
    ret += test_xmlUTF8Charcmp();
    ret += test_xmlUTF8Size();
    ret += test_xmlUTF8Strlen();
    ret += test_xmlUTF8Strloc();
    ret += test_xmlUTF8Strndup();
    ret += test_xmlUTF8Strpos();
    ret += test_xmlUTF8Strsize();
    ret += test_xmlUTF8Strsub();

    if (ret != 0)
	printf("Module xmlstring: %d errors\n", ret);
    return(ret);
}

static int
test_xmlUCSIsAegeanNumbers(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsAegeanNumbers(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsAegeanNumbers",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsAlphabeticPresentationForms(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsAlphabeticPresentationForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsAlphabeticPresentationForms",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsArabic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArabic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArabic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsArabicPresentationFormsA(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArabicPresentationFormsA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsArabicPresentationFormsB(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArabicPresentationFormsB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsB",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsArmenian(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArmenian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArmenian",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsArrows(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArrows(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArrows",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBasicLatin(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBasicLatin(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBasicLatin",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBengali(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBengali(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBengali",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBlock(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;
    char * block; /* UCS block name */
    int n_block;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    for (n_block = 0;n_block < gen_nb_const_char_ptr;n_block++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);
        block = gen_const_char_ptr(n_block, 1);

        ret_val = xmlUCSIsBlock(code, block);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        des_const_char_ptr(n_block, block, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBlock",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf(" %d", n_block);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBlockElements(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBlockElements(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBlockElements",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBopomofo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBopomofo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBopomofo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBopomofoExtended(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBopomofoExtended(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBopomofoExtended",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBoxDrawing(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBoxDrawing(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBoxDrawing",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBraillePatterns(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBraillePatterns(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBraillePatterns",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsBuhid(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBuhid(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBuhid",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsByzantineMusicalSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsByzantineMusicalSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsByzantineMusicalSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKCompatibility(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibility(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibility",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKCompatibilityForms(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibilityForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityForms",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKCompatibilityIdeographs(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibilityIdeographs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKCompatibilityIdeographsSupplement(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibilityIdeographsSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographsSupplement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKRadicalsSupplement(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKRadicalsSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKRadicalsSupplement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKSymbolsandPunctuation(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKSymbolsandPunctuation(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKSymbolsandPunctuation",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKUnifiedIdeographs(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKUnifiedIdeographs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKUnifiedIdeographsExtensionA(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCJKUnifiedIdeographsExtensionB(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionB",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCat(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;
    char * cat; /* UCS Category name */
    int n_cat;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    for (n_cat = 0;n_cat < gen_nb_const_char_ptr;n_cat++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);
        cat = gen_const_char_ptr(n_cat, 1);

        ret_val = xmlUCSIsCat(code, cat);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        des_const_char_ptr(n_cat, cat, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf(" %d", n_cat);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatC(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatC(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatC",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatCc(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatCf(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCf(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCf",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatCo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatCs(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatL(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatL(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatL",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatLl(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLl(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatLm(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLm(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLm",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatLo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatLt(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLt(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatLu(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLu(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLu",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatM(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatM(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatM",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatMc(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatMc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatMc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatMe(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatMe(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatMe",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatMn(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatMn(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatMn",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatN(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatN(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatN",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatNd(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatNd(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatNd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatNl(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatNl(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatNl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatNo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatNo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatNo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatP(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatP(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatP",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatPc(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatPd(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPd(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatPe(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPe(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPe",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatPf(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPf(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPf",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatPi(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPi(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPi",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatPo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatPs(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatS(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatS(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatSc(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatSk(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSk(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSk",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatSm(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSm(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSm",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatSo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatZ(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZ(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZ",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatZl(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZl(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZl",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatZp(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZp(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCatZs(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCherokee(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCherokee(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCherokee",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCombiningDiacriticalMarks(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningDiacriticalMarks(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCombiningDiacriticalMarksforSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningDiacriticalMarksforSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarksforSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCombiningHalfMarks(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningHalfMarks(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningHalfMarks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCombiningMarksforSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningMarksforSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningMarksforSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsControlPictures(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsControlPictures(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsControlPictures",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCurrencySymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCurrencySymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCurrencySymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCypriotSyllabary(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCypriotSyllabary(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCypriotSyllabary",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCyrillic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCyrillic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCyrillic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsCyrillicSupplement(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCyrillicSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCyrillicSupplement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsDeseret(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsDeseret(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsDeseret",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsDevanagari(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsDevanagari(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsDevanagari",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsDingbats(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsDingbats(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsDingbats",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsEnclosedAlphanumerics(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsEnclosedAlphanumerics(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsEnclosedAlphanumerics",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsEnclosedCJKLettersandMonths(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsEnclosedCJKLettersandMonths(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsEnclosedCJKLettersandMonths",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsEthiopic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsEthiopic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsEthiopic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGeneralPunctuation(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGeneralPunctuation(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGeneralPunctuation",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGeometricShapes(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGeometricShapes(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGeometricShapes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGeorgian(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGeorgian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGeorgian",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGothic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGothic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGothic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGreek(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGreek(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGreek",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGreekExtended(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGreekExtended(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGreekExtended",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGreekandCoptic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGreekandCoptic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGreekandCoptic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGujarati(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGujarati(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGujarati",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsGurmukhi(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGurmukhi(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGurmukhi",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHalfwidthandFullwidthForms(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHalfwidthandFullwidthForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHalfwidthandFullwidthForms",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHangulCompatibilityJamo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHangulCompatibilityJamo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHangulCompatibilityJamo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHangulJamo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHangulJamo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHangulJamo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHangulSyllables(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHangulSyllables(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHangulSyllables",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHanunoo(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHanunoo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHanunoo",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHebrew(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHebrew(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHebrew",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHighPrivateUseSurrogates(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHighPrivateUseSurrogates(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHighPrivateUseSurrogates",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHighSurrogates(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHighSurrogates(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHighSurrogates",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsHiragana(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHiragana(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHiragana",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsIPAExtensions(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsIPAExtensions(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsIPAExtensions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsIdeographicDescriptionCharacters(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsIdeographicDescriptionCharacters(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsIdeographicDescriptionCharacters",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsKanbun(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKanbun(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKanbun",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsKangxiRadicals(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKangxiRadicals(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKangxiRadicals",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsKannada(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKannada(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKannada",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsKatakana(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKatakana(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKatakana",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsKatakanaPhoneticExtensions(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKatakanaPhoneticExtensions(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKatakanaPhoneticExtensions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsKhmer(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKhmer(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKhmer",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsKhmerSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKhmerSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKhmerSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLao(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLao(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLao",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLatin1Supplement(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatin1Supplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatin1Supplement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLatinExtendedA(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatinExtendedA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLatinExtendedAdditional(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatinExtendedAdditional(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedAdditional",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLatinExtendedB(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatinExtendedB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedB",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLetterlikeSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLetterlikeSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLetterlikeSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLimbu(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLimbu(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLimbu",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLinearBIdeograms(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLinearBIdeograms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLinearBIdeograms",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLinearBSyllabary(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLinearBSyllabary(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLinearBSyllabary",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsLowSurrogates(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLowSurrogates(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLowSurrogates",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMalayalam(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMalayalam(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMalayalam",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMathematicalAlphanumericSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMathematicalAlphanumericSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMathematicalAlphanumericSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMathematicalOperators(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMathematicalOperators(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMathematicalOperators",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMiscellaneousMathematicalSymbolsA(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMiscellaneousMathematicalSymbolsB(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsB",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMiscellaneousSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMiscellaneousSymbolsandArrows(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousSymbolsandArrows(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbolsandArrows",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMiscellaneousTechnical(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousTechnical(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousTechnical",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMongolian(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMongolian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMongolian",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMusicalSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMusicalSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMusicalSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsMyanmar(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMyanmar(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMyanmar",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsNumberForms(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsNumberForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsNumberForms",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsOgham(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOgham(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOgham",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsOldItalic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOldItalic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOldItalic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsOpticalCharacterRecognition(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOpticalCharacterRecognition(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOpticalCharacterRecognition",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsOriya(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOriya(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOriya",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsOsmanya(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOsmanya(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOsmanya",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsPhoneticExtensions(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsPhoneticExtensions(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsPhoneticExtensions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsPrivateUse(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsPrivateUse(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsPrivateUse",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsPrivateUseArea(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsPrivateUseArea(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsPrivateUseArea",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsRunic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsRunic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsRunic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsShavian(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsShavian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsShavian",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSinhala(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSinhala(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSinhala",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSmallFormVariants(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSmallFormVariants(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSmallFormVariants",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSpacingModifierLetters(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSpacingModifierLetters(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSpacingModifierLetters",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSpecials(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSpecials(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSpecials",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSuperscriptsandSubscripts(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSuperscriptsandSubscripts(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSuperscriptsandSubscripts",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSupplementalArrowsA(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementalArrowsA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSupplementalArrowsB(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementalArrowsB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsB",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSupplementalMathematicalOperators(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementalMathematicalOperators(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementalMathematicalOperators",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSupplementaryPrivateUseAreaA(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementaryPrivateUseAreaA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSupplementaryPrivateUseAreaB(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementaryPrivateUseAreaB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaB",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsSyriac(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSyriac(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSyriac",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTagalog(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTagalog(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTagalog",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTagbanwa(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTagbanwa(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTagbanwa",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTags(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTags(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTaiLe(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTaiLe(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTaiLe",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTaiXuanJingSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTaiXuanJingSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTaiXuanJingSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTamil(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTamil(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTamil",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTelugu(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTelugu(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTelugu",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsThaana(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsThaana(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsThaana",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsThai(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsThai(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsThai",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsTibetan(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTibetan(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTibetan",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsUgaritic(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsUgaritic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsUgaritic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsUnifiedCanadianAboriginalSyllabics(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsUnifiedCanadianAboriginalSyllabics(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsUnifiedCanadianAboriginalSyllabics",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsVariationSelectors(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsVariationSelectors(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsVariationSelectors",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsVariationSelectorsSupplement(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsVariationSelectorsSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsVariationSelectorsSupplement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsYiRadicals(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsYiRadicals(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsYiRadicals",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsYiSyllables(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsYiSyllables(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsYiSyllables",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlUCSIsYijingHexagramSymbols(void) {
    int ret = 0;

#ifdef LIBXML_UNICODE_ENABLED
    int mem_base;
    int ret_val;
    int code; /* UCS code point */
    int n_code;

    for (n_code = 0;n_code < gen_nb_int;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsYijingHexagramSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsYijingHexagramSymbols",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xmlunicode(void) {
    int ret = 0;

    printf("Testing xmlunicode : 166 of 166 functions ...\n");
    ret += test_xmlUCSIsAegeanNumbers();
    ret += test_xmlUCSIsAlphabeticPresentationForms();
    ret += test_xmlUCSIsArabic();
    ret += test_xmlUCSIsArabicPresentationFormsA();
    ret += test_xmlUCSIsArabicPresentationFormsB();
    ret += test_xmlUCSIsArmenian();
    ret += test_xmlUCSIsArrows();
    ret += test_xmlUCSIsBasicLatin();
    ret += test_xmlUCSIsBengali();
    ret += test_xmlUCSIsBlock();
    ret += test_xmlUCSIsBlockElements();
    ret += test_xmlUCSIsBopomofo();
    ret += test_xmlUCSIsBopomofoExtended();
    ret += test_xmlUCSIsBoxDrawing();
    ret += test_xmlUCSIsBraillePatterns();
    ret += test_xmlUCSIsBuhid();
    ret += test_xmlUCSIsByzantineMusicalSymbols();
    ret += test_xmlUCSIsCJKCompatibility();
    ret += test_xmlUCSIsCJKCompatibilityForms();
    ret += test_xmlUCSIsCJKCompatibilityIdeographs();
    ret += test_xmlUCSIsCJKCompatibilityIdeographsSupplement();
    ret += test_xmlUCSIsCJKRadicalsSupplement();
    ret += test_xmlUCSIsCJKSymbolsandPunctuation();
    ret += test_xmlUCSIsCJKUnifiedIdeographs();
    ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionA();
    ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionB();
    ret += test_xmlUCSIsCat();
    ret += test_xmlUCSIsCatC();
    ret += test_xmlUCSIsCatCc();
    ret += test_xmlUCSIsCatCf();
    ret += test_xmlUCSIsCatCo();
    ret += test_xmlUCSIsCatCs();
    ret += test_xmlUCSIsCatL();
    ret += test_xmlUCSIsCatLl();
    ret += test_xmlUCSIsCatLm();
    ret += test_xmlUCSIsCatLo();
    ret += test_xmlUCSIsCatLt();
    ret += test_xmlUCSIsCatLu();
    ret += test_xmlUCSIsCatM();
    ret += test_xmlUCSIsCatMc();
    ret += test_xmlUCSIsCatMe();
    ret += test_xmlUCSIsCatMn();
    ret += test_xmlUCSIsCatN();
    ret += test_xmlUCSIsCatNd();
    ret += test_xmlUCSIsCatNl();
    ret += test_xmlUCSIsCatNo();
    ret += test_xmlUCSIsCatP();
    ret += test_xmlUCSIsCatPc();
    ret += test_xmlUCSIsCatPd();
    ret += test_xmlUCSIsCatPe();
    ret += test_xmlUCSIsCatPf();
    ret += test_xmlUCSIsCatPi();
    ret += test_xmlUCSIsCatPo();
    ret += test_xmlUCSIsCatPs();
    ret += test_xmlUCSIsCatS();
    ret += test_xmlUCSIsCatSc();
    ret += test_xmlUCSIsCatSk();
    ret += test_xmlUCSIsCatSm();
    ret += test_xmlUCSIsCatSo();
    ret += test_xmlUCSIsCatZ();
    ret += test_xmlUCSIsCatZl();
    ret += test_xmlUCSIsCatZp();
    ret += test_xmlUCSIsCatZs();
    ret += test_xmlUCSIsCherokee();
    ret += test_xmlUCSIsCombiningDiacriticalMarks();
    ret += test_xmlUCSIsCombiningDiacriticalMarksforSymbols();
    ret += test_xmlUCSIsCombiningHalfMarks();
    ret += test_xmlUCSIsCombiningMarksforSymbols();
    ret += test_xmlUCSIsControlPictures();
    ret += test_xmlUCSIsCurrencySymbols();
    ret += test_xmlUCSIsCypriotSyllabary();
    ret += test_xmlUCSIsCyrillic();
    ret += test_xmlUCSIsCyrillicSupplement();
    ret += test_xmlUCSIsDeseret();
    ret += test_xmlUCSIsDevanagari();
    ret += test_xmlUCSIsDingbats();
    ret += test_xmlUCSIsEnclosedAlphanumerics();
    ret += test_xmlUCSIsEnclosedCJKLettersandMonths();
    ret += test_xmlUCSIsEthiopic();
    ret += test_xmlUCSIsGeneralPunctuation();
    ret += test_xmlUCSIsGeometricShapes();
    ret += test_xmlUCSIsGeorgian();
    ret += test_xmlUCSIsGothic();
    ret += test_xmlUCSIsGreek();
    ret += test_xmlUCSIsGreekExtended();
    ret += test_xmlUCSIsGreekandCoptic();
    ret += test_xmlUCSIsGujarati();
    ret += test_xmlUCSIsGurmukhi();
    ret += test_xmlUCSIsHalfwidthandFullwidthForms();
    ret += test_xmlUCSIsHangulCompatibilityJamo();
    ret += test_xmlUCSIsHangulJamo();
    ret += test_xmlUCSIsHangulSyllables();
    ret += test_xmlUCSIsHanunoo();
    ret += test_xmlUCSIsHebrew();
    ret += test_xmlUCSIsHighPrivateUseSurrogates();
    ret += test_xmlUCSIsHighSurrogates();
    ret += test_xmlUCSIsHiragana();
    ret += test_xmlUCSIsIPAExtensions();
    ret += test_xmlUCSIsIdeographicDescriptionCharacters();
    ret += test_xmlUCSIsKanbun();
    ret += test_xmlUCSIsKangxiRadicals();
    ret += test_xmlUCSIsKannada();
    ret += test_xmlUCSIsKatakana();
    ret += test_xmlUCSIsKatakanaPhoneticExtensions();
    ret += test_xmlUCSIsKhmer();
    ret += test_xmlUCSIsKhmerSymbols();
    ret += test_xmlUCSIsLao();
    ret += test_xmlUCSIsLatin1Supplement();
    ret += test_xmlUCSIsLatinExtendedA();
    ret += test_xmlUCSIsLatinExtendedAdditional();
    ret += test_xmlUCSIsLatinExtendedB();
    ret += test_xmlUCSIsLetterlikeSymbols();
    ret += test_xmlUCSIsLimbu();
    ret += test_xmlUCSIsLinearBIdeograms();
    ret += test_xmlUCSIsLinearBSyllabary();
    ret += test_xmlUCSIsLowSurrogates();
    ret += test_xmlUCSIsMalayalam();
    ret += test_xmlUCSIsMathematicalAlphanumericSymbols();
    ret += test_xmlUCSIsMathematicalOperators();
    ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsA();
    ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsB();
    ret += test_xmlUCSIsMiscellaneousSymbols();
    ret += test_xmlUCSIsMiscellaneousSymbolsandArrows();
    ret += test_xmlUCSIsMiscellaneousTechnical();
    ret += test_xmlUCSIsMongolian();
    ret += test_xmlUCSIsMusicalSymbols();
    ret += test_xmlUCSIsMyanmar();
    ret += test_xmlUCSIsNumberForms();
    ret += test_xmlUCSIsOgham();
    ret += test_xmlUCSIsOldItalic();
    ret += test_xmlUCSIsOpticalCharacterRecognition();
    ret += test_xmlUCSIsOriya();
    ret += test_xmlUCSIsOsmanya();
    ret += test_xmlUCSIsPhoneticExtensions();
    ret += test_xmlUCSIsPrivateUse();
    ret += test_xmlUCSIsPrivateUseArea();
    ret += test_xmlUCSIsRunic();
    ret += test_xmlUCSIsShavian();
    ret += test_xmlUCSIsSinhala();
    ret += test_xmlUCSIsSmallFormVariants();
    ret += test_xmlUCSIsSpacingModifierLetters();
    ret += test_xmlUCSIsSpecials();
    ret += test_xmlUCSIsSuperscriptsandSubscripts();
    ret += test_xmlUCSIsSupplementalArrowsA();
    ret += test_xmlUCSIsSupplementalArrowsB();
    ret += test_xmlUCSIsSupplementalMathematicalOperators();
    ret += test_xmlUCSIsSupplementaryPrivateUseAreaA();
    ret += test_xmlUCSIsSupplementaryPrivateUseAreaB();
    ret += test_xmlUCSIsSyriac();
    ret += test_xmlUCSIsTagalog();
    ret += test_xmlUCSIsTagbanwa();
    ret += test_xmlUCSIsTags();
    ret += test_xmlUCSIsTaiLe();
    ret += test_xmlUCSIsTaiXuanJingSymbols();
    ret += test_xmlUCSIsTamil();
    ret += test_xmlUCSIsTelugu();
    ret += test_xmlUCSIsThaana();
    ret += test_xmlUCSIsThai();
    ret += test_xmlUCSIsTibetan();
    ret += test_xmlUCSIsUgaritic();
    ret += test_xmlUCSIsUnifiedCanadianAboriginalSyllabics();
    ret += test_xmlUCSIsVariationSelectors();
    ret += test_xmlUCSIsVariationSelectorsSupplement();
    ret += test_xmlUCSIsYiRadicals();
    ret += test_xmlUCSIsYiSyllables();
    ret += test_xmlUCSIsYijingHexagramSymbols();

    if (ret != 0)
	printf("Module xmlunicode: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNewTextWriter(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlOutputBufferPtr out; /* an xmlOutputBufferPtr */
    int n_out;

    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);

        ret_val = xmlNewTextWriter(out);
        if (ret_val != NULL) out = NULL;
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriter",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextWriterFilename(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    xmlTextWriterPtr ret_val;
    const char * uri; /* the URI of the resource for the output */
    int n_uri;
    int compression; /* compress the output? */
    int n_compression;

    for (n_uri = 0;n_uri < gen_nb_filepath;n_uri++) {
    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
        mem_base = xmlMemBlocks();
        uri = gen_filepath(n_uri, 0);
        compression = gen_int(n_compression, 1);

        ret_val = xmlNewTextWriterFilename(uri, compression);
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_filepath(n_uri, uri, 0);
        des_int(n_compression, compression, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_uri);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextWriterMemory(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlBufferPtr buf; /* xmlBufferPtr */
    int n_buf;
    int compression; /* compress the output? */
    int n_compression;

    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        compression = gen_int(n_compression, 1);

        ret_val = xmlNewTextWriterMemory(buf, compression);
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_int(n_compression, compression, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buf);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextWriterPushParser(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlParserCtxtPtr ctxt; /* xmlParserCtxtPtr to hold the new XML document tree */
    int n_ctxt;
    int compression; /* compress the output? */
    int n_compression;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        compression = gen_int(n_compression, 1);

        ret_val = xmlNewTextWriterPushParser(ctxt, compression);
        if (ret_val != NULL) ctxt = NULL;
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_compression, compression, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterPushParser",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlNewTextWriterTree(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlDocPtr doc; /* xmlDocPtr */
    int n_doc;
    xmlNodePtr node; /* xmlNodePtr or NULL for doc->children */
    int n_node;
    int compression; /* compress the output? */
    int n_compression;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_xmlNodePtr(n_node, 1);
        compression = gen_int(n_compression, 2);

        ret_val = xmlNewTextWriterTree(doc, node, compression);
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_int(n_compression, compression, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterTree",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndAttribute(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndAttribute(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndCDATA(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndCDATA(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndCDATA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndComment(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndComment(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTD(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTD(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTDAttlist(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDAttlist(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDAttlist",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTDElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDTDEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDEntity(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndDocument(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDocument(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterEndPI(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndPI(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterFlush(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterFlush(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterFlush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterFullEndElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterFullEndElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterFullEndElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterSetIndent(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int indent; /* do indentation? */
    int n_indent;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_indent = 0;n_indent < gen_nb_int;n_indent++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        indent = gen_int(n_indent, 1);

        ret_val = xmlTextWriterSetIndent(writer, indent);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_indent, indent, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterSetIndent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_indent);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterSetIndentString(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * str; /* the xmlChar string */
    int n_str;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlTextWriterSetIndentString(writer, str);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_str, str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterSetIndentString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartAttribute(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* element name */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartAttribute(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartAttributeNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * prefix; /* namespace prefix or NULL */
    int n_prefix;
    xmlChar * name; /* element local name */
    int n_name;
    xmlChar * namespaceURI; /* namespace URI or NULL */
    int n_namespaceURI;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);

        ret_val = xmlTextWriterStartAttributeNS(writer, prefix, name, namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartAttributeNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartCDATA(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterStartCDATA(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartCDATA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartComment(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterStartComment(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTD(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* the name of the DTD */
    int n_name;
    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);

        ret_val = xmlTextWriterStartDTD(writer, name, pubid, sysid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_pubid, pubid, 2);
        des_const_xmlChar_ptr(n_sysid, sysid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTDAttlist(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* the name of the DTD ATTLIST */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartDTDAttlist(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDAttlist",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTDElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* the name of the DTD element */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartDTDElement(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDTDEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    xmlChar * name; /* the name of the DTD ATTLIST */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlTextWriterStartDTDEntity(writer, pe, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartDocument(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    char * version; /* the xml version ("1.0") or NULL for default ("1.0") */
    int n_version;
    char * encoding; /* the encoding or NULL for default */
    int n_encoding;
    char * standalone; /* "yes" or "no" or NULL for default */
    int n_standalone;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_version = 0;n_version < gen_nb_const_char_ptr;n_version++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_standalone = 0;n_standalone < gen_nb_const_char_ptr;n_standalone++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        version = gen_const_char_ptr(n_version, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        standalone = gen_const_char_ptr(n_standalone, 3);

        ret_val = xmlTextWriterStartDocument(writer, version, encoding, standalone);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_version, version, 1);
        des_const_char_ptr(n_encoding, encoding, 2);
        des_const_char_ptr(n_standalone, standalone, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_version);
            printf(" %d", n_encoding);
            printf(" %d", n_standalone);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* element name */
    int n_name;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartElement(writer, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartElementNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * prefix; /* namespace prefix or NULL */
    int n_prefix;
    xmlChar * name; /* element local name */
    int n_name;
    xmlChar * namespaceURI; /* namespace URI or NULL */
    int n_namespaceURI;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);

        ret_val = xmlTextWriterStartElementNS(writer, prefix, name, namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartElementNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterStartPI(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * target; /* PI target */
    int n_target;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_target = 0;n_target < gen_nb_const_xmlChar_ptr;n_target++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        target = gen_const_xmlChar_ptr(n_target, 1);

        ret_val = xmlTextWriterStartPI(writer, target);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_target, target, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_target);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteAttribute(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* attribute name */
    int n_name;
    xmlChar * content; /* attribute content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteAttribute(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteAttributeNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * prefix; /* namespace prefix */
    int n_prefix;
    xmlChar * name; /* attribute local name */
    int n_name;
    xmlChar * namespaceURI; /* namespace URI */
    int n_namespaceURI;
    xmlChar * content; /* attribute content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        content = gen_const_xmlChar_ptr(n_content, 4);

        ret_val = xmlTextWriterWriteAttributeNS(writer, prefix, name, namespaceURI, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        des_const_xmlChar_ptr(n_content, content, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteAttributeNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteBase64(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    char * data; /* binary data */
    int n_data;
    int start; /* the position within the data of the first byte to encode */
    int n_start;
    int len; /* the number of bytes to encode */
    int n_len;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        data = gen_const_char_ptr(n_data, 1);
        start = gen_int(n_start, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlTextWriterWriteBase64(writer, data, start, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_data, data, 1);
        des_int(n_start, start, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteBase64",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_data);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteBinHex(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    char * data; /* binary data */
    int n_data;
    int start; /* the position within the data of the first byte to encode */
    int n_start;
    int len; /* the number of bytes to encode */
    int n_len;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        data = gen_const_char_ptr(n_data, 1);
        start = gen_int(n_start, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlTextWriterWriteBinHex(writer, data, start, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_data, data, 1);
        des_int(n_start, start, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteBinHex",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_data);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteCDATA(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * content; /* CDATA content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteCDATA(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteCDATA",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteComment(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * content; /* comment string */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteComment(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTD(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* the name of the DTD */
    int n_name;
    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    xmlChar * subset; /* string content of the DTD */
    int n_subset;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_subset = 0;n_subset < gen_nb_const_xmlChar_ptr;n_subset++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);
        subset = gen_const_xmlChar_ptr(n_subset, 4);

        ret_val = xmlTextWriterWriteDTD(writer, name, pubid, sysid, subset);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_pubid, pubid, 2);
        des_const_xmlChar_ptr(n_sysid, sysid, 3);
        des_const_xmlChar_ptr(n_subset, subset, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_subset);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDAttlist(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* the name of the DTD ATTLIST */
    int n_name;
    xmlChar * content; /* content of the ATTLIST */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteDTDAttlist(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDAttlist",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* the name of the DTD element */
    int n_name;
    xmlChar * content; /* content of the element */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteDTDElement(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    xmlChar * name; /* the name of the DTD entity */
    int n_name;
    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    xmlChar * ndataid; /* the xml notation name. */
    int n_ndataid;
    xmlChar * content; /* content of the entity */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);
        content = gen_const_xmlChar_ptr(n_content, 6);

        ret_val = xmlTextWriterWriteDTDEntity(writer, pe, name, pubid, sysid, ndataid, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_pubid, pubid, 3);
        des_const_xmlChar_ptr(n_sysid, sysid, 4);
        des_const_xmlChar_ptr(n_ndataid, ndataid, 5);
        des_const_xmlChar_ptr(n_content, content, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    xmlChar * name; /* the name of the DTD entity */
    int n_name;
    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    xmlChar * ndataid; /* the xml notation name. */
    int n_ndataid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);

        ret_val = xmlTextWriterWriteDTDExternalEntity(writer, pe, name, pubid, sysid, ndataid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_pubid, pubid, 3);
        des_const_xmlChar_ptr(n_sysid, sysid, 4);
        des_const_xmlChar_ptr(n_ndataid, ndataid, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntityContents(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;
    xmlChar * ndataid; /* the xml notation name. */
    int n_ndataid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pubid = gen_const_xmlChar_ptr(n_pubid, 1);
        sysid = gen_const_xmlChar_ptr(n_sysid, 2);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 3);

        ret_val = xmlTextWriterWriteDTDExternalEntityContents(writer, pubid, sysid, ndataid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_pubid, pubid, 1);
        des_const_xmlChar_ptr(n_sysid, sysid, 2);
        des_const_xmlChar_ptr(n_ndataid, ndataid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntityContents",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDInternalEntity(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    int pe; /* TRUE if this is a parameter entity, FALSE if not */
    int n_pe;
    xmlChar * name; /* the name of the DTD entity */
    int n_name;
    xmlChar * content; /* content of the entity */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlTextWriterWriteDTDInternalEntity(writer, pe, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDInternalEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteDTDNotation(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* the name of the xml notation */
    int n_name;
    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
    int n_pubid;
    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
    int n_sysid;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);

        ret_val = xmlTextWriterWriteDTDNotation(writer, name, pubid, sysid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_pubid, pubid, 2);
        des_const_xmlChar_ptr(n_sysid, sysid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDNotation",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteElement(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * name; /* element name */
    int n_name;
    xmlChar * content; /* element content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteElement(writer, name, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, name, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteElementNS(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * prefix; /* namespace prefix */
    int n_prefix;
    xmlChar * name; /* element local name */
    int n_name;
    xmlChar * namespaceURI; /* namespace URI */
    int n_namespaceURI;
    xmlChar * content; /* element content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        content = gen_const_xmlChar_ptr(n_content, 4);

        ret_val = xmlTextWriterWriteElementNS(writer, prefix, name, namespaceURI, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, prefix, 1);
        des_const_xmlChar_ptr(n_name, name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, namespaceURI, 3);
        des_const_xmlChar_ptr(n_content, content, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteElementNS",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteFormatAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDInternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatRaw(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWritePI(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * target; /* PI target */
    int n_target;
    xmlChar * content; /* PI content */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_target = 0;n_target < gen_nb_const_xmlChar_ptr;n_target++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        target = gen_const_xmlChar_ptr(n_target, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWritePI(writer, target, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_target, target, 1);
        des_const_xmlChar_ptr(n_content, content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWritePI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_target);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteRaw(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * content; /* text string */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteRaw(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteRaw",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteRawLen(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * content; /* text string */
    int n_content;
    int len; /* length of the text string */
    int n_len;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlTextWriterWriteRawLen(writer, content, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteRawLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteString(void) {
    int ret = 0;

#ifdef LIBXML_WRITER_ENABLED
    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
    int n_writer;
    xmlChar * content; /* text string */
    int n_content;

    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteString(writer, content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDInternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatRaw(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlwriter(void) {
    int ret = 0;

    printf("Testing xmlwriter : 51 of 79 functions ...\n");
    ret += test_xmlNewTextWriter();
    ret += test_xmlNewTextWriterFilename();
    ret += test_xmlNewTextWriterMemory();
    ret += test_xmlNewTextWriterPushParser();
    ret += test_xmlNewTextWriterTree();
    ret += test_xmlTextWriterEndAttribute();
    ret += test_xmlTextWriterEndCDATA();
    ret += test_xmlTextWriterEndComment();
    ret += test_xmlTextWriterEndDTD();
    ret += test_xmlTextWriterEndDTDAttlist();
    ret += test_xmlTextWriterEndDTDElement();
    ret += test_xmlTextWriterEndDTDEntity();
    ret += test_xmlTextWriterEndDocument();
    ret += test_xmlTextWriterEndElement();
    ret += test_xmlTextWriterEndPI();
    ret += test_xmlTextWriterFlush();
    ret += test_xmlTextWriterFullEndElement();
    ret += test_xmlTextWriterSetIndent();
    ret += test_xmlTextWriterSetIndentString();
    ret += test_xmlTextWriterStartAttribute();
    ret += test_xmlTextWriterStartAttributeNS();
    ret += test_xmlTextWriterStartCDATA();
    ret += test_xmlTextWriterStartComment();
    ret += test_xmlTextWriterStartDTD();
    ret += test_xmlTextWriterStartDTDAttlist();
    ret += test_xmlTextWriterStartDTDElement();
    ret += test_xmlTextWriterStartDTDEntity();
    ret += test_xmlTextWriterStartDocument();
    ret += test_xmlTextWriterStartElement();
    ret += test_xmlTextWriterStartElementNS();
    ret += test_xmlTextWriterStartPI();
    ret += test_xmlTextWriterWriteAttribute();
    ret += test_xmlTextWriterWriteAttributeNS();
    ret += test_xmlTextWriterWriteBase64();
    ret += test_xmlTextWriterWriteBinHex();
    ret += test_xmlTextWriterWriteCDATA();
    ret += test_xmlTextWriterWriteComment();
    ret += test_xmlTextWriterWriteDTD();
    ret += test_xmlTextWriterWriteDTDAttlist();
    ret += test_xmlTextWriterWriteDTDElement();
    ret += test_xmlTextWriterWriteDTDEntity();
    ret += test_xmlTextWriterWriteDTDExternalEntity();
    ret += test_xmlTextWriterWriteDTDExternalEntityContents();
    ret += test_xmlTextWriterWriteDTDInternalEntity();
    ret += test_xmlTextWriterWriteDTDNotation();
    ret += test_xmlTextWriterWriteElement();
    ret += test_xmlTextWriterWriteElementNS();
    ret += test_xmlTextWriterWriteFormatAttribute();
    ret += test_xmlTextWriterWriteFormatAttributeNS();
    ret += test_xmlTextWriterWriteFormatCDATA();
    ret += test_xmlTextWriterWriteFormatComment();
    ret += test_xmlTextWriterWriteFormatDTD();
    ret += test_xmlTextWriterWriteFormatDTDAttlist();
    ret += test_xmlTextWriterWriteFormatDTDElement();
    ret += test_xmlTextWriterWriteFormatDTDInternalEntity();
    ret += test_xmlTextWriterWriteFormatElement();
    ret += test_xmlTextWriterWriteFormatElementNS();
    ret += test_xmlTextWriterWriteFormatPI();
    ret += test_xmlTextWriterWriteFormatRaw();
    ret += test_xmlTextWriterWriteFormatString();
    ret += test_xmlTextWriterWritePI();
    ret += test_xmlTextWriterWriteRaw();
    ret += test_xmlTextWriterWriteRawLen();
    ret += test_xmlTextWriterWriteString();
    ret += test_xmlTextWriterWriteVFormatAttribute();
    ret += test_xmlTextWriterWriteVFormatAttributeNS();
    ret += test_xmlTextWriterWriteVFormatCDATA();
    ret += test_xmlTextWriterWriteVFormatComment();
    ret += test_xmlTextWriterWriteVFormatDTD();
    ret += test_xmlTextWriterWriteVFormatDTDAttlist();
    ret += test_xmlTextWriterWriteVFormatDTDElement();
    ret += test_xmlTextWriterWriteVFormatDTDInternalEntity();
    ret += test_xmlTextWriterWriteVFormatElement();
    ret += test_xmlTextWriterWriteVFormatElementNS();
    ret += test_xmlTextWriterWriteVFormatPI();
    ret += test_xmlTextWriterWriteVFormatRaw();
    ret += test_xmlTextWriterWriteVFormatString();

    if (ret != 0)
	printf("Module xmlwriter: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXPathCastBooleanToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    int val; /* a boolean */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlXPathCastBooleanToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastBooleanToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastBooleanToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    int val; /* a boolean */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlXPathCastBooleanToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastBooleanToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlNodeSetPtr 1
static xmlNodeSetPtr gen_xmlNodeSetPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlNodeSetPtr(int no ATTRIBUTE_UNUSED, xmlNodeSetPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlXPathCastNodeSetToBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlNodeSetPtr ns; /* a node-set */
    int n_ns;

    for (n_ns = 0;n_ns < gen_nb_xmlNodeSetPtr;n_ns++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0);

        ret_val = xmlXPathCastNodeSetToBoolean(ns);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_ns, ns, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeSetToBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ns);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNodeSetToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    xmlNodeSetPtr ns; /* a node-set */
    int n_ns;

    for (n_ns = 0;n_ns < gen_nb_xmlNodeSetPtr;n_ns++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0);

        ret_val = xmlXPathCastNodeSetToNumber(ns);
        desret_double(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_ns, ns, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeSetToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ns);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNodeSetToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlNodeSetPtr ns; /* a node-set */
    int n_ns;

    for (n_ns = 0;n_ns < gen_nb_xmlNodeSetPtr;n_ns++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0);

        ret_val = xmlXPathCastNodeSetToString(ns);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_ns, ns, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeSetToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ns);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNodeToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlXPathCastNodeToNumber(node);
        desret_double(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNodeToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlXPathCastNodeToString(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNumberToBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    double val; /* a number */
    int n_val;

    for (n_val = 0;n_val < gen_nb_double;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathCastNumberToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNumberToBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastNumberToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    double val; /* a number */
    int n_val;

    for (n_val = 0;n_val < gen_nb_double;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathCastNumberToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNumberToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastStringToBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlChar * val; /* a string */
    int n_val;

    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0);

        ret_val = xmlXPathCastStringToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastStringToBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastStringToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    xmlChar * val; /* a string */
    int n_val;

    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0);

        ret_val = xmlXPathCastStringToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastStringToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastToBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastToNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    double ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCastToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCmpNodes(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr node1; /* the first node */
    int n_node1;
    xmlNodePtr node2; /* the second node */
    int n_node2;

    for (n_node1 = 0;n_node1 < gen_nb_xmlNodePtr;n_node1++) {
    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
        mem_base = xmlMemBlocks();
        node1 = gen_xmlNodePtr(n_node1, 0);
        node2 = gen_xmlNodePtr(n_node2, 1);

        ret_val = xmlXPathCmpNodes(node1, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node1, node1, 0);
        des_xmlNodePtr(n_node2, node2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCmpNodes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node1);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


#define gen_nb_xmlXPathCompExprPtr 1
static xmlXPathCompExprPtr gen_xmlXPathCompExprPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlXPathCompExprPtr(int no ATTRIBUTE_UNUSED, xmlXPathCompExprPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlXPathContextPtr 1
static xmlXPathContextPtr gen_xmlXPathContextPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlXPathContextPtr(int no ATTRIBUTE_UNUSED, xmlXPathContextPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlXPathCompiledEval(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathCompExprPtr comp; /* the compiled XPath expression */
    int n_comp;
    xmlXPathContextPtr ctx; /* the XPath context */
    int n_ctx;

    for (n_comp = 0;n_comp < gen_nb_xmlXPathCompExprPtr;n_comp++) {
    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlXPathCompExprPtr(n_comp, 0);
        ctx = gen_xmlXPathContextPtr(n_ctx, 1);

        ret_val = xmlXPathCompiledEval(comp, ctx);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathCompExprPtr(n_comp, comp, 0);
        des_xmlXPathContextPtr(n_ctx, ctx, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCompiledEval",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_comp);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathConvertBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertBoolean(val);
        val = NULL;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathConvertNumber(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertNumber(val);
        val = NULL;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertNumber",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathConvertString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* an XPath object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertString(val);
        val = NULL;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathCtxtCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathEval(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlChar * str; /* the XPath expression */
    int n_str;
    xmlXPathContextPtr ctx; /* the XPath context */
    int n_ctx;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        ctx = gen_xmlXPathContextPtr(n_ctx, 1);

        ret_val = xmlXPathEval(str, ctx);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_xmlXPathContextPtr(n_ctx, ctx, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEval",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathEvalExpression(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlChar * str; /* the XPath expression */
    int n_str;
    xmlXPathContextPtr ctxt; /* the XPath context */
    int n_ctxt;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 1);

        ret_val = xmlXPathEvalExpression(str, ctxt);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_xmlXPathContextPtr(n_ctxt, ctxt, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEvalExpression",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathEvalPredicate(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlXPathContextPtr ctxt; /* the XPath context */
    int n_ctxt;
    xmlXPathObjectPtr res; /* the Predicate Expression evaluation result */
    int n_res;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    for (n_res = 0;n_res < gen_nb_xmlXPathObjectPtr;n_res++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        res = gen_xmlXPathObjectPtr(n_res, 1);

        ret_val = xmlXPathEvalPredicate(ctxt, res);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_xmlXPathObjectPtr(n_res, res, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEvalPredicate",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_res);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathInit(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlXPathInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathIsInf(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    double val; /* a double value */
    int n_val;

    for (n_val = 0;n_val < gen_nb_double;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathIsInf(val);
        desret_int(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathIsInf",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathIsNaN(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    double val; /* a double value */
    int n_val;

    for (n_val = 0;n_val < gen_nb_double;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathIsNaN(val);
        desret_int(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathIsNaN",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathNodeSetCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathObjectCopy(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val; /* the original object */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathObjectCopy(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathObjectCopy",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPathOrderDocElems(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    long ret_val;
    xmlDocPtr doc; /* an input document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlXPathOrderDocElems(doc);
        desret_long(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathOrderDocElems",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xpath(void) {
    int ret = 0;

    printf("Testing xpath : 27 of 36 functions ...\n");
    ret += test_xmlXPathCastBooleanToNumber();
    ret += test_xmlXPathCastBooleanToString();
    ret += test_xmlXPathCastNodeSetToBoolean();
    ret += test_xmlXPathCastNodeSetToNumber();
    ret += test_xmlXPathCastNodeSetToString();
    ret += test_xmlXPathCastNodeToNumber();
    ret += test_xmlXPathCastNodeToString();
    ret += test_xmlXPathCastNumberToBoolean();
    ret += test_xmlXPathCastNumberToString();
    ret += test_xmlXPathCastStringToBoolean();
    ret += test_xmlXPathCastStringToNumber();
    ret += test_xmlXPathCastToBoolean();
    ret += test_xmlXPathCastToNumber();
    ret += test_xmlXPathCastToString();
    ret += test_xmlXPathCmpNodes();
    ret += test_xmlXPathCompile();
    ret += test_xmlXPathCompiledEval();
    ret += test_xmlXPathConvertBoolean();
    ret += test_xmlXPathConvertNumber();
    ret += test_xmlXPathConvertString();
    ret += test_xmlXPathCtxtCompile();
    ret += test_xmlXPathEval();
    ret += test_xmlXPathEvalExpression();
    ret += test_xmlXPathEvalPredicate();
    ret += test_xmlXPathInit();
    ret += test_xmlXPathIsInf();
    ret += test_xmlXPathIsNaN();
    ret += test_xmlXPathNewContext();
    ret += test_xmlXPathNodeSetCreate();
    ret += test_xmlXPathObjectCopy();
    ret += test_xmlXPathOrderDocElems();

    if (ret != 0)
	printf("Module xpath: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXPtrBuildNodeList(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathObjectPtr obj; /* the XPointer result from the evaluation. */
    int n_obj;

    for (n_obj = 0;n_obj < gen_nb_xmlXPathObjectPtr;n_obj++) {
        mem_base = xmlMemBlocks();
        obj = gen_xmlXPathObjectPtr(n_obj, 0);

        ret_val = xmlXPtrBuildNodeList(obj);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_obj, obj, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrBuildNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_obj);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrEval(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlChar * str; /* the XPointer expression */
    int n_str;
    xmlXPathContextPtr ctx; /* the XPointer context */
    int n_ctx;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        ctx = gen_xmlXPathContextPtr(n_ctx, 1);

        ret_val = xmlXPtrEval(str, ctx);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str, 0);
        des_xmlXPathContextPtr(n_ctx, ctx, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrEval",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlXPathParserContextPtr 1
static xmlXPathParserContextPtr gen_xmlXPathParserContextPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlXPathParserContextPtr(int no ATTRIBUTE_UNUSED, xmlXPathParserContextPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlXPtrEvalRangePredicate(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathParserContextPtr ctxt; /* the XPointer Parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPtrEvalRangePredicate(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrEvalRangePredicate",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


#define gen_nb_xmlLocationSetPtr 1
static xmlLocationSetPtr gen_xmlLocationSetPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    return(NULL);
}
static void des_xmlLocationSetPtr(int no ATTRIBUTE_UNUSED, xmlLocationSetPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
}

static int
test_xmlXPtrLocationSetAdd(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlLocationSetPtr cur; /* the initial range set */
    int n_cur;
    xmlXPathObjectPtr val; /* a new xmlXPathObjectPtr */
    int n_val;

    for (n_cur = 0;n_cur < gen_nb_xmlLocationSetPtr;n_cur++) {
    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlLocationSetPtr(n_cur, 0);
        val = gen_xmlXPathObjectPtr(n_val, 1);

        xmlXPtrLocationSetAdd(cur, val);
        call_tests++;
        des_xmlLocationSetPtr(n_cur, cur, 0);
        des_xmlXPathObjectPtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrLocationSetAdd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrLocationSetCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetDel(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlLocationSetPtr cur; /* the initial range set */
    int n_cur;
    xmlXPathObjectPtr val; /* an xmlXPathObjectPtr */
    int n_val;

    for (n_cur = 0;n_cur < gen_nb_xmlLocationSetPtr;n_cur++) {
    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlLocationSetPtr(n_cur, 0);
        val = gen_xmlXPathObjectPtr(n_val, 1);

        xmlXPtrLocationSetDel(cur, val);
        call_tests++;
        des_xmlLocationSetPtr(n_cur, cur, 0);
        des_xmlXPathObjectPtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrLocationSetDel",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrLocationSetMerge(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetRemove(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlLocationSetPtr cur; /* the initial range set */
    int n_cur;
    int val; /* the index to remove */
    int n_val;

    for (n_cur = 0;n_cur < gen_nb_xmlLocationSetPtr;n_cur++) {
    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlLocationSetPtr(n_cur, 0);
        val = gen_int(n_val, 1);

        xmlXPtrLocationSetRemove(cur, val);
        call_tests++;
        des_xmlLocationSetPtr(n_cur, cur, 0);
        des_int(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrLocationSetRemove",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewCollapsedRange(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting and ending node */
    int n_start;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);

        ret_val = xmlXPtrNewCollapsedRange(start);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewCollapsedRange",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewLocationSetNodeSet(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodeSetPtr set; /* a node set */
    int n_set;

    for (n_set = 0;n_set < gen_nb_xmlNodeSetPtr;n_set++) {
        mem_base = xmlMemBlocks();
        set = gen_xmlNodeSetPtr(n_set, 0);

        ret_val = xmlXPtrNewLocationSetNodeSet(set);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_set, set, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewLocationSetNodeSet",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_set);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewLocationSetNodes(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the start NodePtr value */
    int n_start;
    xmlNodePtr end; /* the end NodePtr value or NULL */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewLocationSetNodes(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewLocationSetNodes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRange(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    int startindex; /* the start index */
    int n_startindex;
    xmlNodePtr end; /* the ending point */
    int n_end;
    int endindex; /* the ending index */
    int n_endindex;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_startindex = 0;n_startindex < gen_nb_int;n_startindex++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
    for (n_endindex = 0;n_endindex < gen_nb_int;n_endindex++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        startindex = gen_int(n_startindex, 1);
        end = gen_xmlNodePtr(n_end, 2);
        endindex = gen_int(n_endindex, 3);

        ret_val = xmlXPtrNewRange(start, startindex, end, endindex);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_int(n_startindex, startindex, 1);
        des_xmlNodePtr(n_end, end, 2);
        des_int(n_endindex, endindex, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRange",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_startindex);
            printf(" %d", n_end);
            printf(" %d", n_endindex);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangeNodeObject(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    xmlXPathObjectPtr end; /* the ending object */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodeObject(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodeObject",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangeNodePoint(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    xmlXPathObjectPtr end; /* the ending point */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodePoint(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodePoint",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangeNodes(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start; /* the starting node */
    int n_start;
    xmlNodePtr end; /* the ending node */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodes(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangePointNode(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr start; /* the starting point */
    int n_start;
    xmlNodePtr end; /* the ending node */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlXPathObjectPtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlXPathObjectPtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewRangePointNode(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangePointNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrNewRangePoints(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr start; /* the starting point */
    int n_start;
    xmlXPathObjectPtr end; /* the ending point */
    int n_end;

    for (n_start = 0;n_start < gen_nb_xmlXPathObjectPtr;n_start++) {
    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlXPathObjectPtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangePoints(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangePoints",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrRangeToFunction(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathParserContextPtr ctxt; /* the XPointer Parser context */
    int n_ctxt;
    int nargs; /* the number of args */
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPtrRangeToFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrRangeToFunction",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
#endif

    function_tests++;
    return(ret);
}


static int
test_xmlXPtrWrapLocationSet(void) {
    int ret = 0;

#ifdef LIBXML_XPTR_ENABLED
    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlLocationSetPtr val; /* the LocationSet value */
    int n_val;

    for (n_val = 0;n_val < gen_nb_xmlLocationSetPtr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlLocationSetPtr(n_val, 0);

        ret_val = xmlXPtrWrapLocationSet(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlLocationSetPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrWrapLocationSet",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    function_tests++;
    return(ret);
}

static int
test_xpointer(void) {
    int ret = 0;

    printf("Testing xpointer : 17 of 21 functions ...\n");
    ret += test_xmlXPtrBuildNodeList();
    ret += test_xmlXPtrEval();
    ret += test_xmlXPtrEvalRangePredicate();
    ret += test_xmlXPtrLocationSetAdd();
    ret += test_xmlXPtrLocationSetCreate();
    ret += test_xmlXPtrLocationSetDel();
    ret += test_xmlXPtrLocationSetMerge();
    ret += test_xmlXPtrLocationSetRemove();
    ret += test_xmlXPtrNewCollapsedRange();
    ret += test_xmlXPtrNewContext();
    ret += test_xmlXPtrNewLocationSetNodeSet();
    ret += test_xmlXPtrNewLocationSetNodes();
    ret += test_xmlXPtrNewRange();
    ret += test_xmlXPtrNewRangeNodeObject();
    ret += test_xmlXPtrNewRangeNodePoint();
    ret += test_xmlXPtrNewRangeNodes();
    ret += test_xmlXPtrNewRangePointNode();
    ret += test_xmlXPtrNewRangePoints();
    ret += test_xmlXPtrRangeToFunction();
    ret += test_xmlXPtrWrapLocationSet();

    if (ret != 0)
	printf("Module xpointer: %d errors\n", ret);
    return(ret);
}
static int
test_module(const char *module) {
    if (!strcmp(module, "HTMLparser")) return(test_HTMLparser());
    if (!strcmp(module, "HTMLtree")) return(test_HTMLtree());
    if (!strcmp(module, "catalog")) return(test_catalog());
    if (!strcmp(module, "chvalid")) return(test_chvalid());
    if (!strcmp(module, "dict")) return(test_dict());
    if (!strcmp(module, "encoding")) return(test_encoding());
    if (!strcmp(module, "entities")) return(test_entities());
    if (!strcmp(module, "hash")) return(test_hash());
    if (!strcmp(module, "list")) return(test_list());
    if (!strcmp(module, "nanoftp")) return(test_nanoftp());
    if (!strcmp(module, "nanohttp")) return(test_nanohttp());
    if (!strcmp(module, "parser")) return(test_parser());
    if (!strcmp(module, "pattern")) return(test_pattern());
    if (!strcmp(module, "relaxng")) return(test_relaxng());
    if (!strcmp(module, "schemasInternals")) return(test_schemasInternals());
    if (!strcmp(module, "tree")) return(test_tree());
    if (!strcmp(module, "uri")) return(test_uri());
    if (!strcmp(module, "valid")) return(test_valid());
    if (!strcmp(module, "xinclude")) return(test_xinclude());
    if (!strcmp(module, "xmlIO")) return(test_xmlIO());
    if (!strcmp(module, "xmlerror")) return(test_xmlerror());
    if (!strcmp(module, "xmlreader")) return(test_xmlreader());
    if (!strcmp(module, "xmlsave")) return(test_xmlsave());
    if (!strcmp(module, "xmlschemas")) return(test_xmlschemas());
    if (!strcmp(module, "xmlschemastypes")) return(test_xmlschemastypes());
    if (!strcmp(module, "xmlstring")) return(test_xmlstring());
    if (!strcmp(module, "xmlunicode")) return(test_xmlunicode());
    if (!strcmp(module, "xmlwriter")) return(test_xmlwriter());
    if (!strcmp(module, "xpath")) return(test_xpath());
    if (!strcmp(module, "xpointer")) return(test_xpointer());
    return(0);
}
