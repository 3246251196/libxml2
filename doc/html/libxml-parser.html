<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" /><link rel="SHORTCUT ICON" href="/favicon.ico" /><style type="text/css">
TD {font-family: Verdana,Arial,Helvetica}
BODY {font-family: Verdana,Arial,Helvetica; margin-top: 2em; margin-left: 0em; margin-right: 0em}
H1 {font-family: Verdana,Arial,Helvetica}
H2 {font-family: Verdana,Arial,Helvetica}
H3 {font-family: Verdana,Arial,Helvetica}
A:link, A:visited, A:active { text-decoration: underline }
</style><title>Module parser from libxml2</title></head><body bgcolor="#8b7765" text="#000000" link="#000000" vlink="#000000"><table border="0" width="100%" cellpadding="5" cellspacing="0" align="center"><tr><td width="120"><a href="http://swpat.ffii.org/"><img src="../epatents.png" alt="Action against software patents" /></a></td><td width="180"><a href="http://www.gnome.org/"><img src="../gnome2.png" alt="Gnome2 Logo" /></a><a href="http://www.w3.org/Status"><img src="../w3c.png" alt="W3C Logo" /></a><a href="http://www.redhat.com/"><img src="../redhat.gif" alt="Red Hat Logo" /></a><div align="left"><a href="http://xmlsoft.org/"><img src="../Libxml2-Logo-180x168.gif" alt="Made with Libxml2 Logo" /></a></div></td><td><table border="0" width="90%" cellpadding="2" cellspacing="0" align="center" bgcolor="#000000"><tr><td><table width="100%" border="0" cellspacing="1" cellpadding="3" bgcolor="#fffacd"><tr><td align="center"><h1></h1><h2>Module parser from libxml2</h2></td></tr></table></td></tr></table></td></tr></table><table border="0" cellpadding="4" cellspacing="0" width="100%" align="center"><tr><td bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td valign="top" width="200" bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="1" width="100%" bgcolor="#000000"><tr><td><table width="100%" border="0" cellspacing="1" cellpadding="3"><tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>Main Menu</b></center></td></tr><tr><td bgcolor="#fffacd"><form action="search.php" enctype="application/x-www-form-urlencoded" method="get"><input name="query" type="text" size="20" value="" /><input name="submit" type="submit" value="Search ..." /></form><ul><li><a href="index.html">Home</a></li><li><a href="examples/index.html" style="font-weight:bold">Code Examples</a></li><li><a href="guidelines.html">XML Guidelines</a></li></ul></td></tr></table><table width="100%" border="0" cellspacing="1" cellpadding="3"><tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>Related links</b></center></td></tr><tr><td bgcolor="#fffacd"><ul><li><a href="http://mail.gnome.org/archives/xml/">Mail archive</a></li><li><a href="http://xmlsoft.org/XSLT/">XSLT libxslt</a></li><li><a href="http://phd.cs.unibo.it/gdome2/">DOM gdome2</a></li><li><a href="http://www.aleksey.com/xmlsec/">XML-DSig xmlsec</a></li><li><a href="ftp://xmlsoft.org/">FTP</a></li><li><a href="http://www.zlatkovic.com/projects/libxml/">Windows binaries</a></li><li><a href="http://garypennington.net/libxml2/">Solaris binaries</a></li><li><a href="http://www.zveno.com/open_source/libxml2xslt.html">MacOsX binaries</a></li><li><a href="http://sourceforge.net/projects/libxml2-pas/">Pascal bindings</a></li><li><a href="http://bugzilla.gnome.org/buglist.cgi?product=libxml2">Bug Tracker</a></li></ul></td></tr></table></td></tr></table></td><td valign="top" bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="1" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="1" width="100%" bgcolor="#000000"><tr><td><table border="0" cellpadding="3" cellspacing="1" width="100%"><tr><td bgcolor="#fffacd"><table class="navigation" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2"><tr valign="middle"><td><a accesskey="p" href="libxml-nanohttp.html"><img src="left.png" width="24" height="24" border="0" alt="Prev" /></a></td><th align="left"><a href="libxml-nanohttp.html">nanohttp</a></th><td><a accesskey="u" href="index.html"><img src="up.png" width="24" height="24" border="0" alt="Up" /></a></td><th align="left"><a href="index.html">API documentation</a></th><td><a accesskey="h" href="../index.html"><img src="home.png" width="24" height="24" border="0" alt="Home" /></a></td><th align="center"><a href="../index.html">The XML C parser and toolkit of Gnome</a></th><th align="right"><a href="libxml-parserInternals.html">parserInternals</a></th><td><a accesskey="n" href="libxml-parserInternals.html"><img src="right.png" width="24" height="24" border="0" alt="Next" /></a></td></tr></table><h2>Table of Contents</h2><pre class="programlisting">void	<a href="#xmlSetupParserForBuffer">xmlSetupParserForBuffer</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * buffer, <br />				 const char * filename)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlCtxtReadFile">xmlCtxtReadFile</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * filename, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting">int	<a href="#xmlStrcmp">xmlStrcmp</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlParseMemory">xmlParseMemory</a>	(const char * buffer, <br />				 int size)<br />
</pre><pre class="programlisting">int	<a href="#xmlParseCtxtExternalEntity">xmlParseCtxtExternalEntity</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * URL, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ID, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><pre class="programlisting">Structure <a name="xmlParserNodeInfoSeq" id="xmlParserNodeInfoSeq">xmlParserNodeInfoSeq</a><br />struct _xmlParserNodeInfoSeq {
    unsigned long	maximum
    unsigned long	length
    <a href="libxml-parser.html#xmlParserNodeInfo">xmlParserNodeInfo</a> *	buffer
}</pre><br /><pre class="programlisting">const <a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrcasestr">xmlStrcasestr</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 <a href="libxml-tree.html#xmlChar">xmlChar</a> * val)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrcat">xmlStrcat</a>	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * add)<br />
</pre><pre class="programlisting"><a name="attributeDeclSAXFunc" id="attributeDeclSAXFunc"></a>Function type: attributeDeclSAXFunc
void	attributeDeclSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * elem, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * fullname, <br />				 int type, <br />				 int def, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * defaultValue, <br />				 <a href="libxml-tree.html#xmlEnumerationPtr">xmlEnumerationPtr</a> tree)
</pre><p>An <a href="libxml-SAX.html#attribute">attribute</a> definition has been parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>elem</tt></i>:</span></td><td>the name of the element</td></tr><tr><td><span class="term"><i><tt>fullname</tt></i>:</span></td><td>the <a href="libxml-SAX.html#attribute">attribute</a> name</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>the <a href="libxml-SAX.html#attribute">attribute</a> type</td></tr><tr><td><span class="term"><i><tt>def</tt></i>:</span></td><td>the type of default value</td></tr><tr><td><span class="term"><i><tt>defaultValue</tt></i>:</span></td><td>the <a href="libxml-SAX.html#attribute">attribute</a> default value</td></tr><tr><td><span class="term"><i><tt>tree</tt></i>:</span></td><td>the tree of enumerated value set</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="getEntitySAXFunc" id="getEntitySAXFunc"></a>Function type: getEntitySAXFunc
<a href="libxml-tree.html#xmlEntityPtr">xmlEntityPtr</a>	getEntitySAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name)
</pre><p>Get an entity by name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The entity name</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlEntityPtr">xmlEntityPtr</a> if found.</td></tr></tbody></table></div><br />
<pre class="programlisting">const <a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrstr">xmlStrstr</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * val)<br />
</pre><pre class="programlisting"><a name="startElementSAXFunc" id="startElementSAXFunc"></a>Function type: startElementSAXFunc
void	startElementSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> ** atts)
</pre><p>Called when an opening tag has been processed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The element name, including namespace prefix</td></tr><tr><td><span class="term"><i><tt>atts</tt></i>:</span></td><td>An array of name/value attributes pairs, NULL terminated</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="charactersSAXFunc" id="charactersSAXFunc"></a>Function type: charactersSAXFunc
void	charactersSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ch, <br />				 int len)
</pre><p>Receiving some chars from the parser.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>ch</tt></i>:</span></td><td>a <a href="libxml-tree.html#xmlChar">xmlChar</a> string</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the number of <a href="libxml-tree.html#xmlChar">xmlChar</a></td></tr></tbody></table></div><br />
<pre class="programlisting">void	<a href="#xmlClearNodeInfoSeq">xmlClearNodeInfoSeq</a>	(<a href="libxml-parser.html#xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a> seq)<br />
</pre><pre class="programlisting">int	<a href="#xmlParseChunk">xmlParseChunk</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * chunk, <br />				 int size, <br />				 int terminate)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlReadMemory">xmlReadMemory</a>	(const char * buffer, <br />				 int size, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlParseEntity">xmlParseEntity</a>	(const char * filename)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlRecoverFile">xmlRecoverFile</a>	(const char * filename)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrdup">xmlStrdup</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><pre class="programlisting"><a name="unparsedEntityDeclSAXFunc" id="unparsedEntityDeclSAXFunc"></a>Function type: unparsedEntityDeclSAXFunc
void	unparsedEntityDeclSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * publicId, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * systemId, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * notationName)
</pre><p>What to do when an unparsed entity declaration is parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The name of the entity</td></tr><tr><td><span class="term"><i><tt>publicId</tt></i>:</span></td><td>The public ID of the entity</td></tr><tr><td><span class="term"><i><tt>systemId</tt></i>:</span></td><td>The system ID of the entity</td></tr><tr><td><span class="term"><i><tt>notationName</tt></i>:</span></td><td>the name of the notation</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="startElementNsSAX2Func" id="startElementNsSAX2Func"></a>Function type: startElementNsSAX2Func
void	startElementNsSAX2Func	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * localname, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * prefix, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * URI, <br />				 int nb_namespaces, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> ** namespaces, <br />				 int nb_attributes, <br />				 int nb_defaulted, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> ** attributes)
</pre><p>SAX2 callback when an element start has been detected by the parser. It provides the namespace informations for the element, as well as the new namespace declarations on the element.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>localname</tt></i>:</span></td><td>the local name of the element</td></tr><tr><td><span class="term"><i><tt>prefix</tt></i>:</span></td><td>the element namespace prefix if available</td></tr><tr><td><span class="term"><i><tt>URI</tt></i>:</span></td><td>the element namespace name if available</td></tr><tr><td><span class="term"><i><tt>nb_namespaces</tt></i>:</span></td><td>number of namespace definitions on that node</td></tr><tr><td><span class="term"><i><tt>namespaces</tt></i>:</span></td><td>pointer to the array of prefix/URI pairs namespace definitions</td></tr><tr><td><span class="term"><i><tt>nb_attributes</tt></i>:</span></td><td>the number of attributes on that node</td></tr><tr><td><span class="term"><i><tt>nb_defaulted</tt></i>:</span></td><td>the number of defaulted attributes. The defaulted ones are at the end of the array</td></tr><tr><td><span class="term"><i><tt>attributes</tt></i>:</span></td><td>pointer to the array of (localname/prefix/URI/value/end) <a href="libxml-SAX.html#attribute">attribute</a> values.</td></tr></tbody></table></div><br />
<pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	<a href="#xmlCreateIOParserCtxt">xmlCreateIOParserCtxt</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 <a href="libxml-xmlIO.html#xmlInputReadCallback">xmlInputReadCallback</a> ioread, <br />				 <a href="libxml-xmlIO.html#xmlInputCloseCallback">xmlInputCloseCallback</a> ioclose, <br />				 void * ioctx, <br />				 <a href="libxml-encoding.html#xmlCharEncoding">xmlCharEncoding</a> enc)<br />
</pre><pre class="programlisting"><a name="referenceSAXFunc" id="referenceSAXFunc"></a>Function type: referenceSAXFunc
void	referenceSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name)
</pre><p>Called when an entity <a href="libxml-SAX.html#reference">reference</a> is detected.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The entity name</td></tr></tbody></table></div><br />
<pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrncat">xmlStrncat</a>	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * add, <br />				 int len)<br />
</pre><pre class="programlisting"><a name="hasExternalSubsetSAXFunc" id="hasExternalSubsetSAXFunc"></a>Function type: hasExternalSubsetSAXFunc
int	hasExternalSubsetSAXFunc	(void * ctx)
</pre><p>Does this document has an external subset?</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if true</td></tr></tbody></table></div><br />
<pre class="programlisting">Typedef <a href="libxml-parser.html#xmlSAXHandlerV1">xmlSAXHandlerV1</a> * <a name="xmlSAXHandlerV1Ptr" id="xmlSAXHandlerV1Ptr">xmlSAXHandlerV1Ptr</a>

</pre><pre class="programlisting">int	<a href="#xmlStrPrintf">xmlStrPrintf</a>	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * buf, <br />				 int len, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * msg, <br />				 ... ...)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlSAXParseDoc">xmlSAXParseDoc</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 int recovery)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrndup">xmlStrndup</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 int len)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlCharStrdup">xmlCharStrdup</a>	(const char * cur)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a>	<a href="#xmlNewIOInputStream">xmlNewIOInputStream</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 <a href="libxml-tree.html#xmlParserInputBufferPtr">xmlParserInputBufferPtr</a> input, <br />				 <a href="libxml-encoding.html#xmlCharEncoding">xmlCharEncoding</a> enc)<br />
</pre><pre class="programlisting"><a name="processingInstructionSAXFunc" id="processingInstructionSAXFunc"></a>Function type: processingInstructionSAXFunc
void	processingInstructionSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * target, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * data)
</pre><p>A processing instruction has been parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>target</tt></i>:</span></td><td>the target name</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>the PI data's</td></tr></tbody></table></div><br />
<pre class="programlisting">int	<a href="#xmlParseBalancedChunkMemoryRecover">xmlParseBalancedChunkMemoryRecover</a>	(<a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a> doc, <br />				 <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 int depth, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * string, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst, <br />				 int recover)<br />
</pre><pre class="programlisting">void	<a href="#xmlInitParser">xmlInitParser</a>	(void)<br />
</pre><pre class="programlisting"><a name="errorSAXFunc" id="errorSAXFunc"></a>Function type: errorSAXFunc
void	errorSAXFunc	(void * ctx, <br />				 const char * msg, <br />				 ... ...)
</pre><p>Display and format an error messages, callback.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>msg</tt></i>:</span></td><td>the message to display/transmit</td></tr><tr><td><span class="term"><i><tt>...</tt></i>:</span></td><td>extra parameters for the message display</td></tr></tbody></table></div><br />
<pre class="programlisting">Enum <a name="xmlParserInputState" id="xmlParserInputState">xmlParserInputState</a> {
    <a name="XML_PARSER_EOF" id="XML_PARSER_EOF">XML_PARSER_EOF</a> = -1 : nothing is to be parsed
    <a name="XML_PARSER_START" id="XML_PARSER_START">XML_PARSER_START</a> = 0 : nothing has been parsed
    <a name="XML_PARSER_MISC" id="XML_PARSER_MISC">XML_PARSER_MISC</a> = 1 : Misc* before int subset
    <a name="XML_PARSER_PI" id="XML_PARSER_PI">XML_PARSER_PI</a> = 2 : Within a processing instruction
    <a name="XML_PARSER_DTD" id="XML_PARSER_DTD">XML_PARSER_DTD</a> = 3 : within some DTD content
    <a name="XML_PARSER_PROLOG" id="XML_PARSER_PROLOG">XML_PARSER_PROLOG</a> = 4 : Misc* after internal subset
    <a name="XML_PARSER_COMMENT" id="XML_PARSER_COMMENT">XML_PARSER_COMMENT</a> = 5 : within a <a href="libxml-SAX.html#comment">comment</a>
    <a name="XML_PARSER_START_TAG" id="XML_PARSER_START_TAG">XML_PARSER_START_TAG</a> = 6 : within a start tag
    <a name="XML_PARSER_CONTENT" id="XML_PARSER_CONTENT">XML_PARSER_CONTENT</a> = 7 : within the content
    <a name="XML_PARSER_CDATA_SECTION" id="XML_PARSER_CDATA_SECTION">XML_PARSER_CDATA_SECTION</a> = 8 : within a CDATA section
    <a name="XML_PARSER_END_TAG" id="XML_PARSER_END_TAG">XML_PARSER_END_TAG</a> = 9 : within a closing tag
    <a name="XML_PARSER_ENTITY_DECL" id="XML_PARSER_ENTITY_DECL">XML_PARSER_ENTITY_DECL</a> = 10 : within an entity declaration
    <a name="XML_PARSER_ENTITY_VALUE" id="XML_PARSER_ENTITY_VALUE">XML_PARSER_ENTITY_VALUE</a> = 11 : within an entity value in a decl
    <a name="XML_PARSER_ATTRIBUTE_VALUE" id="XML_PARSER_ATTRIBUTE_VALUE">XML_PARSER_ATTRIBUTE_VALUE</a> = 12 : within an <a href="libxml-SAX.html#attribute">attribute</a> value
    <a name="XML_PARSER_SYSTEM_LITERAL" id="XML_PARSER_SYSTEM_LITERAL">XML_PARSER_SYSTEM_LITERAL</a> = 13 : within a SYSTEM value
    <a name="XML_PARSER_EPILOG" id="XML_PARSER_EPILOG">XML_PARSER_EPILOG</a> = 14 : the Misc* after the last end tag
    <a name="XML_PARSER_IGNORE" id="XML_PARSER_IGNORE">XML_PARSER_IGNORE</a> = 15 : within an IGNORED section
    <a name="XML_PARSER_PUBLIC_LITERAL" id="XML_PARSER_PUBLIC_LITERAL">XML_PARSER_PUBLIC_LITERAL</a> = 16 : within a PUBLIC value
}

</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlSAXParseMemory">xmlSAXParseMemory</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * buffer, <br />				 int size, <br />				 int recovery)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlRecoverMemory">xmlRecoverMemory</a>	(const char * buffer, <br />				 int size)<br />
</pre><pre class="programlisting"><a name="xmlExternalEntityLoader" id="xmlExternalEntityLoader"></a>Function type: xmlExternalEntityLoader
<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a>	xmlExternalEntityLoader	(const char * URL, <br />				 const char * ID, <br />				 <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> context)
</pre><p>External entity loaders types.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>The System ID of the resource requested</td></tr><tr><td><span class="term"><i><tt>ID</tt></i>:</span></td><td>The Public ID of the resource requested</td></tr><tr><td><span class="term"><i><tt>context</tt></i>:</span></td><td>the XML parser context</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the entity input parser.</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="hasInternalSubsetSAXFunc" id="hasInternalSubsetSAXFunc"></a>Function type: hasInternalSubsetSAXFunc
int	hasInternalSubsetSAXFunc	(void * ctx)
</pre><p>Does this document has an internal subset.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if true</td></tr></tbody></table></div><br />
<pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlReadDoc">xmlReadDoc</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting"><a name="cdataBlockSAXFunc" id="cdataBlockSAXFunc"></a>Function type: cdataBlockSAXFunc
void	cdataBlockSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * value, <br />				 int len)
</pre><p>Called when a pcdata block has been parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>The pcdata content</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the block length</td></tr></tbody></table></div><br />
<pre class="programlisting">#define <a href="#XML_COMPLETE_ATTRS">XML_COMPLETE_ATTRS</a>

</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlSAXParseFile">xmlSAXParseFile</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * filename, <br />				 int recovery)<br />
</pre><pre class="programlisting"><a name="xmlParserInputDeallocate" id="xmlParserInputDeallocate"></a>Function type: xmlParserInputDeallocate
void	xmlParserInputDeallocate	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * str)
</pre><p>Callback for freeing some parser input allocations.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the string to deallocate</td></tr></tbody></table></div><br />
<pre class="programlisting">Typedef <a href="libxml-parser.html#xmlParserNodeInfo">xmlParserNodeInfo</a> * <a name="xmlParserNodeInfoPtr" id="xmlParserNodeInfoPtr">xmlParserNodeInfoPtr</a>

</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlCtxtReadIO">xmlCtxtReadIO</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 <a href="libxml-xmlIO.html#xmlInputReadCallback">xmlInputReadCallback</a> ioread, <br />				 <a href="libxml-xmlIO.html#xmlInputCloseCallback">xmlInputCloseCallback</a> ioclose, <br />				 void * ioctx, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlSAXParseMemoryWithData">xmlSAXParseMemoryWithData</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * buffer, <br />				 int size, <br />				 int recovery, <br />				 void * data)<br />
</pre><pre class="programlisting">const <a href="libxml-parser.html#xmlParserNodeInfo">xmlParserNodeInfo</a> *	<a href="#xmlParserFindNodeInfo">xmlParserFindNodeInfo</a>	(const <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctx, <br />				 const <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> node)<br />
</pre><pre class="programlisting">int	<a href="#xmlGetFeature">xmlGetFeature</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * name, <br />				 void * result)<br />
</pre><pre class="programlisting">Structure <a name="xmlParserNodeInfo" id="xmlParserNodeInfo">xmlParserNodeInfo</a><br />struct _xmlParserNodeInfo {
    const struct _xmlNode *	node	: Position &amp; line # that text that created the node
    unsigned long	begin_pos
    unsigned long	begin_line
    unsigned long	end_pos
    unsigned long	end_line
}</pre><br /><pre class="programlisting">const <a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrchr">xmlStrchr</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 <a href="libxml-tree.html#xmlChar">xmlChar</a> val)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	<a href="#xmlIOParseDTD">xmlIOParseDTD</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 <a href="libxml-tree.html#xmlParserInputBufferPtr">xmlParserInputBufferPtr</a> input, <br />				 <a href="libxml-encoding.html#xmlCharEncoding">xmlCharEncoding</a> enc)<br />
</pre><pre class="programlisting">void	<a href="#xmlFreeParserCtxt">xmlFreeParserCtxt</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	<a href="#xmlParseDTD">xmlParseDTD</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ExternalID, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * SystemID)<br />
</pre><pre class="programlisting"><a name="commentSAXFunc" id="commentSAXFunc"></a>Function type: commentSAXFunc
void	commentSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * value)
</pre><p>A <a href="libxml-SAX.html#comment">comment</a> has been parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>the <a href="libxml-SAX.html#comment">comment</a> content</td></tr></tbody></table></div><br />
<pre class="programlisting">int	<a href="#xmlInitParserCtxt">xmlInitParserCtxt</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting"><a name="attributeSAXFunc" id="attributeSAXFunc"></a>Function type: attributeSAXFunc
void	attributeSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * value)
</pre><p>Handle an <a href="libxml-SAX.html#attribute">attribute</a> that has been read by the parser. The default handling is to convert the <a href="libxml-SAX.html#attribute">attribute</a> into an DOM subtree and past it in a new <a href="libxml-tree.html#xmlAttr">xmlAttr</a> element added to the element.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The <a href="libxml-SAX.html#attribute">attribute</a> name, including namespace prefix</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>The <a href="libxml-SAX.html#attribute">attribute</a> value</td></tr></tbody></table></div><br />
<pre class="programlisting">int	<a href="#xmlStrQEqual">xmlStrQEqual</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * pref, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str)<br />
</pre><pre class="programlisting">int	<a href="#xmlParserInputGrow">xmlParserInputGrow</a>	(<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> in, <br />				 int len)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlCtxtReadMemory">xmlCtxtReadMemory</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * buffer, <br />				 int size, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting"><a name="externalSubsetSAXFunc" id="externalSubsetSAXFunc"></a>Function type: externalSubsetSAXFunc
void	externalSubsetSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ExternalID, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * SystemID)
</pre><p>Callback on external subset declaration.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the root element name</td></tr><tr><td><span class="term"><i><tt>ExternalID</tt></i>:</span></td><td>the external ID</td></tr><tr><td><span class="term"><i><tt>SystemID</tt></i>:</span></td><td>the SYSTEM ID (e.g. filename or URL)</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="resolveEntitySAXFunc" id="resolveEntitySAXFunc"></a>Function type: resolveEntitySAXFunc
<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a>	resolveEntitySAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * publicId, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * systemId)
</pre><p>Callback: The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it's own entity resolution routine</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>publicId</tt></i>:</span></td><td>The public ID of the entity</td></tr><tr><td><span class="term"><i><tt>systemId</tt></i>:</span></td><td>The system ID of the entity</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> if inlined or NULL for DOM behaviour.</td></tr></tbody></table></div><br />
<pre class="programlisting">Enum <a name="xmlParserOption" id="xmlParserOption">xmlParserOption</a> {
    <a name="XML_PARSE_RECOVER" id="XML_PARSE_RECOVER">XML_PARSE_RECOVER</a> = 1 : recover on errors
    <a name="XML_PARSE_NOENT" id="XML_PARSE_NOENT">XML_PARSE_NOENT</a> = 2 : substitute entities
    <a name="XML_PARSE_DTDLOAD" id="XML_PARSE_DTDLOAD">XML_PARSE_DTDLOAD</a> = 4 : load the external subset
    <a name="XML_PARSE_DTDATTR" id="XML_PARSE_DTDATTR">XML_PARSE_DTDATTR</a> = 8 : default DTD attributes
    <a name="XML_PARSE_DTDVALID" id="XML_PARSE_DTDVALID">XML_PARSE_DTDVALID</a> = 16 : validate with the DTD
    <a name="XML_PARSE_NOERROR" id="XML_PARSE_NOERROR">XML_PARSE_NOERROR</a> = 32 : suppress error reports
    <a name="XML_PARSE_NOWARNING" id="XML_PARSE_NOWARNING">XML_PARSE_NOWARNING</a> = 64 : suppress warning reports
    <a name="XML_PARSE_PEDANTIC" id="XML_PARSE_PEDANTIC">XML_PARSE_PEDANTIC</a> = 128 : pedantic error reporting
    <a name="XML_PARSE_NOBLANKS" id="XML_PARSE_NOBLANKS">XML_PARSE_NOBLANKS</a> = 256 : remove blank nodes
    <a name="XML_PARSE_SAX1" id="XML_PARSE_SAX1">XML_PARSE_SAX1</a> = 512 : use the SAX1 interface internally
    <a name="XML_PARSE_XINCLUDE" id="XML_PARSE_XINCLUDE">XML_PARSE_XINCLUDE</a> = 1024 : Implement XInclude substitition
    <a name="XML_PARSE_NONET" id="XML_PARSE_NONET">XML_PARSE_NONET</a> = 2048 : Forbid network access
    <a name="XML_PARSE_NODICT" id="XML_PARSE_NODICT">XML_PARSE_NODICT</a> = 4096 : Do not reuse the context dictionnary
    <a name="XML_PARSE_NSCLEAN" id="XML_PARSE_NSCLEAN">XML_PARSE_NSCLEAN</a> = 8192 : remove redundant namespaces declarations
    <a name="XML_PARSE_NOCDATA" id="XML_PARSE_NOCDATA">XML_PARSE_NOCDATA</a> = 16384 : merge CDATA as text nodes
}

</pre><pre class="programlisting">int	<a href="#xmlPedanticParserDefault">xmlPedanticParserDefault</a>	(int val)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlSAXParseEntity">xmlSAXParseEntity</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * filename)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlParseDoc">xmlParseDoc</a>	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><pre class="programlisting">void	<a href="#xmlParserAddNodeInfo">xmlParserAddNodeInfo</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const <a href="libxml-parser.html#xmlParserNodeInfoPtr">xmlParserNodeInfoPtr</a> info)<br />
</pre><pre class="programlisting">#define <a href="#XML_SAX2_MAGIC">XML_SAX2_MAGIC</a>

</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlSAXParseFileWithData">xmlSAXParseFileWithData</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * filename, <br />				 int recovery, <br />				 void * data)<br />
</pre><pre class="programlisting">int	<a href="#xmlLineNumbersDefault">xmlLineNumbersDefault</a>	(int val)<br />
</pre><pre class="programlisting"><a href="libxml-parser.html#xmlExternalEntityLoader">xmlExternalEntityLoader</a>	<a href="#xmlGetExternalEntityLoader">xmlGetExternalEntityLoader</a>	(void)<br />
</pre><pre class="programlisting"><a name="elementDeclSAXFunc" id="elementDeclSAXFunc"></a>Function type: elementDeclSAXFunc
void	elementDeclSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 int type, <br />				 <a href="libxml-tree.html#xmlElementContentPtr">xmlElementContentPtr</a> content)
</pre><p>An element definition has been parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the element name</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>the element type</td></tr><tr><td><span class="term"><i><tt>content</tt></i>:</span></td><td>the element value tree</td></tr></tbody></table></div><br />
<pre class="programlisting">int	<a href="#xmlCtxtUseOptions">xmlCtxtUseOptions</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 int options)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	<a href="#xmlCreatePushParserCtxt">xmlCreatePushParserCtxt</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 const char * chunk, <br />				 int size, <br />				 const char * filename)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlCharStrndup">xmlCharStrndup</a>	(const char * cur, <br />				 int len)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlCtxtReadFd">xmlCtxtReadFd</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 int fd, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting"><a name="internalSubsetSAXFunc" id="internalSubsetSAXFunc"></a>Function type: internalSubsetSAXFunc
void	internalSubsetSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ExternalID, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * SystemID)
</pre><p>Callback on internal subset declaration.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the root element name</td></tr><tr><td><span class="term"><i><tt>ExternalID</tt></i>:</span></td><td>the external ID</td></tr><tr><td><span class="term"><i><tt>SystemID</tt></i>:</span></td><td>the SYSTEM ID (e.g. filename or URL)</td></tr></tbody></table></div><br />
<pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	<a href="#xmlNewParserCtxt">xmlNewParserCtxt</a>	(void)<br />
</pre><pre class="programlisting"><a name="endDocumentSAXFunc" id="endDocumentSAXFunc"></a>Function type: endDocumentSAXFunc
void	endDocumentSAXFunc	(void * ctx)
</pre><p>Called when the document end has been detected.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr></tbody></table></div><br />
<pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlParseFile">xmlParseFile</a>	(const char * filename)<br />
</pre><pre class="programlisting">Typedef <a href="libxml-parser.html#xmlParserNodeInfoSeq">xmlParserNodeInfoSeq</a> * <a name="xmlParserNodeInfoSeqPtr" id="xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a>

</pre><pre class="programlisting">int	<a href="#xmlParseDocument">xmlParseDocument</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting">int	<a href="#xmlStrncmp">xmlStrncmp</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2, <br />				 int len)<br />
</pre><pre class="programlisting"><a name="setDocumentLocatorSAXFunc" id="setDocumentLocatorSAXFunc"></a>Function type: setDocumentLocatorSAXFunc
void	setDocumentLocatorSAXFunc	(void * ctx, <br />				 <a href="libxml-tree.html#xmlSAXLocatorPtr">xmlSAXLocatorPtr</a> loc)
</pre><p>Receive the document locator at startup, actually xmlDefaultSAXLocator. Everything is available on the context, so this is useless in our case.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>loc</tt></i>:</span></td><td>A SAX Locator</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="endElementSAXFunc" id="endElementSAXFunc"></a>Function type: endElementSAXFunc
void	endElementSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name)
</pre><p>Called when the end of an element has been detected.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The element name</td></tr></tbody></table></div><br />
<pre class="programlisting">#define <a href="#XML_DETECT_IDS">XML_DETECT_IDS</a>

</pre><pre class="programlisting"><a name="getParameterEntitySAXFunc" id="getParameterEntitySAXFunc"></a>Function type: getParameterEntitySAXFunc
<a href="libxml-tree.html#xmlEntityPtr">xmlEntityPtr</a>	getParameterEntitySAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name)
</pre><p>Get a parameter entity by name.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The entity name</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlEntityPtr">xmlEntityPtr</a> if found.</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="endElementNsSAX2Func" id="endElementNsSAX2Func"></a>Function type: endElementNsSAX2Func
void	endElementNsSAX2Func	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * localname, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * prefix, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * URI)
</pre><p>SAX2 callback when an element end has been detected by the parser. It provides the namespace informations for the element.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>localname</tt></i>:</span></td><td>the local name of the element</td></tr><tr><td><span class="term"><i><tt>prefix</tt></i>:</span></td><td>the element namespace prefix if available</td></tr><tr><td><span class="term"><i><tt>URI</tt></i>:</span></td><td>the element namespace name if available</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="ignorableWhitespaceSAXFunc" id="ignorableWhitespaceSAXFunc"></a>Function type: ignorableWhitespaceSAXFunc
void	ignorableWhitespaceSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ch, <br />				 int len)
</pre><p>Receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>ch</tt></i>:</span></td><td>a <a href="libxml-tree.html#xmlChar">xmlChar</a> string</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the number of <a href="libxml-tree.html#xmlChar">xmlChar</a></td></tr></tbody></table></div><br />
<pre class="programlisting">void	<a href="#xmlInitNodeInfoSeq">xmlInitNodeInfoSeq</a>	(<a href="libxml-parser.html#xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a> seq)<br />
</pre><pre class="programlisting">int	<a href="#xmlStrlen">xmlStrlen</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str)<br />
</pre><pre class="programlisting">int	<a href="#xmlSubstituteEntitiesDefault">xmlSubstituteEntitiesDefault</a>	(int val)<br />
</pre><pre class="programlisting">int	<a href="#xmlStrncasecmp">xmlStrncasecmp</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2, <br />				 int len)<br />
</pre><pre class="programlisting">unsigned long	<a href="#xmlParserFindNodeInfoIndex">xmlParserFindNodeInfoIndex</a>	(const <a href="libxml-parser.html#xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a> seq, <br />				 const <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> node)<br />
</pre><pre class="programlisting">int	<a href="#xmlSAXUserParseMemory">xmlSAXUserParseMemory</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 const char * buffer, <br />				 int size)<br />
</pre><pre class="programlisting">void	<a href="#xmlCtxtReset">xmlCtxtReset</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting">int	<a href="#xmlSetFeature">xmlSetFeature</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * name, <br />				 void * value)<br />
</pre><pre class="programlisting">int	<a href="#xmlStrEqual">xmlStrEqual</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2)<br />
</pre><pre class="programlisting">int	<a href="#xmlKeepBlanksDefault">xmlKeepBlanksDefault</a>	(int val)<br />
</pre><pre class="programlisting">int	<a href="#xmlParserInputRead">xmlParserInputRead</a>	(<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> in, <br />				 int len)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlReadFile">xmlReadFile</a>	(const char * filename, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting">int	<a href="#xmlGetFeaturesList">xmlGetFeaturesList</a>	(int * len, <br />				 const char ** result)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlCtxtReadDoc">xmlCtxtReadDoc</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting">Structure <a name="xmlSAXHandlerV1" id="xmlSAXHandlerV1">xmlSAXHandlerV1</a><br />struct _xmlSAXHandlerV1 {
    <a href="libxml-parser.html#internalSubsetSAXFunc">internalSubsetSAXFunc</a>	internalSubset
    <a href="libxml-parser.html#isStandaloneSAXFunc">isStandaloneSAXFunc</a>	isStandalone
    <a href="libxml-parser.html#hasInternalSubsetSAXFunc">hasInternalSubsetSAXFunc</a>	hasInternalSubset
    <a href="libxml-parser.html#hasExternalSubsetSAXFunc">hasExternalSubsetSAXFunc</a>	hasExternalSubset
    <a href="libxml-parser.html#resolveEntitySAXFunc">resolveEntitySAXFunc</a>	resolveEntity
    <a href="libxml-parser.html#getEntitySAXFunc">getEntitySAXFunc</a>	getEntity
    <a href="libxml-parser.html#entityDeclSAXFunc">entityDeclSAXFunc</a>	entityDecl
    <a href="libxml-parser.html#notationDeclSAXFunc">notationDeclSAXFunc</a>	notationDecl
    <a href="libxml-parser.html#attributeDeclSAXFunc">attributeDeclSAXFunc</a>	attributeDecl
    <a href="libxml-parser.html#elementDeclSAXFunc">elementDeclSAXFunc</a>	elementDecl
    <a href="libxml-parser.html#unparsedEntityDeclSAXFunc">unparsedEntityDeclSAXFunc</a>	unparsedEntityDecl
    <a href="libxml-parser.html#setDocumentLocatorSAXFunc">setDocumentLocatorSAXFunc</a>	setDocumentLocator
    <a href="libxml-parser.html#startDocumentSAXFunc">startDocumentSAXFunc</a>	startDocument
    <a href="libxml-parser.html#endDocumentSAXFunc">endDocumentSAXFunc</a>	endDocument
    <a href="libxml-parser.html#startElementSAXFunc">startElementSAXFunc</a>	startElement
    <a href="libxml-parser.html#endElementSAXFunc">endElementSAXFunc</a>	endElement
    <a href="libxml-parser.html#referenceSAXFunc">referenceSAXFunc</a>	reference
    <a href="libxml-parser.html#charactersSAXFunc">charactersSAXFunc</a>	characters
    <a href="libxml-parser.html#ignorableWhitespaceSAXFunc">ignorableWhitespaceSAXFunc</a>	ignorableWhitespace
    <a href="libxml-parser.html#processingInstructionSAXFunc">processingInstructionSAXFunc</a>	processingInstruction
    <a href="libxml-parser.html#commentSAXFunc">commentSAXFunc</a>	comment
    <a href="libxml-parser.html#warningSAXFunc">warningSAXFunc</a>	warning
    <a href="libxml-parser.html#errorSAXFunc">errorSAXFunc</a>	error
    <a href="libxml-parser.html#fatalErrorSAXFunc">fatalErrorSAXFunc</a>	fatalError	: unused error() get all the errors
    <a href="libxml-parser.html#getParameterEntitySAXFunc">getParameterEntitySAXFunc</a>	getParameterEntity
    <a href="libxml-parser.html#cdataBlockSAXFunc">cdataBlockSAXFunc</a>	cdataBlock
    <a href="libxml-parser.html#externalSubsetSAXFunc">externalSubsetSAXFunc</a>	externalSubset
    unsigned int	initialized
}</pre><br /><pre class="programlisting">int	<a href="#xmlSAXUserParseFile">xmlSAXUserParseFile</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 const char * filename)<br />
</pre><pre class="programlisting"><a name="fatalErrorSAXFunc" id="fatalErrorSAXFunc"></a>Function type: fatalErrorSAXFunc
void	fatalErrorSAXFunc	(void * ctx, <br />				 const char * msg, <br />				 ... ...)
</pre><p>Display and format fatal error messages, callback. Note: so far fatalError() SAX callbacks are not used, error() get all the callbacks for errors.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>msg</tt></i>:</span></td><td>the message to display/transmit</td></tr><tr><td><span class="term"><i><tt>...</tt></i>:</span></td><td>extra parameters for the message display</td></tr></tbody></table></div><br />
<pre class="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	<a href="#xmlSAXParseDTD">xmlSAXParseDTD</a>	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ExternalID, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * SystemID)<br />
</pre><pre class="programlisting"><a name="entityDeclSAXFunc" id="entityDeclSAXFunc"></a>Function type: entityDeclSAXFunc
void	entityDeclSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 int type, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * publicId, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * systemId, <br />				 <a href="libxml-tree.html#xmlChar">xmlChar</a> * content)
</pre><p>An entity definition has been parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the entity name</td></tr><tr><td><span class="term"><i><tt>type</tt></i>:</span></td><td>the entity type</td></tr><tr><td><span class="term"><i><tt>publicId</tt></i>:</span></td><td>The public ID of the entity</td></tr><tr><td><span class="term"><i><tt>systemId</tt></i>:</span></td><td>The system ID of the entity</td></tr><tr><td><span class="term"><i><tt>content</tt></i>:</span></td><td>the entity value (without processing).</td></tr></tbody></table></div><br />
<pre class="programlisting"><a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a>	<a href="#xmlLoadExternalEntity">xmlLoadExternalEntity</a>	(const char * URL, <br />				 const char * ID, <br />				 <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting">#define <a href="#XML_DEFAULT_VERSION">XML_DEFAULT_VERSION</a>

</pre><pre class="programlisting">void	<a href="#xmlStopParser">xmlStopParser</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlReadFd">xmlReadFd</a>	(int fd, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting">int	<a href="#xmlParseExtParsedEnt">xmlParseExtParsedEnt</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlReadIO">xmlReadIO</a>	(<a href="libxml-xmlIO.html#xmlInputReadCallback">xmlInputReadCallback</a> ioread, <br />				 <a href="libxml-xmlIO.html#xmlInputCloseCallback">xmlInputCloseCallback</a> ioclose, <br />				 void * ioctx, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><pre class="programlisting">int	<a href="#xmlStrVPrintf">xmlStrVPrintf</a>	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * buf, <br />				 int len, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * msg, <br />				 va_list ap)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	<a href="#xmlCreateDocParserCtxt">xmlCreateDocParserCtxt</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	<a href="#xmlStrsub">xmlStrsub</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 int start, <br />				 int len)<br />
</pre><pre class="programlisting">int	<a href="#xmlParseBalancedChunkMemory">xmlParseBalancedChunkMemory</a>	(<a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a> doc, <br />				 <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 int depth, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * string, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	<a href="#xmlRecoverDoc">xmlRecoverDoc</a>	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><pre class="programlisting">void	<a href="#xmlCleanupParser">xmlCleanupParser</a>	(void)<br />
</pre><pre class="programlisting">int	<a href="#xmlStrcasecmp">xmlStrcasecmp</a>	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2)<br />
</pre><pre class="programlisting">int	<a href="#xmlCtxtResetPush">xmlCtxtResetPush</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * chunk, <br />				 int size, <br />				 const char * filename, <br />				 const char * encoding)<br />
</pre><pre class="programlisting"><a name="isStandaloneSAXFunc" id="isStandaloneSAXFunc"></a>Function type: isStandaloneSAXFunc
int	isStandaloneSAXFunc	(void * ctx)
</pre><p>Is this document tagged standalone?</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if true</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="startDocumentSAXFunc" id="startDocumentSAXFunc"></a>Function type: startDocumentSAXFunc
void	startDocumentSAXFunc	(void * ctx)
</pre><p>Called when the document start being processed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr></tbody></table></div><br />
<pre class="programlisting">#define <a href="#XML_SKIP_IDS">XML_SKIP_IDS</a>

</pre><pre class="programlisting">void	<a href="#xmlClearParserCtxt">xmlClearParserCtxt</a>	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><pre class="programlisting">int	<a href="#xmlParseExternalEntity">xmlParseExternalEntity</a>	(<a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a> doc, <br />				 <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 int depth, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * URL, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ID, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><pre class="programlisting"><a name="notationDeclSAXFunc" id="notationDeclSAXFunc"></a>Function type: notationDeclSAXFunc
void	notationDeclSAXFunc	(void * ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * publicId, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * systemId)
</pre><p>What to do when a notation declaration has been parsed.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the user data (XML parser context)</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>The name of the notation</td></tr><tr><td><span class="term"><i><tt>publicId</tt></i>:</span></td><td>The public ID of the entity</td></tr><tr><td><span class="term"><i><tt>systemId</tt></i>:</span></td><td>The system ID of the entity</td></tr></tbody></table></div><br />
<pre class="programlisting"><a name="warningSAXFunc" id="warningSAXFunc"></a>Function type: warningSAXFunc
void	warningSAXFunc	(void * ctx, <br />				 const char * msg, <br />				 ... ...)
</pre><p>Display and format a warning messages, callback.</p><div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>msg</tt></i>:</span></td><td>the message to display/transmit</td></tr><tr><td><span class="term"><i><tt>...</tt></i>:</span></td><td>extra parameters for the message display</td></tr></tbody></table></div><br />
<pre class="programlisting">void	<a href="#xmlSetExternalEntityLoader">xmlSetExternalEntityLoader</a>	(<a href="libxml-parser.html#xmlExternalEntityLoader">xmlExternalEntityLoader</a> f)<br />
</pre><h2>Description</h2>
<h3><a name="xmlSetupParserForBuffer" id="xmlSetupParserForBuffer"></a>Function: xmlSetupParserForBuffer</h3><pre class="programlisting">void	xmlSetupParserForBuffer	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * buffer, <br />				 const char * filename)<br />
</pre><p>Setup the parser context to parse a new buffer; Clears any prior contents from the parser context. The buffer parameter must not be NULL, but the filename parameter can be</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>a <a href="libxml-tree.html#xmlChar">xmlChar</a> * buffer</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>a file name</td></tr></tbody></table></div><h3><a name="xmlCtxtReadFile" id="xmlCtxtReadFile"></a>Function: xmlCtxtReadFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlCtxtReadFile	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * filename, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML file from the filesystem or the network. This reuses the existing @ctxt parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>a file or URL</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlStrcmp" id="xmlStrcmp"></a>Function: xmlStrcmp</h3><pre class="programlisting">int	xmlStrcmp	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2)<br />
</pre><p>a strcmp for xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str1</tt></i>:</span></td><td>the first <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>str2</tt></i>:</span></td><td>the second <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the integer result of the comparison</td></tr></tbody></table></div><h3><a name="xmlParseMemory" id="xmlParseMemory"></a>Function: xmlParseMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseMemory	(const char * buffer, <br />				 int size)<br />
</pre><p>parse an XML in-memory block and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParseCtxtExternalEntity" id="xmlParseCtxtExternalEntity"></a>Function: xmlParseCtxtExternalEntity</h3><pre class="programlisting">int	xmlParseCtxtExternalEntity	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctx, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * URL, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ID, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><p>Parse an external general entity within an existing parsing context An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>the existing parsing context</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the URL for the entity to load</td></tr><tr><td><span class="term"><i><tt>ID</tt></i>:</span></td><td>the System ID for the entity to load</td></tr><tr><td><span class="term"><i><tt>lst</tt></i>:</span></td><td>the return value for the set of parsed nodes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise</td></tr></tbody></table></div>
      
      
      
    <h3><a name="xmlStrcasestr" id="xmlStrcasestr"></a>Function: xmlStrcasestr</h3><pre class="programlisting">const <a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrcasestr	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 <a href="libxml-tree.html#xmlChar">xmlChar</a> * val)<br />
</pre><p>a case-ignoring strstr for xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * array (haystack)</td></tr><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> to search (needle)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * for the first occurrence or NULL.</td></tr></tbody></table></div><h3><a name="xmlStrcat" id="xmlStrcat"></a>Function: xmlStrcat</h3><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrcat	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * add)<br />
</pre><p>a strcat for array of xmlChar's. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of '0'.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>the original <a href="libxml-tree.html#xmlChar">xmlChar</a> * array</td></tr><tr><td><span class="term"><i><tt>add</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * array added</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new <a href="libxml-tree.html#xmlChar">xmlChar</a> * containing the concatenated string.</td></tr></tbody></table></div>
      An attribute definition has been parsed.
      
      
      
      
      
      
      
      
    
      Get an entity by name.
      
      
      
    <h3><a name="xmlStrstr" id="xmlStrstr"></a>Function: xmlStrstr</h3><pre class="programlisting">const <a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrstr	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * val)<br />
</pre><p>a strstr for xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * array (haystack)</td></tr><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> to search (needle)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * for the first occurrence or NULL.</td></tr></tbody></table></div>
      Called when an opening tag has been processed.
      
      
      
      
    
      Receiving some chars from the parser.
      
      
      
      
    <h3><a name="xmlClearNodeInfoSeq" id="xmlClearNodeInfoSeq"></a>Function: xmlClearNodeInfoSeq</h3><pre class="programlisting">void	xmlClearNodeInfoSeq	(<a href="libxml-parser.html#xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a> seq)<br />
</pre><p>-- Clear (release memory and reinitialize) node info sequence</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>seq</tt></i>:</span></td><td>a node info sequence pointer</td></tr></tbody></table></div><h3><a name="xmlParseChunk" id="xmlParseChunk"></a>Function: xmlParseChunk</h3><pre class="programlisting">int	xmlParseChunk	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * chunk, <br />				 int size, <br />				 int terminate)<br />
</pre><p>Parse a Chunk of memory</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>chunk</tt></i>:</span></td><td>an char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size in byte of the chunk</td></tr><tr><td><span class="term"><i><tt>terminate</tt></i>:</span></td><td>last chunk indicator</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>zero if no error, the <a href="libxml-xmlerror.html#xmlParserErrors">xmlParserErrors</a> otherwise.</td></tr></tbody></table></div><h3><a name="xmlReadMemory" id="xmlReadMemory"></a>Function: xmlReadMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadMemory	(const char * buffer, <br />				 int size, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML in-memory document and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>a pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParseEntity" id="xmlParseEntity"></a>Function: xmlParseEntity</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseEntity	(const char * filename)<br />
</pre><p>parse an XML external entity out of context and build a tree. [78] extParsedEnt ::= TextDecl? content This correspond to a &quot;Well Balanced&quot; chunk</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlRecoverFile" id="xmlRecoverFile"></a>Function: xmlRecoverFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlRecoverFile	(const char * filename)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. In the case the document is not Well Formed, a tree is built anyway</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlStrdup" id="xmlStrdup"></a>Function: xmlStrdup</h3><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrdup	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><p>a strdup for array of xmlChar's. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of '0'.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>the input <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new <a href="libxml-tree.html#xmlChar">xmlChar</a> * or NULL</td></tr></tbody></table></div>
      What to do when an unparsed entity declaration is parsed.
      
      
      
      
      
      
    
      SAX2 callback when an element start has been detected by the parser. It provides the namespace informations for the element, as well as the new namespace declarations on the element.
      
      
      
      
      
      
      
      
      
      
    <h3><a name="xmlCreateIOParserCtxt" id="xmlCreateIOParserCtxt"></a>Function: xmlCreateIOParserCtxt</h3><pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	xmlCreateIOParserCtxt	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 <a href="libxml-xmlIO.html#xmlInputReadCallback">xmlInputReadCallback</a> ioread, <br />				 <a href="libxml-xmlIO.html#xmlInputCloseCallback">xmlInputCloseCallback</a> ioclose, <br />				 void * ioctx, <br />				 <a href="libxml-encoding.html#xmlCharEncoding">xmlCharEncoding</a> enc)<br />
</pre><p>Create a parser context for using the XML parser with an existing I/O stream</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>a SAX handler</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks</td></tr><tr><td><span class="term"><i><tt>ioread</tt></i>:</span></td><td>an I/O read function</td></tr><tr><td><span class="term"><i><tt>ioclose</tt></i>:</span></td><td>an I/O close function</td></tr><tr><td><span class="term"><i><tt>ioctx</tt></i>:</span></td><td>an I/O handler</td></tr><tr><td><span class="term"><i><tt>enc</tt></i>:</span></td><td>the charset encoding if known</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new parser context or NULL</td></tr></tbody></table></div>
      Called when an entity reference is detected.
      
      
      
    <h3><a name="xmlStrncat" id="xmlStrncat"></a>Function: xmlStrncat</h3><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrncat	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * add, <br />				 int len)<br />
</pre><p>a strncat for array of xmlChar's, it will extend @cur with the len first bytes of @add.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>the original <a href="libxml-tree.html#xmlChar">xmlChar</a> * array</td></tr><tr><td><span class="term"><i><tt>add</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * array added</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the length of @add</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new <a href="libxml-tree.html#xmlChar">xmlChar</a> *, the original @cur is reallocated if needed and should not be freed</td></tr></tbody></table></div>
      Does this document has an external subset?
      
      
    <h3><a name="xmlStrPrintf" id="xmlStrPrintf"></a>Function: xmlStrPrintf</h3><pre class="programlisting">int	xmlStrPrintf	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * buf, <br />				 int len, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * msg, <br />				 ... ...)<br />
</pre><p>Formats @msg and places result into @buf.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>the result buffer.</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the result buffer length.</td></tr><tr><td><span class="term"><i><tt>msg</tt></i>:</span></td><td>the message with printf formatting.</td></tr><tr><td><span class="term"><i><tt>...</tt></i>:</span></td><td>extra parameters for the message.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of <a href="libxml-SAX.html#characters">characters</a> written to @buf or -1 if an error occurs.</td></tr></tbody></table></div><h3><a name="xmlSAXParseDoc" id="xmlSAXParseDoc"></a>Function: xmlSAXParseDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseDoc	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 int recovery)<br />
</pre><p>parse an XML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to an array of <a href="libxml-tree.html#xmlChar">xmlChar</a></td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlStrndup" id="xmlStrndup"></a>Function: xmlStrndup</h3><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrndup	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 int len)<br />
</pre><p>a strndup for array of xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>the input <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the len of @cur</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new <a href="libxml-tree.html#xmlChar">xmlChar</a> * or NULL</td></tr></tbody></table></div><h3><a name="xmlCharStrdup" id="xmlCharStrdup"></a>Function: xmlCharStrdup</h3><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlCharStrdup	(const char * cur)<br />
</pre><p>a strdup for char's to xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>the input char *</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new <a href="libxml-tree.html#xmlChar">xmlChar</a> * or NULL</td></tr></tbody></table></div><h3><a name="xmlNewIOInputStream" id="xmlNewIOInputStream"></a>Function: xmlNewIOInputStream</h3><pre class="programlisting"><a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a>	xmlNewIOInputStream	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 <a href="libxml-tree.html#xmlParserInputBufferPtr">xmlParserInputBufferPtr</a> input, <br />				 <a href="libxml-encoding.html#xmlCharEncoding">xmlCharEncoding</a> enc)<br />
</pre><p>Create a new input stream structure encapsulating the @input into a stream suitable for the parser.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>input</tt></i>:</span></td><td>an I/O Input</td></tr><tr><td><span class="term"><i><tt>enc</tt></i>:</span></td><td>the charset encoding if known</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new input stream or NULL</td></tr></tbody></table></div>
      A processing instruction has been parsed.
      
      
      
      
    <h3><a name="xmlParseBalancedChunkMemoryRecover" id="xmlParseBalancedChunkMemoryRecover"></a>Function: xmlParseBalancedChunkMemoryRecover</h3><pre class="programlisting">int	xmlParseBalancedChunkMemoryRecover	(<a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a> doc, <br />				 <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 int depth, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * string, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst, <br />				 int recover)<br />
</pre><p>Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>doc</tt></i>:</span></td><td>the document the chunk pertains to</td></tr><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler bloc (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>depth</tt></i>:</span></td><td>Used for loop detection, use 0</td></tr><tr><td><span class="term"><i><tt>string</tt></i>:</span></td><td>the input string in UTF8 or ISO-Latin (zero terminated)</td></tr><tr><td><span class="term"><i><tt>lst</tt></i>:</span></td><td>the return value for the set of parsed nodes</td></tr><tr><td><span class="term"><i><tt>recover</tt></i>:</span></td><td>return nodes even if the data is broken (use 0)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise In case recover is set to 1, the nodelist will not be empty even if the parsed chunk is not well balanced.</td></tr></tbody></table></div><h3><a name="xmlInitParser" id="xmlInitParser"></a>Function: xmlInitParser</h3><pre class="programlisting">void	xmlInitParser	(void)<br />
</pre><p>Initialization function for the XML parser. This is not reentrant. Call once before processing in case of use in multithreaded programs.</p>

      Display and format an error messages, callback.
      
      
      
      
    <h3><a name="xmlSAXParseMemory" id="xmlSAXParseMemory"></a>Function: xmlSAXParseMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseMemory	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * buffer, <br />				 int size, <br />				 int recovery)<br />
</pre><p>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read not Well Formed documents</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlRecoverMemory" id="xmlRecoverMemory"></a>Function: xmlRecoverMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlRecoverMemory	(const char * buffer, <br />				 int size)<br />
</pre><p>parse an XML in-memory block and build a tree. In the case the document is not Well Formed, a tree is built anyway</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div>
      External entity loaders types.
      
      
      
      
    
      Does this document has an internal subset.
      
      
    <h3><a name="xmlReadDoc" id="xmlReadDoc"></a>Function: xmlReadDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadDoc	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML in-memory document and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to a zero terminated string</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div>
      Called when a pcdata block has been parsed.
      
      
      
      
    <h3><a name="XML_COMPLETE_ATTRS" id="XML_COMPLETE_ATTRS"></a>Macro: XML_COMPLETE_ATTRS</h3><pre>#define XML_COMPLETE_ATTRS</pre><p>Bit in the loadsubset context field to tell to do complete the elements attributes lists with the ones defaulted from the DTDs. Use it to initialize xmlLoadExtDtdDefaultValue.</p>
<h3><a name="xmlSAXParseFile" id="xmlSAXParseFile"></a>Function: xmlSAXParseFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseFile	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * filename, <br />				 int recovery)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div>
      Callback for freeing some parser input allocations.
      
      
    <h3><a name="xmlCtxtReadIO" id="xmlCtxtReadIO"></a>Function: xmlCtxtReadIO</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlCtxtReadIO	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 <a href="libxml-xmlIO.html#xmlInputReadCallback">xmlInputReadCallback</a> ioread, <br />				 <a href="libxml-xmlIO.html#xmlInputCloseCallback">xmlInputCloseCallback</a> ioclose, <br />				 void * ioctx, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML document from I/O functions and source and build a tree. This reuses the existing @ctxt parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>ioread</tt></i>:</span></td><td>an I/O read function</td></tr><tr><td><span class="term"><i><tt>ioclose</tt></i>:</span></td><td>an I/O close function</td></tr><tr><td><span class="term"><i><tt>ioctx</tt></i>:</span></td><td>an I/O handler</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlSAXParseMemoryWithData" id="xmlSAXParseMemoryWithData"></a>Function: xmlSAXParseMemoryWithData</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseMemoryWithData	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * buffer, <br />				 int size, <br />				 int recovery, <br />				 void * data)<br />
</pre><p>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. User data (void *) is stored within the parser context in the context's _private member, so it is available nearly everywhere in libxml</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>the userdata</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParserFindNodeInfo" id="xmlParserFindNodeInfo"></a>Function: xmlParserFindNodeInfo</h3><pre class="programlisting">const <a href="libxml-parser.html#xmlParserNodeInfo">xmlParserNodeInfo</a> *	xmlParserFindNodeInfo	(const <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctx, <br />				 const <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> node)<br />
</pre><p>Find the parser node info struct for a given node</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctx</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>node</tt></i>:</span></td><td>an XML node within the tree</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>an <a href="libxml-parser.html#xmlParserNodeInfo">xmlParserNodeInfo</a> block pointer or NULL</td></tr></tbody></table></div><h3><a name="xmlGetFeature" id="xmlGetFeature"></a>Function: xmlGetFeature</h3><pre class="programlisting">int	xmlGetFeature	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * name, <br />				 void * result)<br />
</pre><p>Read the current value of one feature of this parser instance</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML/HTML parser context</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the feature name</td></tr><tr><td><span class="term"><i><tt>result</tt></i>:</span></td><td>location to store the result</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case or error, 0 otherwise</td></tr></tbody></table></div>
      
      
      
      
      
    <h3><a name="xmlStrchr" id="xmlStrchr"></a>Function: xmlStrchr</h3><pre class="programlisting">const <a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrchr	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 <a href="libxml-tree.html#xmlChar">xmlChar</a> val)<br />
</pre><p>a strchr for xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * array</td></tr><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> to search</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * for the first occurrence or NULL.</td></tr></tbody></table></div><h3><a name="xmlIOParseDTD" id="xmlIOParseDTD"></a>Function: xmlIOParseDTD</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	xmlIOParseDTD	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 <a href="libxml-tree.html#xmlParserInputBufferPtr">xmlParserInputBufferPtr</a> input, <br />				 <a href="libxml-encoding.html#xmlCharEncoding">xmlCharEncoding</a> enc)<br />
</pre><p>Load and parse a DTD</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block or NULL</td></tr><tr><td><span class="term"><i><tt>input</tt></i>:</span></td><td>an Input Buffer</td></tr><tr><td><span class="term"><i><tt>enc</tt></i>:</span></td><td>the charset encoding if known</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting <a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a> or NULL in case of error. @input will be freed at parsing end.</td></tr></tbody></table></div><h3><a name="xmlFreeParserCtxt" id="xmlFreeParserCtxt"></a>Function: xmlFreeParserCtxt</h3><pre class="programlisting">void	xmlFreeParserCtxt	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr></tbody></table></div><h3><a name="xmlParseDTD" id="xmlParseDTD"></a>Function: xmlParseDTD</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	xmlParseDTD	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ExternalID, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * SystemID)<br />
</pre><p>Load and parse an external subset.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ExternalID</tt></i>:</span></td><td>a NAME* containing the External ID of the DTD</td></tr><tr><td><span class="term"><i><tt>SystemID</tt></i>:</span></td><td>a NAME* containing the URL to the DTD</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting <a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a> or NULL in case of error.</td></tr></tbody></table></div>
      A comment has been parsed.
      
      
      
    <h3><a name="xmlInitParserCtxt" id="xmlInitParserCtxt"></a>Function: xmlInitParserCtxt</h3><pre class="programlisting">int	xmlInitParserCtxt	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>Initialize a parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and -1 in case of error</td></tr></tbody></table></div>
      Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.
      
      
      
      
    <h3><a name="xmlStrQEqual" id="xmlStrQEqual"></a>Function: xmlStrQEqual</h3><pre class="programlisting">int	xmlStrQEqual	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * pref, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * name, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str)<br />
</pre><p>Check if a QName is Equal to a given string</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>pref</tt></i>:</span></td><td>the prefix of the QName</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the localname of the QName</td></tr><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the second <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if they are equal, 0 if they are different</td></tr></tbody></table></div><h3><a name="xmlParserInputGrow" id="xmlParserInputGrow"></a>Function: xmlParserInputGrow</h3><pre class="programlisting">int	xmlParserInputGrow	(<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> in, <br />				 int len)<br />
</pre><p>This function increase the input for the parser. It tries to preserve pointers to the input buffer, and keep already read data</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>in</tt></i>:</span></td><td>an XML parser input</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>an indicative size for the lookahead</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of xmlChars read, or -1 in case of error, 0 indicate the end of this entity</td></tr></tbody></table></div><h3><a name="xmlCtxtReadMemory" id="xmlCtxtReadMemory"></a>Function: xmlCtxtReadMemory</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlCtxtReadMemory	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * buffer, <br />				 int size, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>a pointer to a char array</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the size of the array</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div>
      Callback on external subset declaration.
      
      
      
      
      
    
      Callback: The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it's own entity resolution routine
      
      
      
      
    <h3><a name="xmlPedanticParserDefault" id="xmlPedanticParserDefault"></a>Function: xmlPedanticParserDefault</h3><pre class="programlisting">int	xmlPedanticParserDefault	(int val)<br />
</pre><p>Set and return the previous value for enabling pedantic warnings.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>int 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the last value for 0 for no substitution, 1 for substitution.</td></tr></tbody></table></div><h3><a name="xmlSAXParseEntity" id="xmlSAXParseEntity"></a>Function: xmlSAXParseEntity</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseEntity	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * filename)<br />
</pre><p>parse an XML external entity out of context and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. [78] extParsedEnt ::= TextDecl? content This correspond to a &quot;Well Balanced&quot; chunk</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParseDoc" id="xmlParseDoc"></a>Function: xmlParseDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseDoc	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><p>parse an XML in-memory document and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to an array of <a href="libxml-tree.html#xmlChar">xmlChar</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParserAddNodeInfo" id="xmlParserAddNodeInfo"></a>Function: xmlParserAddNodeInfo</h3><pre class="programlisting">void	xmlParserAddNodeInfo	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const <a href="libxml-parser.html#xmlParserNodeInfoPtr">xmlParserNodeInfoPtr</a> info)<br />
</pre><p>Insert node info record into the sorted sequence</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>info</tt></i>:</span></td><td>a node info sequence pointer</td></tr></tbody></table></div><h3><a name="XML_SAX2_MAGIC" id="XML_SAX2_MAGIC"></a>Macro: XML_SAX2_MAGIC</h3><pre>#define XML_SAX2_MAGIC</pre><p>Special constant found in SAX2 blocks initialized fields</p>
<h3><a name="xmlSAXParseFileWithData" id="xmlSAXParseFileWithData"></a>Function: xmlSAXParseFileWithData</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlSAXParseFileWithData	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const char * filename, <br />				 int recovery, <br />				 void * data)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. User data (void *) is stored within the parser context in the context's _private member, so it is available nearly everywhere in libxml</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>recovery</tt></i>:</span></td><td>work in recovery mode, i.e. tries to read no Well Formed documents</td></tr><tr><td><span class="term"><i><tt>data</tt></i>:</span></td><td>the userdata</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlLineNumbersDefault" id="xmlLineNumbersDefault"></a>Function: xmlLineNumbersDefault</h3><pre class="programlisting">int	xmlLineNumbersDefault	(int val)<br />
</pre><p>Set and return the previous value for enabling line numbers in elements contents. This may break on old application and is turned off by default.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>int 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the last value for 0 for no substitution, 1 for substitution.</td></tr></tbody></table></div><h3><a name="xmlGetExternalEntityLoader" id="xmlGetExternalEntityLoader"></a>Function: xmlGetExternalEntityLoader</h3><pre class="programlisting"><a href="libxml-parser.html#xmlExternalEntityLoader">xmlExternalEntityLoader</a>	xmlGetExternalEntityLoader	(void)<br />
</pre><p>Get the default external entity resolver function for the application</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-parser.html#xmlExternalEntityLoader">xmlExternalEntityLoader</a> function pointer</td></tr></tbody></table></div>
      An element definition has been parsed.
      
      
      
      
      
    <h3><a name="xmlCtxtUseOptions" id="xmlCtxtUseOptions"></a>Function: xmlCtxtUseOptions</h3><pre class="programlisting">int	xmlCtxtUseOptions	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 int options)<br />
</pre><p>Applies the options to the parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success, the set of unknown or unimplemented options in case of error.</td></tr></tbody></table></div><h3><a name="xmlCreatePushParserCtxt" id="xmlCreatePushParserCtxt"></a>Function: xmlCreatePushParserCtxt</h3><pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	xmlCreatePushParserCtxt	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 const char * chunk, <br />				 int size, <br />				 const char * filename)<br />
</pre><p>Create a parser context for using the XML parser in push mode. If @buffer and @size are non-NULL, the data is used to detect the encoding. The remaining <a href="libxml-SAX.html#characters">characters</a> will be parsed so they don't need to be fed in again through xmlParseChunk. To allow content encoding detection, @size should be &gt;= 4 The value of @filename is used for fetching external entities and error/warning reports.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>a SAX handler</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks</td></tr><tr><td><span class="term"><i><tt>chunk</tt></i>:</span></td><td>a pointer to an array of chars</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>number of chars in the array</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>an optional file name or URI</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new parser context or NULL</td></tr></tbody></table></div><h3><a name="xmlCharStrndup" id="xmlCharStrndup"></a>Function: xmlCharStrndup</h3><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlCharStrndup	(const char * cur, <br />				 int len)<br />
</pre><p>a strndup for char's to xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>the input char *</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the len of @cur</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a new <a href="libxml-tree.html#xmlChar">xmlChar</a> * or NULL</td></tr></tbody></table></div><h3><a name="xmlCtxtReadFd" id="xmlCtxtReadFd"></a>Function: xmlCtxtReadFd</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlCtxtReadFd	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 int fd, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML from a file descriptor and build a tree. This reuses the existing @ctxt parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>an open file descriptor</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div>
      Callback on internal subset declaration.
      
      
      
      
      
    <h3><a name="xmlNewParserCtxt" id="xmlNewParserCtxt"></a>Function: xmlNewParserCtxt</h3><pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	xmlNewParserCtxt	(void)<br />
</pre><p>Allocate and initialize a new parser context.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> or NULL</td></tr></tbody></table></div>
      Called when the document end has been detected.
      
      
    <h3><a name="xmlParseFile" id="xmlParseFile"></a>Function: xmlParseFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlParseFile	(const char * filename)<br />
</pre><p>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>the filename</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree if the file was wellformed, NULL otherwise.</td></tr></tbody></table></div><h3><a name="xmlParseDocument" id="xmlParseDocument"></a>Function: xmlParseDocument</h3><pre class="programlisting">int	xmlParseDocument	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>parse an XML document (and build a tree if using the standard SAX interface). [1] document ::= prolog element Misc* [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0, -1 in case of error. the parser context is augmented as a result of the parsing.</td></tr></tbody></table></div><h3><a name="xmlStrncmp" id="xmlStrncmp"></a>Function: xmlStrncmp</h3><pre class="programlisting">int	xmlStrncmp	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2, <br />				 int len)<br />
</pre><p>a strncmp for xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str1</tt></i>:</span></td><td>the first <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>str2</tt></i>:</span></td><td>the second <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the max comparison length</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the integer result of the comparison</td></tr></tbody></table></div>
      Receive the document locator at startup, actually xmlDefaultSAXLocator. Everything is available on the context, so this is useless in our case.
      
      
      
    
      Called when the end of an element has been detected.
      
      
      
    <h3><a name="XML_DETECT_IDS" id="XML_DETECT_IDS"></a>Macro: XML_DETECT_IDS</h3><pre>#define XML_DETECT_IDS</pre><p>Bit in the loadsubset context field to tell to do ID/REFs lookups. Use it to initialize xmlLoadExtDtdDefaultValue.</p>

      Get a parameter entity by name.
      
      
      
    
      SAX2 callback when an element end has been detected by the parser. It provides the namespace informations for the element.
      
      
      
      
      
    
      Receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters.
      
      
      
      
    <h3><a name="xmlInitNodeInfoSeq" id="xmlInitNodeInfoSeq"></a>Function: xmlInitNodeInfoSeq</h3><pre class="programlisting">void	xmlInitNodeInfoSeq	(<a href="libxml-parser.html#xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a> seq)<br />
</pre><p>-- Initialize (set to initial state) node info sequence</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>seq</tt></i>:</span></td><td>a node info sequence pointer</td></tr></tbody></table></div><h3><a name="xmlStrlen" id="xmlStrlen"></a>Function: xmlStrlen</h3><pre class="programlisting">int	xmlStrlen	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str)<br />
</pre><p>length of a xmlChar's string</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * array</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of <a href="libxml-tree.html#xmlChar">xmlChar</a> contained in the ARRAY.</td></tr></tbody></table></div><h3><a name="xmlSubstituteEntitiesDefault" id="xmlSubstituteEntitiesDefault"></a>Function: xmlSubstituteEntitiesDefault</h3><pre class="programlisting">int	xmlSubstituteEntitiesDefault	(int val)<br />
</pre><p>Set and return the previous value for default entity support. Initially the parser always keep entity references instead of substituting entity values in the output. This function has to be used to change the default parser behavior SAX::substituteEntities() has to be used for changing that on a file by file basis.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>int 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the last value for 0 for no substitution, 1 for substitution.</td></tr></tbody></table></div><h3><a name="xmlStrncasecmp" id="xmlStrncasecmp"></a>Function: xmlStrncasecmp</h3><pre class="programlisting">int	xmlStrncasecmp	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2, <br />				 int len)<br />
</pre><p>a strncasecmp for xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str1</tt></i>:</span></td><td>the first <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>str2</tt></i>:</span></td><td>the second <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the max comparison length</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the integer result of the comparison</td></tr></tbody></table></div><h3><a name="xmlParserFindNodeInfoIndex" id="xmlParserFindNodeInfoIndex"></a>Function: xmlParserFindNodeInfoIndex</h3><pre class="programlisting">unsigned long	xmlParserFindNodeInfoIndex	(const <a href="libxml-parser.html#xmlParserNodeInfoSeqPtr">xmlParserNodeInfoSeqPtr</a> seq, <br />				 const <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> node)<br />
</pre><p><a href="libxml-parser.html#xmlParserFindNodeInfoIndex">xmlParserFindNodeInfoIndex</a> : Find the index that the info record for the given node is or should be at in a sorted sequence</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>seq</tt></i>:</span></td><td>a node info sequence pointer</td></tr><tr><td><span class="term"><i><tt>node</tt></i>:</span></td><td>an XML node pointer</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>a long indicating the position of the record</td></tr></tbody></table></div><h3><a name="xmlSAXUserParseMemory" id="xmlSAXUserParseMemory"></a>Function: xmlSAXUserParseMemory</h3><pre class="programlisting">int	xmlSAXUserParseMemory	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 const char * buffer, <br />				 int size)<br />
</pre><p>A better SAX parsing routine. parse an XML in-memory buffer and call the given SAX handler routines.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>a SAX handler</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks</td></tr><tr><td><span class="term"><i><tt>buffer</tt></i>:</span></td><td>an in-memory XML document input</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>the length of the XML document in bytes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or a error number otherwise</td></tr></tbody></table></div><h3><a name="xmlCtxtReset" id="xmlCtxtReset"></a>Function: xmlCtxtReset</h3><pre class="programlisting">void	xmlCtxtReset	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>Reset a parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr></tbody></table></div><h3><a name="xmlSetFeature" id="xmlSetFeature"></a>Function: xmlSetFeature</h3><pre class="programlisting">int	xmlSetFeature	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * name, <br />				 void * value)<br />
</pre><p>Change the current value of one feature of this parser instance</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML/HTML parser context</td></tr><tr><td><span class="term"><i><tt>name</tt></i>:</span></td><td>the feature name</td></tr><tr><td><span class="term"><i><tt>value</tt></i>:</span></td><td>pointer to the location of the new value</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case or error, 0 otherwise</td></tr></tbody></table></div><h3><a name="xmlStrEqual" id="xmlStrEqual"></a>Function: xmlStrEqual</h3><pre class="programlisting">int	xmlStrEqual	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2)<br />
</pre><p>Check if both string are equal of have same content Should be a bit more readable and faster than xmlStrEqual()</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str1</tt></i>:</span></td><td>the first <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>str2</tt></i>:</span></td><td>the second <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>1 if they are equal, 0 if they are different</td></tr></tbody></table></div><h3><a name="xmlKeepBlanksDefault" id="xmlKeepBlanksDefault"></a>Function: xmlKeepBlanksDefault</h3><pre class="programlisting">int	xmlKeepBlanksDefault	(int val)<br />
</pre><p>Set and return the previous value for default blanks text nodes support. The 1.x version of the parser used an heuristic to try to detect ignorable white spaces. As a result the SAX callback was generating xmlSAX2IgnorableWhitespace() callbacks instead of characters() one, and when using the DOM output text nodes containing those blanks were not generated. The 2.x and later version will switch to the XML standard way and ignorableWhitespace() are only generated when running the parser in validating mode and when the current element doesn't allow CDATA or mixed content. This function is provided as a way to force the standard behavior on 1.X libs and to switch back to the old mode for compatibility when running 1.X client code on 2.X . Upgrade of 1.X code should be done by using xmlIsBlankNode() commodity function to detect the &quot;empty&quot; nodes generated. This value also affect autogeneration of indentation when saving code if blanks sections are kept, indentation is not generated.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>val</tt></i>:</span></td><td>int 0 or 1</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the last value for 0 for no substitution, 1 for substitution.</td></tr></tbody></table></div><h3><a name="xmlParserInputRead" id="xmlParserInputRead"></a>Function: xmlParserInputRead</h3><pre class="programlisting">int	xmlParserInputRead	(<a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> in, <br />				 int len)<br />
</pre><p>This function refresh the input for the parser. It doesn't try to preserve pointers to the input buffer, and discard already read data</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>in</tt></i>:</span></td><td>an XML parser input</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>an indicative size for the lookahead</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of xmlChars read, or -1 in case of error, 0 indicate the end of this entity</td></tr></tbody></table></div><h3><a name="xmlReadFile" id="xmlReadFile"></a>Function: xmlReadFile</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadFile	(const char * filename, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML file from the filesystem or the network.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>a file or URL</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlGetFeaturesList" id="xmlGetFeaturesList"></a>Function: xmlGetFeaturesList</h3><pre class="programlisting">int	xmlGetFeaturesList	(int * len, <br />				 const char ** result)<br />
</pre><p>Copy at most *@len feature names into the @result array</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the length of the features name array (input/output)</td></tr><tr><td><span class="term"><i><tt>result</tt></i>:</span></td><td>an array of string to be filled with the features name.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>-1 in case or error, or the total number of features, len is updated with the number of strings copied, strings must not be deallocated</td></tr></tbody></table></div><h3><a name="xmlCtxtReadDoc" id="xmlCtxtReadDoc"></a>Function: xmlCtxtReadDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlCtxtReadDoc	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to a zero terminated string</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    <h3><a name="xmlSAXUserParseFile" id="xmlSAXUserParseFile"></a>Function: xmlSAXUserParseFile</h3><pre class="programlisting">int	xmlSAXUserParseFile	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 const char * filename)<br />
</pre><p>parse an XML file and call the given SAX handler routines. Automatic support for ZLIB/Compress compressed document is provided</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>a SAX handler</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>a file name</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success or a error number otherwise</td></tr></tbody></table></div>
      Display and format fatal error messages, callback. Note: so far fatalError() SAX callbacks are not used, error() get all the callbacks for errors.
      
      
      
      
    <h3><a name="xmlSAXParseDTD" id="xmlSAXParseDTD"></a>Function: xmlSAXParseDTD</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a>	xmlSAXParseDTD	(<a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ExternalID, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * SystemID)<br />
</pre><p>Load and parse an external subset.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler block</td></tr><tr><td><span class="term"><i><tt>ExternalID</tt></i>:</span></td><td>a NAME* containing the External ID of the DTD</td></tr><tr><td><span class="term"><i><tt>SystemID</tt></i>:</span></td><td>a NAME* containing the URL to the DTD</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting <a href="libxml-tree.html#xmlDtdPtr">xmlDtdPtr</a> or NULL in case of error.</td></tr></tbody></table></div>
      An entity definition has been parsed.
      
      
      
      
      
      
      
    <h3><a name="xmlLoadExternalEntity" id="xmlLoadExternalEntity"></a>Function: xmlLoadExternalEntity</h3><pre class="programlisting"><a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a>	xmlLoadExternalEntity	(const char * URL, <br />				 const char * ID, <br />				 <a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>Load an external entity, note that the use of this function for unparsed entities may generate problems TODO: a more generic External entity API must be designed</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the URL for the entity to load</td></tr><tr><td><span class="term"><i><tt>ID</tt></i>:</span></td><td>the Public ID for the entity to load</td></tr><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>the context in which the entity is called or NULL</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlParserInputPtr">xmlParserInputPtr</a> or NULL</td></tr></tbody></table></div><h3><a name="XML_DEFAULT_VERSION" id="XML_DEFAULT_VERSION"></a>Macro: XML_DEFAULT_VERSION</h3><pre>#define XML_DEFAULT_VERSION</pre><p>The default version of XML used: 1.0</p>
<h3><a name="xmlStopParser" id="xmlStopParser"></a>Function: xmlStopParser</h3><pre class="programlisting">void	xmlStopParser	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>Blocks further parser processing</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr></tbody></table></div><h3><a name="xmlReadFd" id="xmlReadFd"></a>Function: xmlReadFd</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadFd	(int fd, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML from a file descriptor and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>fd</tt></i>:</span></td><td>an open file descriptor</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlParseExtParsedEnt" id="xmlParseExtParsedEnt"></a>Function: xmlParseExtParsedEnt</h3><pre class="programlisting">int	xmlParseExtParsedEnt	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>parse a general parsed entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0, -1 in case of error. the parser context is augmented as a result of the parsing.</td></tr></tbody></table></div><h3><a name="xmlReadIO" id="xmlReadIO"></a>Function: xmlReadIO</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlReadIO	(<a href="libxml-xmlIO.html#xmlInputReadCallback">xmlInputReadCallback</a> ioread, <br />				 <a href="libxml-xmlIO.html#xmlInputCloseCallback">xmlInputCloseCallback</a> ioclose, <br />				 void * ioctx, <br />				 const char * URL, <br />				 const char * encoding, <br />				 int options)<br />
</pre><p>parse an XML document from I/O functions and source and build a tree.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ioread</tt></i>:</span></td><td>an I/O read function</td></tr><tr><td><span class="term"><i><tt>ioclose</tt></i>:</span></td><td>an I/O close function</td></tr><tr><td><span class="term"><i><tt>ioctx</tt></i>:</span></td><td>an I/O handler</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the base URL to use for the document</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>options</tt></i>:</span></td><td>a combination of xmlParserOption(s)</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlStrVPrintf" id="xmlStrVPrintf"></a>Function: xmlStrVPrintf</h3><pre class="programlisting">int	xmlStrVPrintf	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * buf, <br />				 int len, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * msg, <br />				 va_list ap)<br />
</pre><p>Formats @msg and places result into @buf.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>buf</tt></i>:</span></td><td>the result buffer.</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the result buffer length.</td></tr><tr><td><span class="term"><i><tt>msg</tt></i>:</span></td><td>the message with printf formatting.</td></tr><tr><td><span class="term"><i><tt>ap</tt></i>:</span></td><td>extra parameters for the message.</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the number of <a href="libxml-SAX.html#characters">characters</a> written to @buf or -1 if an error occurs.</td></tr></tbody></table></div><h3><a name="xmlCreateDocParserCtxt" id="xmlCreateDocParserCtxt"></a>Function: xmlCreateDocParserCtxt</h3><pre class="programlisting"><a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a>	xmlCreateDocParserCtxt	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><p>Creates a parser context for an XML in-memory document.</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to an array of <a href="libxml-tree.html#xmlChar">xmlChar</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the new parser context or NULL</td></tr></tbody></table></div><h3><a name="xmlStrsub" id="xmlStrsub"></a>Function: xmlStrsub</h3><pre class="programlisting"><a href="libxml-tree.html#xmlChar">xmlChar</a> *	xmlStrsub	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str, <br />				 int start, <br />				 int len)<br />
</pre><p>Extract a substring of a given string</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * array (haystack)</td></tr><tr><td><span class="term"><i><tt>start</tt></i>:</span></td><td>the index of the first char (zero based)</td></tr><tr><td><span class="term"><i><tt>len</tt></i>:</span></td><td>the length of the substring</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the <a href="libxml-tree.html#xmlChar">xmlChar</a> * for the first occurrence or NULL.</td></tr></tbody></table></div><h3><a name="xmlParseBalancedChunkMemory" id="xmlParseBalancedChunkMemory"></a>Function: xmlParseBalancedChunkMemory</h3><pre class="programlisting">int	xmlParseBalancedChunkMemory	(<a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a> doc, <br />				 <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 int depth, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * string, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><p>Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>doc</tt></i>:</span></td><td>the document the chunk pertains to</td></tr><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler bloc (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>depth</tt></i>:</span></td><td>Used for loop detection, use 0</td></tr><tr><td><span class="term"><i><tt>string</tt></i>:</span></td><td>the input string in UTF8 or ISO-Latin (zero terminated)</td></tr><tr><td><span class="term"><i><tt>lst</tt></i>:</span></td><td>the return value for the set of parsed nodes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise</td></tr></tbody></table></div><h3><a name="xmlRecoverDoc" id="xmlRecoverDoc"></a>Function: xmlRecoverDoc</h3><pre class="programlisting"><a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a>	xmlRecoverDoc	(<a href="libxml-tree.html#xmlChar">xmlChar</a> * cur)<br />
</pre><p>parse an XML in-memory document and build a tree. In the case the document is not Well Formed, a tree is built anyway</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>cur</tt></i>:</span></td><td>a pointer to an array of <a href="libxml-tree.html#xmlChar">xmlChar</a></td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the resulting document tree</td></tr></tbody></table></div><h3><a name="xmlCleanupParser" id="xmlCleanupParser"></a>Function: xmlCleanupParser</h3><pre class="programlisting">void	xmlCleanupParser	(void)<br />
</pre><p>Cleanup function for the XML library. It tries to reclaim all parsing related global memory allocated for the library processing. It doesn't deallocate any document related memory. Calling this function should not prevent reusing the library but one should call xmlCleanupParser() only when the process has finished using the library or XML document built with it.</p>
<h3><a name="xmlStrcasecmp" id="xmlStrcasecmp"></a>Function: xmlStrcasecmp</h3><pre class="programlisting">int	xmlStrcasecmp	(const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str1, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * str2)<br />
</pre><p>a strcasecmp for xmlChar's</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>str1</tt></i>:</span></td><td>the first <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>str2</tt></i>:</span></td><td>the second <a href="libxml-tree.html#xmlChar">xmlChar</a> *</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>the integer result of the comparison</td></tr></tbody></table></div><h3><a name="xmlCtxtResetPush" id="xmlCtxtResetPush"></a>Function: xmlCtxtResetPush</h3><pre class="programlisting">int	xmlCtxtResetPush	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt, <br />				 const char * chunk, <br />				 int size, <br />				 const char * filename, <br />				 const char * encoding)<br />
</pre><p>Reset a push parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr><tr><td><span class="term"><i><tt>chunk</tt></i>:</span></td><td>a pointer to an array of chars</td></tr><tr><td><span class="term"><i><tt>size</tt></i>:</span></td><td>number of chars in the array</td></tr><tr><td><span class="term"><i><tt>filename</tt></i>:</span></td><td>an optional file name or URI</td></tr><tr><td><span class="term"><i><tt>encoding</tt></i>:</span></td><td>the document encoding, or NULL</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 in case of success and 1 in case of error</td></tr></tbody></table></div>
      Is this document tagged standalone?
      
      
    
      Called when the document start being processed.
      
      
    <h3><a name="XML_SKIP_IDS" id="XML_SKIP_IDS"></a>Macro: XML_SKIP_IDS</h3><pre>#define XML_SKIP_IDS</pre><p>Bit in the loadsubset context field to tell to not do ID/REFs registration. Used to initialize <a href="libxml-globals.html#xmlLoadExtDtdDefaultValue">xmlLoadExtDtdDefaultValue</a> in some special cases.</p>
<h3><a name="xmlClearParserCtxt" id="xmlClearParserCtxt"></a>Function: xmlClearParserCtxt</h3><pre class="programlisting">void	xmlClearParserCtxt	(<a href="libxml-tree.html#xmlParserCtxtPtr">xmlParserCtxtPtr</a> ctxt)<br />
</pre><p>Clear (release owned resources) and reinitialize a parser context</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>ctxt</tt></i>:</span></td><td>an XML parser context</td></tr></tbody></table></div><h3><a name="xmlParseExternalEntity" id="xmlParseExternalEntity"></a>Function: xmlParseExternalEntity</h3><pre class="programlisting">int	xmlParseExternalEntity	(<a href="libxml-tree.html#xmlDocPtr">xmlDocPtr</a> doc, <br />				 <a href="libxml-tree.html#xmlSAXHandlerPtr">xmlSAXHandlerPtr</a> sax, <br />				 void * user_data, <br />				 int depth, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * URL, <br />				 const <a href="libxml-tree.html#xmlChar">xmlChar</a> * ID, <br />				 <a href="libxml-tree.html#xmlNodePtr">xmlNodePtr</a> * lst)<br />
</pre><p>Parse an external general entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. [78] extParsedEnt ::= TextDecl? content</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>doc</tt></i>:</span></td><td>the document the chunk pertains to</td></tr><tr><td><span class="term"><i><tt>sax</tt></i>:</span></td><td>the SAX handler bloc (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>user_data</tt></i>:</span></td><td>The user data returned on SAX callbacks (possibly NULL)</td></tr><tr><td><span class="term"><i><tt>depth</tt></i>:</span></td><td>Used for loop detection, use 0</td></tr><tr><td><span class="term"><i><tt>URL</tt></i>:</span></td><td>the URL for the entity to load</td></tr><tr><td><span class="term"><i><tt>ID</tt></i>:</span></td><td>the System ID for the entity to load</td></tr><tr><td><span class="term"><i><tt>lst</tt></i>:</span></td><td>the return value for the set of parsed nodes</td></tr><tr><td><span class="term"><i><tt>Returns</tt></i>:</span></td><td>0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise</td></tr></tbody></table></div>
      What to do when a notation declaration has been parsed.
      
      
      
      
      
    
      Display and format a warning messages, callback.
      
      
      
      
    <h3><a name="xmlSetExternalEntityLoader" id="xmlSetExternalEntityLoader"></a>Function: xmlSetExternalEntityLoader</h3><pre class="programlisting">void	xmlSetExternalEntityLoader	(<a href="libxml-parser.html#xmlExternalEntityLoader">xmlExternalEntityLoader</a> f)<br />
</pre><p>Changes the defaultexternal entity resolver function for the application</p>
<div class="variablelist"><table border="0"><col align="left" /><tbody><tr><td><span class="term"><i><tt>f</tt></i>:</span></td><td>the new entity resolver function</td></tr></tbody></table></div><p><a href="bugs.html">Daniel Veillard</a></p></td></tr></table></td></tr></table></td></tr></table></td></tr></table></td></tr></table></body></html>
