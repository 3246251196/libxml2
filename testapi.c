/*
 * testapi.c: libxml2 API tester program.
 *
 * Automatically generated by gentest.py from libxml2-api.xml
 *
 * See Copyright for the status of this software.
 *
 * daniel@veillard.com
 */

#include <stdio.h>
#include <libxml/xmlerror.h>

static int testlibxml2(void);

static int generic_errors = 0;
static int call_tests = 0;

static xmlChar chartab[1024] = "  chartab\n";

static void
structured_errors(void *userData ATTRIBUTE_UNUSED,
                  xmlErrorPtr error ATTRIBUTE_UNUSED) {
    generic_errors++;
}

int main(void) {
    int ret;
    int blocks, mem;

    xmlInitParser();

    LIBXML_TEST_VERSION

    xmlSetStructuredErrorFunc(NULL, structured_errors);

    ret = testlibxml2();

    xmlCleanupParser();
    blocks = xmlMemBlocks();
    mem = xmlMemUsed();
    if ((blocks != 0) || (mem != 0)) {
        printf("testapi leaked %d bytes in %d blocks\n", mem, blocks);
    }
    xmlMemoryDump();

    return (ret != 0);
}

#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/c14n.h>
#include <libxml/catalog.h>
#include <libxml/chvalid.h>
#include <libxml/dict.h>
#include <libxml/encoding.h>
#include <libxml/entities.h>
#include <libxml/hash.h>
#include <libxml/list.h>
#include <libxml/nanoftp.h>
#include <libxml/nanohttp.h>
#include <libxml/parser.h>
#include <libxml/pattern.h>
#include <libxml/relaxng.h>
#include <libxml/schemasInternals.h>
#include <libxml/tree.h>
#include <libxml/uri.h>
#include <libxml/valid.h>
#include <libxml/xinclude.h>
#include <libxml/xmlIO.h>
#include <libxml/xmlautomata.h>
#include <libxml/xmlerror.h>
#include <libxml/xmlexports.h>
#include <libxml/xmlreader.h>
#include <libxml/xmlregexp.h>
#include <libxml/xmlsave.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>
#include <libxml/xmlstring.h>
#include <libxml/xmlwriter.h>
#include <libxml/xpath.h>
#include <libxml/xpointer.h>
static int test_HTMLparser(void);
static int test_HTMLtree(void);
static int test_c14n(void);
static int test_catalog(void);
static int test_chvalid(void);
static int test_dict(void);
static int test_encoding(void);
static int test_entities(void);
static int test_hash(void);
static int test_list(void);
static int test_nanoftp(void);
static int test_nanohttp(void);
static int test_parser(void);
static int test_pattern(void);
static int test_relaxng(void);
static int test_schemasInternals(void);
static int test_tree(void);
static int test_uri(void);
static int test_valid(void);
static int test_xinclude(void);
static int test_xmlIO(void);
static int test_xmlautomata(void);
static int test_xmlerror(void);
static int test_xmlexports(void);
static int test_xmlreader(void);
static int test_xmlregexp(void);
static int test_xmlsave(void);
static int test_xmlschemas(void);
static int test_xmlschemastypes(void);
static int test_xmlstring(void);
static int test_xmlwriter(void);
static int test_xpath(void);
static int test_xpointer(void);

#define gen_nb_userdata 3

static void *gen_userdata(int no) {
    if (no == 0) return((void *) &call_tests);
    if (no == 1) return((void *) -1);
    return(NULL);
}
static void des_userdata(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED) {
}


#define gen_nb_int 4

static int gen_int(int no) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return(-1);
}

static void des_int(int no ATTRIBUTE_UNUSED, int val ATTRIBUTE_UNUSED) {
}

#define gen_nb_const_char_ptr 4

static const char *gen_const_char_ptr(int no) {
    if (no == 0) return("foo");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    return(NULL);
}
static void des_const_char_ptr(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlChar_ptr 2

static xmlChar *gen_xmlChar_ptr(int no) {
    if (no == 0) return(&chartab);
    return(NULL);
}
static void des_xmlChar_ptr(int no ATTRIBUTE_UNUSED, xmlChar *val ATTRIBUTE_UNUSED) {
}

#define gen_nb_const_xmlChar_ptr 5

static const xmlChar *gen_const_xmlChar_ptr(int no) {
    if (no == 0) return((const xmlChar *) "foo");
    if (no == 1) return((const xmlChar *) "<foo/>");
    if (no == 2) return((const xmlChar *) "nøne");
    if (no == 3) return((const xmlChar *) " 2ab ");
    return(NULL);
}
static void des_const_xmlChar_ptr(int no ATTRIBUTE_UNUSED, const xmlChar *val ATTRIBUTE_UNUSED) {
}

#define gen_nb_filepath 8

static const char *gen_filepath(int no) {
    if (no == 0) return("missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    if (no == 3) return("test/valid/REC-xml-19980210.xml");
    if (no == 4) return("test/valid/xhtml1-strict.dtd");
    if (no == 5) return("http://missing.example.org/");
    if (no == 6) return("http://missing. example.org/");
    return(NULL);
}
static void des_filepath(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED) {
}

#define gen_nb_fileoutput 6

static const char *gen_fileoutput(int no) {
    if (no == 0) return("/missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("ftp://missing.example.org/foo");
    if (no == 3) return("http://missing.example.org/");
    if (no == 4) return("http://missing. example.org/");
    return(NULL);
}
static void des_fileoutput(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED) {
}

#define gen_nb_xmlParserCtxtPtr 2
static xmlParserCtxtPtr gen_xmlParserCtxtPtr(int no) {
    if (no == 0) return(xmlNewParserCtxt());
    return(NULL);
}
static void des_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlParserCtxtPtr val) {
    if (val != NULL)
        xmlFreeParserCtxt(val);
}

#define gen_nb_xmlDocPtr 3
static xmlDocPtr gen_xmlDocPtr(int no) {
    if (no == 0) return(xmlNewDoc(BAD_CAST "1.0"));
    if (no == 1) return(xmlReadMemory("<foo/>", 6, "test", NULL, 0));
    return(NULL);
}
static void des_xmlDocPtr(int no ATTRIBUTE_UNUSED, xmlDocPtr val) {
    if (val != NULL)
        xmlFreeDoc(val);
}

#define gen_nb_xmlNodePtr 2
static xmlNodePtr gen_xmlNodePtr(int no) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    return(NULL);
}
static void des_xmlNodePtr(int no ATTRIBUTE_UNUSED, xmlNodePtr val) {
    if (val != NULL) {
        xmlUnlinkNode(val);
        xmlFreeNode(val);
    }
}

#define gen_nb_xmlNodePtr_in 3
static xmlNodePtr gen_xmlNodePtr_in(int no) {
    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    if (no == 0) return(xmlNewText(BAD_CAST "text"));
    return(NULL);
}
static void des_xmlNodePtr_in(int no ATTRIBUTE_UNUSED, xmlNodePtr val ATTRIBUTE_UNUSED) {
}


static void desret_int(int val ATTRIBUTE_UNUSED) {
}
static void desret_const_char_ptr(const char *val ATTRIBUTE_UNUSED) {
}
static void desret_xmlChar_ptr(xmlChar *val) {
    if (val != NULL)
	xmlFree(val);
}
static void desret_xmlDocPtr(xmlDocPtr val) {
    xmlFreeDoc(val);
}
static void desret_xmlNodePtr(xmlNodePtr val) {
    xmlUnlinkNode(val);
    xmlFreeNode(val);
}

/**
 * testlibxml2:
 *
 * Main entry point of the tester for the full libxml2 module,
 * it calls all the tester entry point for each module.
 *
 * Returns the number of error found
 */
static int
testlibxml2(void)
{
    int ret = 0;

    ret += test_HTMLparser();
    ret += test_HTMLtree();
    ret += test_c14n();
    ret += test_catalog();
    ret += test_chvalid();
    ret += test_dict();
    ret += test_encoding();
    ret += test_entities();
    ret += test_hash();
    ret += test_list();
    ret += test_nanoftp();
    ret += test_nanohttp();
    ret += test_parser();
    ret += test_pattern();
    ret += test_relaxng();
    ret += test_schemasInternals();
    ret += test_tree();
    ret += test_uri();
    ret += test_valid();
    ret += test_xinclude();
    ret += test_xmlIO();
    ret += test_xmlautomata();
    ret += test_xmlerror();
    ret += test_xmlexports();
    ret += test_xmlreader();
    ret += test_xmlregexp();
    ret += test_xmlsave();
    ret += test_xmlschemas();
    ret += test_xmlschemastypes();
    ret += test_xmlstring();
    ret += test_xmlwriter();
    ret += test_xpath();
    ret += test_xpointer();

    printf("Total: %d tests, %d errors\n", call_tests, ret);
    return(ret);
}


static int
test_UTF8ToHtml(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlAttrAllowed(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlAutoCloseTag(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the HTML document */
    int n_doc;
    const xmlChar * name; /* The tag name */
    int n_name;
    htmlNodePtr elem; /* the HTML element */
    int n_elem;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        name = gen_const_xmlChar_ptr(n_name);
        elem = gen_xmlNodePtr(n_elem);

        ret_val = htmlAutoCloseTag(doc, name, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_name, name);
        des_xmlNodePtr(n_elem, elem);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlAutoCloseTag",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
#endif

    return(ret);
}


static int
test_htmlCreateMemoryParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlCreatePushParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlCtxtReadDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        cur = gen_const_xmlChar_ptr(n_cur);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = htmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_xmlChar_ptr(n_cur, cur);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_htmlCtxtReadFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        filename = gen_filepath(n_filename);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = htmlCtxtReadFile(ctxt, filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_filepath(n_filename, filename);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_htmlCtxtReadIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlCtxtReadMemory(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        buffer = gen_const_char_ptr(n_buffer);
        size = gen_int(n_size);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = htmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_char_ptr(n_buffer, buffer);
        des_int(n_size, size);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_htmlCtxtReset(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        htmlCtxtReset(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_htmlCtxtUseOptions(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        options = gen_int(n_options);

        ret_val = htmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtUseOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_htmlElementAllowedHere(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlElementStatusHere(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlEncodeEntities(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlEntityLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlEntityValueLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlHandleOmittedElem(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val);

        ret_val = htmlHandleOmittedElem(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlHandleOmittedElem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_htmlIsAutoClosed(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the HTML document */
    int n_doc;
    htmlNodePtr elem; /* the HTML element */
    int n_elem;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        elem = gen_xmlNodePtr(n_elem);

        ret_val = htmlIsAutoClosed(doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_xmlNodePtr(n_elem, elem);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsAutoClosed",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_htmlIsScriptAttribute(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * name; /* an attribute name */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = htmlIsScriptAttribute(name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsScriptAttribute",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_htmlNodeStatus(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlParseCharRef(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        ret_val = htmlParseCharRef(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseCharRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_htmlParseChunk(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;
    const char * chunk; /* an char array */
    int n_chunk;
    int size; /* the size in byte of the chunk */
    int n_size;
    int terminate; /* last chunk indicator */
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        chunk = gen_const_char_ptr(n_chunk);
        size = gen_int(n_size);
        terminate = gen_int(n_terminate);

        ret_val = htmlParseChunk(ctxt, chunk, size, terminate);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_char_ptr(n_chunk, chunk);
        des_int(n_size, size);
        des_int(n_terminate, terminate);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseChunk",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    return(ret);
}


static int
test_htmlParseDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;
    const char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur);
        encoding = gen_const_char_ptr(n_encoding);

        ret_val = htmlParseDoc(cur, encoding);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur);
        des_const_char_ptr(n_encoding, encoding);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_htmlParseDocument(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        ret_val = htmlParseDocument(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_htmlParseElement(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlParserCtxtPtr ctxt; /* an HTML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        htmlParseElement(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_htmlParseEntityRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlParseFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    htmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;
    const char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        filename = gen_filepath(n_filename);
        encoding = gen_const_char_ptr(n_encoding);

        ret_val = htmlParseFile(filename, encoding);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        des_const_char_ptr(n_encoding, encoding);
        xmlResetLastError();
    }
    }
#endif

    return(ret);
}


static int
test_htmlReadDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = htmlReadDoc(cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_htmlReadFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = htmlReadFile(filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
#endif

    return(ret);
}


static int
test_htmlReadIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlReadMemory(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of htmlParserOption(s) */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer);
        size = gen_int(n_size);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = htmlReadMemory(buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer);
        des_int(n_size, size);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_htmlSAXParseDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlSAXParseFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlTagLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_HTMLparser(void) {
    int ret = 0;

    printf("Testing HTMLparser ...\n");
    ret += test_UTF8ToHtml();
    ret += test_htmlAttrAllowed();
    ret += test_htmlAutoCloseTag();
    ret += test_htmlCreateMemoryParserCtxt();
    ret += test_htmlCreatePushParserCtxt();
    ret += test_htmlCtxtReadDoc();
    ret += test_htmlCtxtReadFile();
    ret += test_htmlCtxtReadIO();
    ret += test_htmlCtxtReadMemory();
    ret += test_htmlCtxtReset();
    ret += test_htmlCtxtUseOptions();
    ret += test_htmlElementAllowedHere();
    ret += test_htmlElementStatusHere();
    ret += test_htmlEncodeEntities();
    ret += test_htmlEntityLookup();
    ret += test_htmlEntityValueLookup();
    ret += test_htmlHandleOmittedElem();
    ret += test_htmlIsAutoClosed();
    ret += test_htmlIsScriptAttribute();
    ret += test_htmlNodeStatus();
    ret += test_htmlParseCharRef();
    ret += test_htmlParseChunk();
    ret += test_htmlParseDoc();
    ret += test_htmlParseDocument();
    ret += test_htmlParseElement();
    ret += test_htmlParseEntityRef();
    ret += test_htmlParseFile();
    ret += test_htmlReadDoc();
    ret += test_htmlReadFile();
    ret += test_htmlReadIO();
    ret += test_htmlReadMemory();
    ret += test_htmlSAXParseDoc();
    ret += test_htmlSAXParseFile();
    ret += test_htmlTagLookup();

    if (ret != 0)
	printf("Module HTMLparser: %d errors\n", ret);
    return(ret);
}

static int
test_htmlDocContentDumpFormatOutput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlDocContentDumpOutput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlDocDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlDocDumpMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlGetMetaEncoding(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlIsBooleanAttr(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * name; /* the name of the attribute to check */
    int n_name;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = htmlIsBooleanAttr(name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsBooleanAttr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_htmlNewDoc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const xmlChar * URI; /* URI for the dtd, or NULL */
    int n_URI;
    const xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
    int n_ExternalID;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID);

        ret_val = htmlNewDoc(URI, ExternalID);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_htmlNewDocNoDtD(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    htmlDocPtr ret_val;
    const xmlChar * URI; /* URI for the dtd, or NULL */
    int n_URI;
    const xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
    int n_ExternalID;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID);

        ret_val = htmlNewDocNoDtD(URI, ExternalID);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI);
        des_const_xmlChar_ptr(n_ExternalID, ExternalID);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDocNoDtD",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_htmlNodeDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlNodeDumpFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlNodeDumpFileFormat(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlNodeDumpFormatOutput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlNodeDumpOutput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_htmlSaveFile(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename);
        cur = gen_xmlDocPtr(n_cur);

        ret_val = htmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename);
        des_xmlDocPtr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif
#endif

    return(ret);
}


static int
test_htmlSaveFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the document encoding */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename);
        cur = gen_xmlDocPtr(n_cur);
        encoding = gen_const_char_ptr(n_encoding);

        ret_val = htmlSaveFileEnc(filename, cur, encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename);
        des_xmlDocPtr(n_cur, cur);
        des_const_char_ptr(n_encoding, encoding);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif
#endif

    return(ret);
}


static int
test_htmlSaveFileFormat(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the document encoding */
    int n_encoding;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename);
        cur = gen_xmlDocPtr(n_cur);
        encoding = gen_const_char_ptr(n_encoding);
        format = gen_int(n_format);

        ret_val = htmlSaveFileFormat(filename, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename);
        des_xmlDocPtr(n_cur, cur);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_format, format);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileFormat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif
#endif

    return(ret);
}


static int
test_htmlSetMetaEncoding(void) {
    int ret = 0;

#ifdef LIBXML_HTML_ENABLED
    int mem_base;
    int ret_val;
    htmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * encoding; /* the encoding string */
    int n_encoding;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_xmlChar_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        encoding = gen_const_xmlChar_ptr(n_encoding);

        ret_val = htmlSetMetaEncoding(doc, encoding);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_encoding, encoding);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSetMetaEncoding",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}

static int
test_HTMLtree(void) {
    int ret = 0;

    printf("Testing HTMLtree ...\n");
    ret += test_htmlDocContentDumpFormatOutput();
    ret += test_htmlDocContentDumpOutput();
    ret += test_htmlDocDump();
    ret += test_htmlDocDumpMemory();
    ret += test_htmlGetMetaEncoding();
    ret += test_htmlIsBooleanAttr();
    ret += test_htmlNewDoc();
    ret += test_htmlNewDocNoDtD();
    ret += test_htmlNodeDump();
    ret += test_htmlNodeDumpFile();
    ret += test_htmlNodeDumpFileFormat();
    ret += test_htmlNodeDumpFormatOutput();
    ret += test_htmlNodeDumpOutput();
    ret += test_htmlSaveFile();
    ret += test_htmlSaveFileEnc();
    ret += test_htmlSaveFileFormat();
    ret += test_htmlSetMetaEncoding();

    if (ret != 0)
	printf("Module HTMLtree: %d errors\n", ret);
    return(ret);
}

static int
test_xmlC14NDocDumpMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlC14NDocSave(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlC14NDocSaveTo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlC14NExecute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_c14n(void) {
    int ret = 0;

    printf("Testing c14n ...\n");
    ret += test_xmlC14NDocDumpMemory();
    ret += test_xmlC14NDocSave();
    ret += test_xmlC14NDocSaveTo();
    ret += test_xmlC14NExecute();

    if (ret != 0)
	printf("Module c14n: %d errors\n", ret);
    return(ret);
}

static int
test_xmlACatalogAdd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogRemove(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolve(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolvePublic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolveSystem(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlACatalogResolveURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogAdd(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * type; /* the type of record to add to the catalog */
    int n_type;
    const xmlChar * orig; /* the system, public or prefix to match */
    int n_orig;
    const xmlChar * replace; /* the replacement value for the match */
    int n_replace;

    for (n_type = 0;n_type < gen_nb_const_xmlChar_ptr;n_type++) {
    for (n_orig = 0;n_orig < gen_nb_const_xmlChar_ptr;n_orig++) {
    for (n_replace = 0;n_replace < gen_nb_const_xmlChar_ptr;n_replace++) {
        mem_base = xmlMemBlocks();
        type = gen_const_xmlChar_ptr(n_type);
        orig = gen_const_xmlChar_ptr(n_orig);
        replace = gen_const_xmlChar_ptr(n_replace);

        ret_val = xmlCatalogAdd(type, orig, replace);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_type, type);
        des_const_xmlChar_ptr(n_orig, orig);
        des_const_xmlChar_ptr(n_replace, replace);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogAdd",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_type);
            printf(" %d", n_orig);
            printf(" %d", n_replace);
            printf("\n");
        }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlCatalogAddLocal(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogCleanup(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED


        xmlCatalogCleanup();
        call_tests++;
        xmlResetLastError();
#endif

    return(ret);
}


static int
test_xmlCatalogConvert(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;


        ret_val = xmlCatalogConvert();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
#endif

    return(ret);
}


static int
test_xmlCatalogDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogGetDefaults(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogGetPublic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogGetSystem(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogIsEmpty(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogLocalResolve(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogLocalResolveURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogRemove(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;
    const xmlChar * value; /* the value to remove */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlCatalogRemove(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
    }
#endif

    return(ret);
}


static int
test_xmlCatalogResolve(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * pubID; /* the public ID string */
    int n_pubID;
    const xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID);
        sysID = gen_const_xmlChar_ptr(n_sysID);

        ret_val = xmlCatalogResolve(pubID, sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, pubID);
        des_const_xmlChar_ptr(n_sysID, sysID);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlCatalogResolvePublic(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * pubID; /* the public ID string */
    int n_pubID;

    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID);

        ret_val = xmlCatalogResolvePublic(pubID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, pubID);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolvePublic",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pubID);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlCatalogResolveSystem(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * sysID; /* the system ID string */
    int n_sysID;

    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
        mem_base = xmlMemBlocks();
        sysID = gen_const_xmlChar_ptr(n_sysID);

        ret_val = xmlCatalogResolveSystem(sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_sysID, sysID);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveSystem",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlCatalogResolveURI(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * URI; /* the URI */
    int n_URI;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI);

        ret_val = xmlCatalogResolveURI(URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlCatalogSetDebug(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    int ret_val;
    int level; /* the debug level of catalogs required */
    int n_level;

    for (n_level = 0;n_level < gen_nb_int;n_level++) {
        mem_base = xmlMemBlocks();
        level = gen_int(n_level);

        ret_val = xmlCatalogSetDebug(level);
        desret_int(ret_val);
        call_tests++;
        des_int(n_level, level);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogSetDebug",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_level);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlCatalogSetDefaultPrefer(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCatalogSetDefaults(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlConvertSGMLCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlInitializeCatalog(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializeCatalog();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializeCatalog",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlLoadACatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlLoadCatalog(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int ret_val;
    const char * filename; /* a file path */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        filename = gen_filepath(n_filename);

        ret_val = xmlLoadCatalog(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
    }
#endif

    return(ret);
}


static int
test_xmlLoadCatalogs(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    const char * pathss; /* a list of directories separated by a colon or a space. */
    int n_pathss;

    for (n_pathss = 0;n_pathss < gen_nb_const_char_ptr;n_pathss++) {
        pathss = gen_const_char_ptr(n_pathss);

        xmlLoadCatalogs(pathss);
        call_tests++;
        des_const_char_ptr(n_pathss, pathss);
        xmlResetLastError();
    }
#endif

    return(ret);
}


static int
test_xmlLoadSGMLSuperCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewCatalog(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseCatalogFile(void) {
    int ret = 0;

#ifdef LIBXML_CATALOG_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);

        ret_val = xmlParseCatalogFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCatalogFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    return(ret);
}

static int
test_catalog(void) {
    int ret = 0;

    printf("Testing catalog ...\n");
    ret += test_xmlACatalogAdd();
    ret += test_xmlACatalogDump();
    ret += test_xmlACatalogRemove();
    ret += test_xmlACatalogResolve();
    ret += test_xmlACatalogResolvePublic();
    ret += test_xmlACatalogResolveSystem();
    ret += test_xmlACatalogResolveURI();
    ret += test_xmlCatalogAdd();
    ret += test_xmlCatalogAddLocal();
    ret += test_xmlCatalogCleanup();
    ret += test_xmlCatalogConvert();
    ret += test_xmlCatalogDump();
    ret += test_xmlCatalogGetDefaults();
    ret += test_xmlCatalogGetPublic();
    ret += test_xmlCatalogGetSystem();
    ret += test_xmlCatalogIsEmpty();
    ret += test_xmlCatalogLocalResolve();
    ret += test_xmlCatalogLocalResolveURI();
    ret += test_xmlCatalogRemove();
    ret += test_xmlCatalogResolve();
    ret += test_xmlCatalogResolvePublic();
    ret += test_xmlCatalogResolveSystem();
    ret += test_xmlCatalogResolveURI();
    ret += test_xmlCatalogSetDebug();
    ret += test_xmlCatalogSetDefaultPrefer();
    ret += test_xmlCatalogSetDefaults();
    ret += test_xmlConvertSGMLCatalog();
    ret += test_xmlInitializeCatalog();
    ret += test_xmlLoadACatalog();
    ret += test_xmlLoadCatalog();
    ret += test_xmlLoadCatalogs();
    ret += test_xmlLoadSGMLSuperCatalog();
    ret += test_xmlNewCatalog();
    ret += test_xmlParseCatalogFile();

    if (ret != 0)
	printf("Module catalog: %d errors\n", ret);
    return(ret);
}

static int
test_xmlCharInRange(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsBaseChar(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsBlank(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsChar(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsCombining(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsDigit(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsExtender(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsIdeographic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsPubidChar(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_chvalid(void) {
    int ret = 0;

    printf("Testing chvalid ...\n");
    ret += test_xmlCharInRange();
    ret += test_xmlIsBaseChar();
    ret += test_xmlIsBlank();
    ret += test_xmlIsChar();
    ret += test_xmlIsCombining();
    ret += test_xmlIsDigit();
    ret += test_xmlIsExtender();
    ret += test_xmlIsIdeographic();
    ret += test_xmlIsPubidChar();

    if (ret != 0)
	printf("Module chvalid: %d errors\n", ret);
    return(ret);
}

static int
test_xmlDictCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDictCreateSub(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDictLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDictOwns(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDictQLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDictReference(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDictSize(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_dict(void) {
    int ret = 0;

    printf("Testing dict ...\n");
    ret += test_xmlDictCreate();
    ret += test_xmlDictCreateSub();
    ret += test_xmlDictLookup();
    ret += test_xmlDictOwns();
    ret += test_xmlDictQLookup();
    ret += test_xmlDictReference();
    ret += test_xmlDictSize();

    if (ret != 0)
	printf("Module dict: %d errors\n", ret);
    return(ret);
}

static int
test_UTF8Toisolat1(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_isolat1ToUTF8(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddEncodingAlias(void) {
    int ret = 0;

    int ret_val;
    const char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
    int n_name;
    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        name = gen_const_char_ptr(n_name);
        alias = gen_const_char_ptr(n_alias);

        ret_val = xmlAddEncodingAlias(name, alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_name, name);
        des_const_char_ptr(n_alias, alias);
        xmlResetLastError();
    }
    }

    return(ret);
}


static int
test_xmlCharEncCloseFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCharEncFirstLine(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCharEncInFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCharEncOutFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCleanupCharEncodingHandlers(void) {
    int ret = 0;



        xmlCleanupCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();

    return(ret);
}


static int
test_xmlCleanupEncodingAliases(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupEncodingAliases();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupEncodingAliases",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}


static int
test_xmlDelEncodingAlias(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias);

        ret_val = xmlDelEncodingAlias(alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, alias);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDelEncodingAlias",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlDetectCharEncoding(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlFindCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCharEncodingName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetEncodingAlias(void) {
    int ret = 0;

    int mem_base;
    const char * ret_val;
    const char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
    int n_alias;

    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias);

        ret_val = xmlGetEncodingAlias(alias);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, alias);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetEncodingAlias",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlInitCharEncodingHandlers(void) {
    int ret = 0;



        xmlInitCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();

    return(ret);
}


static int
test_xmlNewCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseCharEncoding(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegisterCharEncodingHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_encoding(void) {
    int ret = 0;

    printf("Testing encoding ...\n");
    ret += test_UTF8Toisolat1();
    ret += test_isolat1ToUTF8();
    ret += test_xmlAddEncodingAlias();
    ret += test_xmlCharEncCloseFunc();
    ret += test_xmlCharEncFirstLine();
    ret += test_xmlCharEncInFunc();
    ret += test_xmlCharEncOutFunc();
    ret += test_xmlCleanupCharEncodingHandlers();
    ret += test_xmlCleanupEncodingAliases();
    ret += test_xmlDelEncodingAlias();
    ret += test_xmlDetectCharEncoding();
    ret += test_xmlFindCharEncodingHandler();
    ret += test_xmlGetCharEncodingHandler();
    ret += test_xmlGetCharEncodingName();
    ret += test_xmlGetEncodingAlias();
    ret += test_xmlInitCharEncodingHandlers();
    ret += test_xmlNewCharEncodingHandler();
    ret += test_xmlParseCharEncoding();
    ret += test_xmlRegisterCharEncodingHandler();

    if (ret != 0)
	printf("Module encoding: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddDocEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddDtdEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCleanupPredefinedEntities(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupPredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupPredefinedEntities",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}


static int
test_xmlCopyEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpEntitiesTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpEntityDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlEncodeEntities(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlEncodeEntitiesReentrant(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document containing the string */
    int n_doc;
    const xmlChar * input; /* A string to convert to XML. */
    int n_input;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        input = gen_const_xmlChar_ptr(n_input);

        ret_val = xmlEncodeEntitiesReentrant(doc, input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_input, input);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeEntitiesReentrant",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlEncodeSpecialChars(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document containing the string */
    int n_doc;
    const xmlChar * input; /* A string to convert to XML. */
    int n_input;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        input = gen_const_xmlChar_ptr(n_input);

        ret_val = xmlEncodeSpecialChars(doc, input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_input, input);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeSpecialChars",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlGetDocEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetParameterEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetPredefinedEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlInitializePredefinedEntities(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializePredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializePredefinedEntities",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}

static int
test_entities(void) {
    int ret = 0;

    printf("Testing entities ...\n");
    ret += test_xmlAddDocEntity();
    ret += test_xmlAddDtdEntity();
    ret += test_xmlCleanupPredefinedEntities();
    ret += test_xmlCopyEntitiesTable();
    ret += test_xmlCreateEntitiesTable();
    ret += test_xmlDumpEntitiesTable();
    ret += test_xmlDumpEntityDecl();
    ret += test_xmlEncodeEntities();
    ret += test_xmlEncodeEntitiesReentrant();
    ret += test_xmlEncodeSpecialChars();
    ret += test_xmlGetDocEntity();
    ret += test_xmlGetDtdEntity();
    ret += test_xmlGetParameterEntity();
    ret += test_xmlGetPredefinedEntity();
    ret += test_xmlInitializePredefinedEntities();

    if (ret != 0)
	printf("Module entities: %d errors\n", ret);
    return(ret);
}

static int
test_xmlHashAddEntry(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashAddEntry2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashAddEntry3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashCopy(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashLookup2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashLookup3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashQLookup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashQLookup2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashQLookup3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashRemoveEntry(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashRemoveEntry2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashRemoveEntry3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScan(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScan3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScanFull(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashScanFull3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashSize(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashUpdateEntry(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashUpdateEntry2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHashUpdateEntry3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_hash(void) {
    int ret = 0;

    printf("Testing hash ...\n");
    ret += test_xmlHashAddEntry();
    ret += test_xmlHashAddEntry2();
    ret += test_xmlHashAddEntry3();
    ret += test_xmlHashCopy();
    ret += test_xmlHashCreate();
    ret += test_xmlHashLookup();
    ret += test_xmlHashLookup2();
    ret += test_xmlHashLookup3();
    ret += test_xmlHashQLookup();
    ret += test_xmlHashQLookup2();
    ret += test_xmlHashQLookup3();
    ret += test_xmlHashRemoveEntry();
    ret += test_xmlHashRemoveEntry2();
    ret += test_xmlHashRemoveEntry3();
    ret += test_xmlHashScan();
    ret += test_xmlHashScan3();
    ret += test_xmlHashScanFull();
    ret += test_xmlHashScanFull3();
    ret += test_xmlHashSize();
    ret += test_xmlHashUpdateEntry();
    ret += test_xmlHashUpdateEntry2();
    ret += test_xmlHashUpdateEntry3();

    if (ret != 0)
	printf("Module hash: %d errors\n", ret);
    return(ret);
}

static int
test_xmlLinkGetData(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListAppend(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListClear(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListCopy(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListDelete(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListDup(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListEmpty(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListEnd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListFront(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListInsert(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListMerge(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListPopBack(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListPopFront(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListPushBack(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListPushFront(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListRemoveAll(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListRemoveFirst(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListRemoveLast(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListReverse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListReverseSearch(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListReverseWalk(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListSearch(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListSize(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListSort(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlListWalk(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_list(void) {
    int ret = 0;

    printf("Testing list ...\n");
    ret += test_xmlLinkGetData();
    ret += test_xmlListAppend();
    ret += test_xmlListClear();
    ret += test_xmlListCopy();
    ret += test_xmlListCreate();
    ret += test_xmlListDelete();
    ret += test_xmlListDup();
    ret += test_xmlListEmpty();
    ret += test_xmlListEnd();
    ret += test_xmlListFront();
    ret += test_xmlListInsert();
    ret += test_xmlListMerge();
    ret += test_xmlListPopBack();
    ret += test_xmlListPopFront();
    ret += test_xmlListPushBack();
    ret += test_xmlListPushFront();
    ret += test_xmlListRemoveAll();
    ret += test_xmlListRemoveFirst();
    ret += test_xmlListRemoveLast();
    ret += test_xmlListReverse();
    ret += test_xmlListReverseSearch();
    ret += test_xmlListReverseWalk();
    ret += test_xmlListSearch();
    ret += test_xmlListSize();
    ret += test_xmlListSort();
    ret += test_xmlListWalk();

    if (ret != 0)
	printf("Module list: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNanoFTPCheckResponse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPCleanup(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCleanup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlNanoFTPClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPCloseConnection(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPConnect(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPConnectTo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPCwd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPDele(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGetConnection(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGetResponse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPGetSocket(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPInit(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlNanoFTPList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPNewCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPOpen(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPProxy(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    const char * host; /* the proxy host name */
    int n_host;
    int port; /* the proxy port */
    int n_port;
    const char * user; /* the proxy user name */
    int n_user;
    const char * passwd; /* the proxy password */
    int n_passwd;
    int type; /* the type of proxy 1 for using SITE, 2 for USER a@b */
    int n_type;

    for (n_host = 0;n_host < gen_nb_const_char_ptr;n_host++) {
    for (n_port = 0;n_port < gen_nb_int;n_port++) {
    for (n_user = 0;n_user < gen_nb_const_char_ptr;n_user++) {
    for (n_passwd = 0;n_passwd < gen_nb_const_char_ptr;n_passwd++) {
    for (n_type = 0;n_type < gen_nb_int;n_type++) {
        host = gen_const_char_ptr(n_host);
        port = gen_int(n_port);
        user = gen_const_char_ptr(n_user);
        passwd = gen_const_char_ptr(n_passwd);
        type = gen_int(n_type);

        xmlNanoFTPProxy(host, port, user, passwd, type);
        call_tests++;
        des_const_char_ptr(n_host, host);
        des_int(n_port, port);
        des_const_char_ptr(n_user, user);
        des_const_char_ptr(n_passwd, passwd);
        des_int(n_type, type);
        xmlResetLastError();
    }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlNanoFTPQuit(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoFTPScanProxy(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    const char * URL; /* The proxy URL used to initialize the proxy context */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        URL = gen_filepath(n_URL);

        xmlNanoFTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL);
        xmlResetLastError();
    }
#endif

    return(ret);
}


static int
test_xmlNanoFTPUpdateURL(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_nanoftp(void) {
    int ret = 0;

    printf("Testing nanoftp ...\n");
    ret += test_xmlNanoFTPCheckResponse();
    ret += test_xmlNanoFTPCleanup();
    ret += test_xmlNanoFTPClose();
    ret += test_xmlNanoFTPCloseConnection();
    ret += test_xmlNanoFTPConnect();
    ret += test_xmlNanoFTPConnectTo();
    ret += test_xmlNanoFTPCwd();
    ret += test_xmlNanoFTPDele();
    ret += test_xmlNanoFTPGet();
    ret += test_xmlNanoFTPGetConnection();
    ret += test_xmlNanoFTPGetResponse();
    ret += test_xmlNanoFTPGetSocket();
    ret += test_xmlNanoFTPInit();
    ret += test_xmlNanoFTPList();
    ret += test_xmlNanoFTPNewCtxt();
    ret += test_xmlNanoFTPOpen();
    ret += test_xmlNanoFTPProxy();
    ret += test_xmlNanoFTPQuit();
    ret += test_xmlNanoFTPRead();
    ret += test_xmlNanoFTPScanProxy();
    ret += test_xmlNanoFTPUpdateURL();

    if (ret != 0)
	printf("Module nanoftp: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNanoHTTPAuthHeader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPCleanup(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPCleanup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlNanoHTTPClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPContentLength(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPEncoding(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPFetch(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPInit(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlNanoHTTPMethod(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPMethodRedir(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPMimeType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPOpen(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPOpenRedir(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPRedir(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPReturnCode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPSave(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNanoHTTPScanProxy(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    const char * URL; /* The proxy URL used to initialize the proxy context */
    int n_URL;

    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
        URL = gen_filepath(n_URL);

        xmlNanoHTTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL);
        xmlResetLastError();
    }
#endif

    return(ret);
}

static int
test_nanohttp(void) {
    int ret = 0;

    printf("Testing nanohttp ...\n");
    ret += test_xmlNanoHTTPAuthHeader();
    ret += test_xmlNanoHTTPCleanup();
    ret += test_xmlNanoHTTPClose();
    ret += test_xmlNanoHTTPContentLength();
    ret += test_xmlNanoHTTPEncoding();
    ret += test_xmlNanoHTTPFetch();
    ret += test_xmlNanoHTTPInit();
    ret += test_xmlNanoHTTPMethod();
    ret += test_xmlNanoHTTPMethodRedir();
    ret += test_xmlNanoHTTPMimeType();
    ret += test_xmlNanoHTTPOpen();
    ret += test_xmlNanoHTTPOpenRedir();
    ret += test_xmlNanoHTTPRead();
    ret += test_xmlNanoHTTPRedir();
    ret += test_xmlNanoHTTPReturnCode();
    ret += test_xmlNanoHTTPSave();
    ret += test_xmlNanoHTTPScanProxy();

    if (ret != 0)
	printf("Module nanohttp: %d errors\n", ret);
    return(ret);
}

static int
test_xmlByteConsumed(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlClearNodeInfoSeq(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlClearParserCtxt(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        xmlClearParserCtxt(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlClearParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlCreateDocParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateIOParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreatePushParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCtxtReadDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        cur = gen_const_xmlChar_ptr(n_cur);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = xmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_xmlChar_ptr(n_cur, cur);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }

    return(ret);
}


static int
test_xmlCtxtReadFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        filename = gen_filepath(n_filename);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = xmlCtxtReadFile(ctxt, filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_filepath(n_filename, filename);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }

    return(ret);
}


static int
test_xmlCtxtReadIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCtxtReadMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        buffer = gen_const_char_ptr(n_buffer);
        size = gen_int(n_size);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = xmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_char_ptr(n_buffer, buffer);
        des_int(n_size, size);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }

    return(ret);
}


static int
test_xmlCtxtReset(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        xmlCtxtReset(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReset",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlCtxtResetPush(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * chunk; /* a pointer to an array of chars */
    int n_chunk;
    int size; /* number of chars in the array */
    int n_size;
    const char * filename; /* an optional file name or URI */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        chunk = gen_const_char_ptr(n_chunk);
        size = gen_int(n_size);
        filename = gen_filepath(n_filename);
        encoding = gen_const_char_ptr(n_encoding);

        ret_val = xmlCtxtResetPush(ctxt, chunk, size, filename, encoding);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_char_ptr(n_chunk, chunk);
        des_int(n_size, size);
        des_filepath(n_filename, filename);
        des_const_char_ptr(n_encoding, encoding);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtResetPush",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    }

    return(ret);
}


static int
test_xmlCtxtUseOptions(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        options = gen_int(n_options);

        ret_val = xmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtUseOptions",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlGetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetFeature(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetFeaturesList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOParseDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlInitNodeInfoSeq(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlInitParser(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitParser();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParser",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}


static int
test_xmlInitParserCtxt(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        ret_val = xmlInitParserCtxt(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParserCtxt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlKeepBlanksDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val);

        ret_val = xmlKeepBlanksDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlKeepBlanksDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlLineNumbersDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val);

        ret_val = xmlLineNumbersDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLineNumbersDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlLoadExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewIOInputStream(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseBalancedChunkMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseBalancedChunkMemoryRecover(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseChunk(void) {
    int ret = 0;

#ifdef LIBXML_PUSH_ENABLED
    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const char * chunk; /* an char array */
    int n_chunk;
    int size; /* the size in byte of the chunk */
    int n_size;
    int terminate; /* last chunk indicator */
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        chunk = gen_const_char_ptr(n_chunk);
        size = gen_int(n_size);
        terminate = gen_int(n_terminate);

        ret_val = xmlParseChunk(ctxt, chunk, size, terminate);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_char_ptr(n_chunk, chunk);
        des_int(n_size, size);
        des_int(n_terminate, terminate);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseChunk",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlParseCtxtExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur);

        ret_val = xmlParseDoc(cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlParseDocument(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        ret_val = xmlParseDocument(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDocument",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlParseEntity(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);

        ret_val = xmlParseEntity(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseEntity",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlParseExtParsedEnt(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        ret_val = xmlParseExtParsedEnt(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseExtParsedEnt",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlParseExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);

        ret_val = xmlParseFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlParseInNodeContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer);
        size = gen_int(n_size);

        ret_val = xmlParseMemory(buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer);
        des_int(n_size, size);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlParserAddNodeInfo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserFindNodeInfo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserFindNodeInfoIndex(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputGrow(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlPedanticParserDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val);

        ret_val = xmlPedanticParserDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPedanticParserDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlReadDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const xmlChar * cur; /* a pointer to a zero terminated string */
    int n_cur;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = xmlReadDoc(cur, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }

    return(ret);
}


static int
test_xmlReadFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* a file or URL */
    int n_filename;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = xmlReadFile(filename, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlReadIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReadMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * buffer; /* a pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;
    const char * URL; /* the base URL to use for the document */
    int n_URL;
    const char * encoding; /* the document encoding, or NULL */
    int n_encoding;
    int options; /* a combination of xmlParserOption */
    int n_options;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_options = 0;n_options < gen_nb_int;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer);
        size = gen_int(n_size);
        URL = gen_filepath(n_URL);
        encoding = gen_const_char_ptr(n_encoding);
        options = gen_int(n_options);

        ret_val = xmlReadMemory(buffer, size, URL, encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer);
        des_int(n_size, size);
        des_filepath(n_URL, URL);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_options, options);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }

    return(ret);
}


static int
test_xmlRecoverDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur; /* a pointer to an array of xmlChar */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur);

        ret_val = xmlRecoverDoc(cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlRecoverFile(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename; /* the filename */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);

        ret_val = xmlRecoverFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlRecoverMemory(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * buffer; /* an pointer to a char array */
    int n_buffer;
    int size; /* the size of the array */
    int n_size;

    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    for (n_size = 0;n_size < gen_nb_int;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer);
        size = gen_int(n_size);

        ret_val = xmlRecoverMemory(buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, buffer);
        des_int(n_size, size);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverMemory",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlSAXParseDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXParseDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXParseEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXParseFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXParseFileWithData(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXParseMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXParseMemoryWithData(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXUserParseFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSAXUserParseMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetFeature(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetupParserForBuffer(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;
    const xmlChar * buffer; /* a xmlChar * buffer */
    int n_buffer;
    const char * filename; /* a file name */
    int n_filename;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    for (n_buffer = 0;n_buffer < gen_nb_const_xmlChar_ptr;n_buffer++) {
    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);
        buffer = gen_const_xmlChar_ptr(n_buffer);
        filename = gen_filepath(n_filename);

        xmlSetupParserForBuffer(ctxt, buffer, filename);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        des_const_xmlChar_ptr(n_buffer, buffer);
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetupParserForBuffer",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlStopParser(void) {
    int ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt; /* an XML parser context */
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt);

        xmlStopParser(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStopParser",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlSubstituteEntitiesDefault(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    int val; /* int 0 or 1 */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val);

        ret_val = xmlSubstituteEntitiesDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSubstituteEntitiesDefault",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }

    return(ret);
}

static int
test_parser(void) {
    int ret = 0;

    printf("Testing parser ...\n");
    ret += test_xmlByteConsumed();
    ret += test_xmlClearNodeInfoSeq();
    ret += test_xmlClearParserCtxt();
    ret += test_xmlCreateDocParserCtxt();
    ret += test_xmlCreateIOParserCtxt();
    ret += test_xmlCreatePushParserCtxt();
    ret += test_xmlCtxtReadDoc();
    ret += test_xmlCtxtReadFile();
    ret += test_xmlCtxtReadIO();
    ret += test_xmlCtxtReadMemory();
    ret += test_xmlCtxtReset();
    ret += test_xmlCtxtResetPush();
    ret += test_xmlCtxtUseOptions();
    ret += test_xmlGetExternalEntityLoader();
    ret += test_xmlGetFeature();
    ret += test_xmlGetFeaturesList();
    ret += test_xmlIOParseDTD();
    ret += test_xmlInitNodeInfoSeq();
    ret += test_xmlInitParser();
    ret += test_xmlInitParserCtxt();
    ret += test_xmlKeepBlanksDefault();
    ret += test_xmlLineNumbersDefault();
    ret += test_xmlLoadExternalEntity();
    ret += test_xmlNewIOInputStream();
    ret += test_xmlNewParserCtxt();
    ret += test_xmlParseBalancedChunkMemory();
    ret += test_xmlParseBalancedChunkMemoryRecover();
    ret += test_xmlParseChunk();
    ret += test_xmlParseCtxtExternalEntity();
    ret += test_xmlParseDTD();
    ret += test_xmlParseDoc();
    ret += test_xmlParseDocument();
    ret += test_xmlParseEntity();
    ret += test_xmlParseExtParsedEnt();
    ret += test_xmlParseExternalEntity();
    ret += test_xmlParseFile();
    ret += test_xmlParseInNodeContext();
    ret += test_xmlParseMemory();
    ret += test_xmlParserAddNodeInfo();
    ret += test_xmlParserFindNodeInfo();
    ret += test_xmlParserFindNodeInfoIndex();
    ret += test_xmlParserInputGrow();
    ret += test_xmlParserInputRead();
    ret += test_xmlPedanticParserDefault();
    ret += test_xmlReadDoc();
    ret += test_xmlReadFile();
    ret += test_xmlReadIO();
    ret += test_xmlReadMemory();
    ret += test_xmlRecoverDoc();
    ret += test_xmlRecoverFile();
    ret += test_xmlRecoverMemory();
    ret += test_xmlSAXParseDTD();
    ret += test_xmlSAXParseDoc();
    ret += test_xmlSAXParseEntity();
    ret += test_xmlSAXParseFile();
    ret += test_xmlSAXParseFileWithData();
    ret += test_xmlSAXParseMemory();
    ret += test_xmlSAXParseMemoryWithData();
    ret += test_xmlSAXUserParseFile();
    ret += test_xmlSAXUserParseMemory();
    ret += test_xmlSetExternalEntityLoader();
    ret += test_xmlSetFeature();
    ret += test_xmlSetupParserForBuffer();
    ret += test_xmlStopParser();
    ret += test_xmlSubstituteEntitiesDefault();

    if (ret != 0)
	printf("Module parser: %d errors\n", ret);
    return(ret);
}

static int
test_xmlPatternMatch(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlPatterncompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_pattern(void) {
    int ret = 0;

    printf("Testing pattern ...\n");
    ret += test_xmlPatternMatch();
    ret += test_xmlPatterncompile();

    if (ret != 0)
	printf("Module pattern: %d errors\n", ret);
    return(ret);
}

static int
test_xmlRelaxNGCleanupTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRelaxNGCleanupTypes();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGCleanupTypes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlRelaxNGDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGDumpTree(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGGetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGGetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewDocParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewMemParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGParse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGSetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGSetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidateDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidateFullElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidatePopElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidatePushCData(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxNGValidatePushElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRelaxParserSetFlag(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_relaxng(void) {
    int ret = 0;

    printf("Testing relaxng ...\n");
    ret += test_xmlRelaxNGCleanupTypes();
    ret += test_xmlRelaxNGDump();
    ret += test_xmlRelaxNGDumpTree();
    ret += test_xmlRelaxNGGetParserErrors();
    ret += test_xmlRelaxNGGetValidErrors();
    ret += test_xmlRelaxNGNewDocParserCtxt();
    ret += test_xmlRelaxNGNewMemParserCtxt();
    ret += test_xmlRelaxNGNewParserCtxt();
    ret += test_xmlRelaxNGNewValidCtxt();
    ret += test_xmlRelaxNGParse();
    ret += test_xmlRelaxNGSetParserErrors();
    ret += test_xmlRelaxNGSetValidErrors();
    ret += test_xmlRelaxNGValidateDoc();
    ret += test_xmlRelaxNGValidateFullElement();
    ret += test_xmlRelaxNGValidatePopElement();
    ret += test_xmlRelaxNGValidatePushCData();
    ret += test_xmlRelaxNGValidatePushElement();
    ret += test_xmlRelaxParserSetFlag();

    if (ret != 0)
	printf("Module relaxng: %d errors\n", ret);
    return(ret);
}
static int
test_schemasInternals(void) {
    int ret = 0;

    printf("Testing schemasInternals ...\n");

    if (ret != 0)
	printf("Module schemasInternals: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNodePtr cur; /* the child node */
    int n_cur;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent);
        cur = gen_xmlNodePtr_in(n_cur);

        ret_val = xmlAddChild(parent, cur);
        if (ret_val == NULL) { xmlFreeNode(cur) ; cur = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent);
        des_xmlNodePtr_in(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlAddChildList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;
    xmlNodePtr cur; /* the first node in the list */
    int n_cur;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent);
        cur = gen_xmlNodePtr_in(n_cur);

        ret_val = xmlAddChildList(parent, cur);
        if (ret_val == NULL) { xmlFreeNodeList(cur) ; cur = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent);
        des_xmlNodePtr_in(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChildList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlAddNextSibling(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        elem = gen_xmlNodePtr_in(n_elem);

        ret_val = xmlAddNextSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_xmlNodePtr_in(n_elem, elem);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddNextSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlAddPrevSibling(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        elem = gen_xmlNodePtr_in(n_elem);

        ret_val = xmlAddPrevSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_xmlNodePtr_in(n_elem, elem);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddPrevSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlAddSibling(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur; /* the child node */
    int n_cur;
    xmlNodePtr elem; /* the new node */
    int n_elem;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        elem = gen_xmlNodePtr_in(n_elem);

        ret_val = xmlAddSibling(cur, elem);
        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_xmlNodePtr_in(n_elem, elem);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddSibling",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlAttrSerializeTxtContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferAdd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferAddHead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCCat(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCat(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCreateSize(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferCreateStatic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferEmpty(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferGrow(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferLength(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferResize(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferSetAllocationScheme(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferShrink(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferWriteCHAR(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferWriteChar(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBufferWriteQuotedString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlBuildQName(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * ncname; /* the Name */
    int n_ncname;
    const xmlChar * prefix; /* the prefix */
    int n_prefix;
    xmlChar * memory; /* preallocated memory */
    int n_memory;
    int len; /* preallocated memory length */
    int n_len;

    for (n_ncname = 0;n_ncname < gen_nb_const_xmlChar_ptr;n_ncname++) {
    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    for (n_memory = 0;n_memory < gen_nb_xmlChar_ptr;n_memory++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        ncname = gen_const_xmlChar_ptr(n_ncname);
        prefix = gen_const_xmlChar_ptr(n_prefix);
        memory = gen_xmlChar_ptr(n_memory);
        len = gen_int(n_len);

        ret_val = xmlBuildQName(ncname, prefix, memory, len);
        if ((ret_val != NULL) && (ret_val != ncname) &&
              (ret_val != prefix) && (ret_val != memory))
              xmlFree(ret_val);
	  ret_val = NULL;
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_ncname, ncname);
        des_const_xmlChar_ptr(n_prefix, prefix);
        des_xmlChar_ptr(n_memory, memory);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildQName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_ncname);
            printf(" %d", n_prefix);
            printf(" %d", n_memory);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }

    return(ret);
}


static int
test_xmlCopyDoc(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlDocPtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    int recursive; /* if not zero do a recursive copy. */
    int n_recursive;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_recursive = 0;n_recursive < gen_nb_int;n_recursive++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        recursive = gen_int(n_recursive);

        ret_val = xmlCopyDoc(doc, recursive);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_int(n_recursive, recursive);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_recursive);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlCopyDtd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNamespace(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNamespaceList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNodeList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyPropList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateIntSubset(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocCopyNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocCopyNodeList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDumpFormatMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDumpFormatMemoryEnc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDumpMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocDumpMemoryEnc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocFormatDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDocGetRootElement(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);

        ret_val = xmlDocGetRootElement(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocGetRootElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlDocSetRootElement(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr root; /* the new document root element */
    int n_root;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_root = 0;n_root < gen_nb_xmlNodePtr_in;n_root++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        root = gen_xmlNodePtr_in(n_root);

        ret_val = xmlDocSetRootElement(doc, root);
        if (doc == NULL) { xmlFreeNode(root) ; root = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_xmlNodePtr_in(n_root, root);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocSetRootElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_root);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlElemDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetBufferAllocationScheme(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetCompressMode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlGetCompressMode();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}


static int
test_xmlGetDocCompressMode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);

        ret_val = xmlGetDocCompressMode(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDocCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlGetIntSubset(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetLastChild(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent; /* the parent node */
    int n_parent;

    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent);

        ret_val = xmlGetLastChild(parent);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetLastChild",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_parent);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlGetLineNo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetNoNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = xmlGetNoNsProp(node, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNoNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlGetNodePath(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);

        ret_val = xmlGetNodePath(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNodePath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlGetNsList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetNsProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;
    const xmlChar * nameSpace; /* the URI of the namespace */
    int n_nameSpace;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);
        name = gen_const_xmlChar_ptr(n_name);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace);

        ret_val = xmlGetNsProp(node, name, nameSpace);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        des_const_xmlChar_ptr(n_name, name);
        des_const_xmlChar_ptr(n_nameSpace, nameSpace);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNsProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlGetProp(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = xmlGetProp(node, name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlHasNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlHasProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsBlankNode(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);

        ret_val = xmlIsBlankNode(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBlankNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlIsXHTML(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * systemID; /* the system identifier */
    int n_systemID;
    const xmlChar * publicID; /* the public identifier */
    int n_publicID;

    for (n_systemID = 0;n_systemID < gen_nb_const_xmlChar_ptr;n_systemID++) {
    for (n_publicID = 0;n_publicID < gen_nb_const_xmlChar_ptr;n_publicID++) {
        mem_base = xmlMemBlocks();
        systemID = gen_const_xmlChar_ptr(n_systemID);
        publicID = gen_const_xmlChar_ptr(n_publicID);

        ret_val = xmlIsXHTML(systemID, publicID);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_systemID, systemID);
        des_const_xmlChar_ptr(n_publicID, publicID);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsXHTML",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_systemID);
            printf(" %d", n_publicID);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNewCDataBlock(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the CDATA block content content */
    int n_content;
    int len; /* the length of the block */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        content = gen_const_xmlChar_ptr(n_content);
        len = gen_int(n_len);

        ret_val = xmlNewCDataBlock(doc, content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_content, content);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCDataBlock",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlNewCharRef(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * name; /* the char ref string, starting with # or "&# ... ;" */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = xmlNewCharRef(doc, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCharRef",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNewChild(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewComment(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * content; /* the comment content */
    int n_content;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content);

        ret_val = xmlNewComment(content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlNewDoc(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const xmlChar * version; /* xmlChar string giving the version of XML "1.0" */
    int n_version;

    for (n_version = 0;n_version < gen_nb_const_xmlChar_ptr;n_version++) {
        mem_base = xmlMemBlocks();
        version = gen_const_xmlChar_ptr(n_version);

        ret_val = xmlNewDoc(version);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_version, version);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_version);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlNewDocComment(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the comment content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        content = gen_const_xmlChar_ptr(n_content);

        ret_val = xmlNewDocComment(doc, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocComment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNewDocFragment(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document owning the fragment */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);

        ret_val = xmlNewDocFragment(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocFragment",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlNewDocNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocNodeEatName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocPI(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the target document */
    int n_doc;
    const xmlChar * name; /* the processing instruction name */
    int n_name;
    const xmlChar * content; /* the PI content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        name = gen_const_xmlChar_ptr(n_name);
        content = gen_const_xmlChar_ptr(n_content);

        ret_val = xmlNewDocPI(doc, name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_name, name);
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlNewDocProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocRawNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewDocText(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the text content */
    int n_content;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        content = gen_const_xmlChar_ptr(n_content);

        ret_val = xmlNewDocText(doc, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNewDocTextLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * content; /* the text content */
    int n_content;
    int len; /* the text len. */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        content = gen_const_xmlChar_ptr(n_content);
        len = gen_int(n_len);

        ret_val = xmlNewDocTextLen(doc, content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_content, content);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocTextLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlNewDtd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewGlobalNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNodeEatName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewNsPropEatName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewPI(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * name; /* the processing instruction name */
    int n_name;
    const xmlChar * content; /* the PI content */
    int n_content;

    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name);
        content = gen_const_xmlChar_ptr(n_content);

        ret_val = xmlNewPI(name, content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, name);
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewPI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNewProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewReference(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * name; /* the reference name, or the reference string with & and ; */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = xmlNewReference(doc, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewReference",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNewText(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * content; /* the text content */
    int n_content;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content);

        ret_val = xmlNewText(content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlNewTextChild(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    const xmlChar * content; /* the text content */
    int n_content;
    int len; /* the text len. */
    int n_len;

    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content);
        len = gen_int(n_len);

        ret_val = xmlNewTextLen(content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, content);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNodeAddContent(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* extra content */
    int n_content;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        content = gen_const_xmlChar_ptr(n_content);

        xmlNodeAddContent(cur, content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNodeAddContentLen(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* extra content */
    int n_content;
    int len; /* the size of @content */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        content = gen_const_xmlChar_ptr(n_content);
        len = gen_int(n_len);

        xmlNodeAddContentLen(cur, content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_const_xmlChar_ptr(n_content, content);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContentLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlNodeBufGetContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNodeDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNodeDumpOutput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNodeGetBase(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document the node pertains to */
    int n_doc;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        cur = gen_xmlNodePtr(n_cur);

        ret_val = xmlNodeGetBase(doc, cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_xmlNodePtr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetBase",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNodeGetContent(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur; /* the node being read */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);

        ret_val = xmlNodeGetContent(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlNodeGetLang(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);

        ret_val = xmlNodeGetLang(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlNodeGetSpacePreserve(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr cur; /* the node being checked */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);

        ret_val = xmlNodeGetSpacePreserve(cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetSpacePreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlNodeIsText(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);

        ret_val = xmlNodeIsText(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeIsText",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlNodeListGetRawString(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr list; /* a Node list */
    int n_list;
    int inLine; /* should we replace entity contents or show their external form */
    int n_inLine;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_list = 0;n_list < gen_nb_xmlNodePtr;n_list++) {
    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        list = gen_xmlNodePtr(n_list);
        inLine = gen_int(n_inLine);

        ret_val = xmlNodeListGetRawString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_xmlNodePtr(n_list, list);
        des_int(n_inLine, inLine);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetRawString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlNodeListGetString(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr list; /* a Node list */
    int n_list;
    int inLine; /* should we replace entity contents or show their external form */
    int n_inLine;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_list = 0;n_list < gen_nb_xmlNodePtr;n_list++) {
    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        list = gen_xmlNodePtr(n_list);
        inLine = gen_int(n_inLine);

        ret_val = xmlNodeListGetString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_xmlNodePtr(n_list, list);
        des_int(n_inLine, inLine);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlNodeSetBase(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    const xmlChar * uri; /* the new base URI */
    int n_uri;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_uri = 0;n_uri < gen_nb_const_xmlChar_ptr;n_uri++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        uri = gen_const_xmlChar_ptr(n_uri);

        xmlNodeSetBase(cur, uri);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_const_xmlChar_ptr(n_uri, uri);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetBase",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_uri);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlNodeSetContent(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* the new value of the content */
    int n_content;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        content = gen_const_xmlChar_ptr(n_content);

        xmlNodeSetContent(cur, content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_const_xmlChar_ptr(n_content, content);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContent",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlNodeSetContentLen(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being modified */
    int n_cur;
    const xmlChar * content; /* the new value of the content */
    int n_content;
    int len; /* the size of @content */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        content = gen_const_xmlChar_ptr(n_content);
        len = gen_int(n_len);

        xmlNodeSetContentLen(cur, content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_const_xmlChar_ptr(n_content, content);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContentLen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlNodeSetLang(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    const xmlChar * lang; /* the language description */
    int n_lang;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_lang = 0;n_lang < gen_nb_const_xmlChar_ptr;n_lang++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        lang = gen_const_xmlChar_ptr(n_lang);

        xmlNodeSetLang(cur, lang);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_const_xmlChar_ptr(n_lang, lang);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetLang",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_lang);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlNodeSetName(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    const xmlChar * name; /* the new tag name */
    int n_name;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        name = gen_const_xmlChar_ptr(n_name);

        xmlNodeSetName(cur, name);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlNodeSetSpacePreserve(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr cur; /* the node being changed */
    int n_cur;
    int val; /* the xml:space value ("0": default, 1: "preserve") */
    int n_val;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);
        val = gen_int(n_val);

        xmlNodeSetSpacePreserve(cur, val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        des_int(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetSpacePreserve",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlReconciliateNs(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr tree; /* a node defining the subtree to reconciliate */
    int n_tree;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        tree = gen_xmlNodePtr(n_tree);

        ret_val = xmlReconciliateNs(doc, tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_xmlNodePtr(n_tree, tree);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReconciliateNs",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_tree);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlRemoveProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReplaceNode(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr old; /* the old node */
    int n_old;
    xmlNodePtr cur; /* the node */
    int n_cur;

    for (n_old = 0;n_old < gen_nb_xmlNodePtr;n_old++) {
    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
        mem_base = xmlMemBlocks();
        old = gen_xmlNodePtr(n_old);
        cur = gen_xmlNodePtr_in(n_cur);

        ret_val = xmlReplaceNode(old, cur);
        if ((old == NULL) || (old->parent == NULL)) {
              xmlFreeNode(cur) ; cur = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_old, old);
        des_xmlNodePtr_in(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReplaceNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_old);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlSaveFile(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename);
        cur = gen_xmlDocPtr(n_cur);

        ret_val = xmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename);
        des_xmlDocPtr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlSaveFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    const char * encoding; /* the name of an encoding (or NULL) */
    int n_encoding;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename);
        cur = gen_xmlDocPtr(n_cur);
        encoding = gen_const_char_ptr(n_encoding);

        ret_val = xmlSaveFileEnc(filename, cur, encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename);
        des_xmlDocPtr(n_cur, cur);
        des_const_char_ptr(n_encoding, encoding);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlSaveFileTo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveFormatFile(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename (or URL) */
    int n_filename;
    xmlDocPtr cur; /* the document */
    int n_cur;
    int format; /* should formatting spaces been added */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename);
        cur = gen_xmlDocPtr(n_cur);
        format = gen_int(n_format);

        ret_val = xmlSaveFormatFile(filename, cur, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename);
        des_xmlDocPtr(n_cur, cur);
        des_int(n_format, format);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFile",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlSaveFormatFileEnc(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the filename or URL to output */
    int n_filename;
    xmlDocPtr cur; /* the document being saved */
    int n_cur;
    const char * encoding; /* the name of the encoding to use or NULL. */
    int n_encoding;
    int format; /* should formatting spaces be added. */
    int n_format;

    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    for (n_format = 0;n_format < gen_nb_int;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename);
        cur = gen_xmlDocPtr(n_cur);
        encoding = gen_const_char_ptr(n_encoding);
        format = gen_int(n_format);

        ret_val = xmlSaveFormatFileEnc(filename, cur, encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename);
        des_xmlDocPtr(n_cur, cur);
        des_const_char_ptr(n_encoding, encoding);
        des_int(n_format, format);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFileEnc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlSaveFormatFileTo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSearchNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSearchNsByHref(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetBufferAllocationScheme(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetCompressMode(void) {
    int ret = 0;

    int mem_base;
    int mode; /* the compression ratio */
    int n_mode;

    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
        mem_base = xmlMemBlocks();
        mode = gen_int(n_mode);

        xmlSetCompressMode(mode);
        call_tests++;
        des_int(n_mode, mode);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_mode);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlSetDocCompressMode(void) {
    int ret = 0;

    int mem_base;
    xmlDocPtr doc; /* the document */
    int n_doc;
    int mode; /* the compression ratio */
    int n_mode;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        mode = gen_int(n_mode);

        xmlSetDocCompressMode(doc, mode);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_int(n_mode, mode);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetDocCompressMode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_mode);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlSetListDoc(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr list; /* the first element */
    int n_list;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_list = 0;n_list < gen_nb_xmlNodePtr;n_list++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        list = gen_xmlNodePtr(n_list);
        doc = gen_xmlDocPtr(n_doc);

        xmlSetListDoc(list, doc);
        call_tests++;
        des_xmlNodePtr(n_list, list);
        des_xmlDocPtr(n_doc, doc);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetListDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_list);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlSetNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetTreeDoc(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr tree; /* the top element */
    int n_tree;
    xmlDocPtr doc; /* the document */
    int n_doc;

    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree);
        doc = gen_xmlDocPtr(n_doc);

        xmlSetTreeDoc(tree, doc);
        call_tests++;
        des_xmlNodePtr(n_tree, tree);
        des_xmlDocPtr(n_doc, doc);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetTreeDoc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_tree);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlSplitQName2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSplitQName3(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStringGetNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * value; /* the value of the attribute */
    int n_value;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlStringGetNodeList(doc, value);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringGetNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlStringLenGetNodeList(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * value; /* the value of the text */
    int n_value;
    int len; /* the length of the string value */
    int n_len;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        value = gen_const_xmlChar_ptr(n_value);
        len = gen_int(n_len);

        ret_val = xmlStringLenGetNodeList(doc, value, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_value, value);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringLenGetNodeList",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlTextConcat(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * content; /* the content */
    int n_content;
    int len; /* @content length */
    int n_len;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);
        content = gen_const_xmlChar_ptr(n_content);
        len = gen_int(n_len);

        ret_val = xmlTextConcat(node, content, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        des_const_xmlChar_ptr(n_content, content);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextConcat",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlTextMerge(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr first; /* the first text node */
    int n_first;
    xmlNodePtr second; /* the second text node being merged */
    int n_second;

    for (n_first = 0;n_first < gen_nb_xmlNodePtr_in;n_first++) {
    for (n_second = 0;n_second < gen_nb_xmlNodePtr_in;n_second++) {
        mem_base = xmlMemBlocks();
        first = gen_xmlNodePtr_in(n_first);
        second = gen_xmlNodePtr_in(n_second);

        ret_val = xmlTextMerge(first, second);
        if ((first != NULL) && (first->type != XML_TEXT_NODE)) {
              xmlFreeNode(second) ; second = NULL ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr_in(n_first, first);
        des_xmlNodePtr_in(n_second, second);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextMerge",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_first);
            printf(" %d", n_second);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlUnlinkNode(void) {
    int ret = 0;

    int mem_base;
    xmlNodePtr cur; /* the node */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur);

        xmlUnlinkNode(cur);
        call_tests++;
        des_xmlNodePtr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUnlinkNode",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlUnsetNsProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlUnsetProp(void) {
    int ret = 0;

#ifdef LIBXML_TREE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr node; /* the node */
    int n_node;
    const xmlChar * name; /* the attribute name */
    int n_name;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = xmlUnsetProp(node, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUnsetProp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlValidateNCName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);
        space = gen_int(n_space);

        ret_val = xmlValidateNCName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        des_int(n_space, space);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNCName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlValidateNMToken(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);
        space = gen_int(n_space);

        ret_val = xmlValidateNMToken(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        des_int(n_space, space);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNMToken",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlValidateName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);
        space = gen_int(n_space);

        ret_val = xmlValidateName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        des_int(n_space, space);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlValidateQName(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * value; /* the value to check */
    int n_value;
    int space; /* allow spaces in front and end of the string */
    int n_space;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    for (n_space = 0;n_space < gen_nb_int;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);
        space = gen_int(n_space);

        ret_val = xmlValidateQName(value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        des_int(n_space, space);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateQName",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }

    return(ret);
}

static int
test_tree(void) {
    int ret = 0;

    printf("Testing tree ...\n");
    ret += test_xmlAddChild();
    ret += test_xmlAddChildList();
    ret += test_xmlAddNextSibling();
    ret += test_xmlAddPrevSibling();
    ret += test_xmlAddSibling();
    ret += test_xmlAttrSerializeTxtContent();
    ret += test_xmlBufferAdd();
    ret += test_xmlBufferAddHead();
    ret += test_xmlBufferCCat();
    ret += test_xmlBufferCat();
    ret += test_xmlBufferContent();
    ret += test_xmlBufferCreate();
    ret += test_xmlBufferCreateSize();
    ret += test_xmlBufferCreateStatic();
    ret += test_xmlBufferDump();
    ret += test_xmlBufferEmpty();
    ret += test_xmlBufferGrow();
    ret += test_xmlBufferLength();
    ret += test_xmlBufferResize();
    ret += test_xmlBufferSetAllocationScheme();
    ret += test_xmlBufferShrink();
    ret += test_xmlBufferWriteCHAR();
    ret += test_xmlBufferWriteChar();
    ret += test_xmlBufferWriteQuotedString();
    ret += test_xmlBuildQName();
    ret += test_xmlCopyDoc();
    ret += test_xmlCopyDtd();
    ret += test_xmlCopyNamespace();
    ret += test_xmlCopyNamespaceList();
    ret += test_xmlCopyNode();
    ret += test_xmlCopyNodeList();
    ret += test_xmlCopyProp();
    ret += test_xmlCopyPropList();
    ret += test_xmlCreateIntSubset();
    ret += test_xmlDocCopyNode();
    ret += test_xmlDocCopyNodeList();
    ret += test_xmlDocDump();
    ret += test_xmlDocDumpFormatMemory();
    ret += test_xmlDocDumpFormatMemoryEnc();
    ret += test_xmlDocDumpMemory();
    ret += test_xmlDocDumpMemoryEnc();
    ret += test_xmlDocFormatDump();
    ret += test_xmlDocGetRootElement();
    ret += test_xmlDocSetRootElement();
    ret += test_xmlElemDump();
    ret += test_xmlGetBufferAllocationScheme();
    ret += test_xmlGetCompressMode();
    ret += test_xmlGetDocCompressMode();
    ret += test_xmlGetIntSubset();
    ret += test_xmlGetLastChild();
    ret += test_xmlGetLineNo();
    ret += test_xmlGetNoNsProp();
    ret += test_xmlGetNodePath();
    ret += test_xmlGetNsList();
    ret += test_xmlGetNsProp();
    ret += test_xmlGetProp();
    ret += test_xmlHasNsProp();
    ret += test_xmlHasProp();
    ret += test_xmlIsBlankNode();
    ret += test_xmlIsXHTML();
    ret += test_xmlNewCDataBlock();
    ret += test_xmlNewCharRef();
    ret += test_xmlNewChild();
    ret += test_xmlNewComment();
    ret += test_xmlNewDoc();
    ret += test_xmlNewDocComment();
    ret += test_xmlNewDocFragment();
    ret += test_xmlNewDocNode();
    ret += test_xmlNewDocNodeEatName();
    ret += test_xmlNewDocPI();
    ret += test_xmlNewDocProp();
    ret += test_xmlNewDocRawNode();
    ret += test_xmlNewDocText();
    ret += test_xmlNewDocTextLen();
    ret += test_xmlNewDtd();
    ret += test_xmlNewGlobalNs();
    ret += test_xmlNewNode();
    ret += test_xmlNewNodeEatName();
    ret += test_xmlNewNs();
    ret += test_xmlNewNsProp();
    ret += test_xmlNewNsPropEatName();
    ret += test_xmlNewPI();
    ret += test_xmlNewProp();
    ret += test_xmlNewReference();
    ret += test_xmlNewText();
    ret += test_xmlNewTextChild();
    ret += test_xmlNewTextLen();
    ret += test_xmlNodeAddContent();
    ret += test_xmlNodeAddContentLen();
    ret += test_xmlNodeBufGetContent();
    ret += test_xmlNodeDump();
    ret += test_xmlNodeDumpOutput();
    ret += test_xmlNodeGetBase();
    ret += test_xmlNodeGetContent();
    ret += test_xmlNodeGetLang();
    ret += test_xmlNodeGetSpacePreserve();
    ret += test_xmlNodeIsText();
    ret += test_xmlNodeListGetRawString();
    ret += test_xmlNodeListGetString();
    ret += test_xmlNodeSetBase();
    ret += test_xmlNodeSetContent();
    ret += test_xmlNodeSetContentLen();
    ret += test_xmlNodeSetLang();
    ret += test_xmlNodeSetName();
    ret += test_xmlNodeSetSpacePreserve();
    ret += test_xmlReconciliateNs();
    ret += test_xmlRemoveProp();
    ret += test_xmlReplaceNode();
    ret += test_xmlSaveFile();
    ret += test_xmlSaveFileEnc();
    ret += test_xmlSaveFileTo();
    ret += test_xmlSaveFormatFile();
    ret += test_xmlSaveFormatFileEnc();
    ret += test_xmlSaveFormatFileTo();
    ret += test_xmlSearchNs();
    ret += test_xmlSearchNsByHref();
    ret += test_xmlSetBufferAllocationScheme();
    ret += test_xmlSetCompressMode();
    ret += test_xmlSetDocCompressMode();
    ret += test_xmlSetListDoc();
    ret += test_xmlSetNs();
    ret += test_xmlSetNsProp();
    ret += test_xmlSetProp();
    ret += test_xmlSetTreeDoc();
    ret += test_xmlSplitQName2();
    ret += test_xmlSplitQName3();
    ret += test_xmlStringGetNodeList();
    ret += test_xmlStringLenGetNodeList();
    ret += test_xmlTextConcat();
    ret += test_xmlTextMerge();
    ret += test_xmlUnlinkNode();
    ret += test_xmlUnsetNsProp();
    ret += test_xmlUnsetProp();
    ret += test_xmlValidateNCName();
    ret += test_xmlValidateNMToken();
    ret += test_xmlValidateName();
    ret += test_xmlValidateQName();

    if (ret != 0)
	printf("Module tree: %d errors\n", ret);
    return(ret);
}

static int
test_xmlBuildRelativeURI(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * URI; /* the URI reference under consideration */
    int n_URI;
    const xmlChar * base; /* the base value */
    int n_base;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI);
        base = gen_const_xmlChar_ptr(n_base);

        ret_val = xmlBuildRelativeURI(URI, base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI);
        des_const_xmlChar_ptr(n_base, base);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildRelativeURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlBuildURI(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * URI; /* the URI instance found in the document */
    int n_URI;
    const xmlChar * base; /* the base value */
    int n_base;

    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI);
        base = gen_const_xmlChar_ptr(n_base);

        ret_val = xmlBuildURI(URI, base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, URI);
        des_const_xmlChar_ptr(n_base, base);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildURI",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlCanonicPath(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * path; /* the resource locator in a filesystem notation */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path);

        ret_val = xmlCanonicPath(path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, path);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCanonicPath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlCreateURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNormalizeURIPath(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParseURIReference(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlPrintURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveUri(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlURIEscape(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str; /* the string of the URI to escape */
    int n_str;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str);

        ret_val = xmlURIEscape(str);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscape",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlURIEscapeStr(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str; /* string to escape */
    int n_str;
    const xmlChar * list; /* exception list string of chars not to escape */
    int n_list;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_list = 0;n_list < gen_nb_const_xmlChar_ptr;n_list++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str);
        list = gen_const_xmlChar_ptr(n_list);

        ret_val = xmlURIEscapeStr(str, list);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str);
        des_const_xmlChar_ptr(n_list, list);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscapeStr",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_list);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlURIUnescapeString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_uri(void) {
    int ret = 0;

    printf("Testing uri ...\n");
    ret += test_xmlBuildRelativeURI();
    ret += test_xmlBuildURI();
    ret += test_xmlCanonicPath();
    ret += test_xmlCreateURI();
    ret += test_xmlNormalizeURIPath();
    ret += test_xmlParseURI();
    ret += test_xmlParseURIReference();
    ret += test_xmlPrintURI();
    ret += test_xmlSaveUri();
    ret += test_xmlURIEscape();
    ret += test_xmlURIEscapeStr();
    ret += test_xmlURIUnescapeString();

    if (ret != 0)
	printf("Module uri: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAddAttributeDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddElementDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddID(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddNotationDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAddRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyAttributeTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyElementTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyEnumeration(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyNotationTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCreateEnumeration(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpAttributeDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpAttributeTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpElementDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpElementTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpNotationDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlDumpNotationTable(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdAttrDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdElementDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdNotationDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdQAttrDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetDtdQElementDesc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetID(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetRefs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsID(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIsMixedElement(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    const xmlChar * name; /* the element name */
    int n_name;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        name = gen_const_xmlChar_ptr(n_name);

        ret_val = xmlIsMixedElement(doc, name);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_const_xmlChar_ptr(n_name, name);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsMixedElement",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlIsRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRemoveID(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRemoveRef(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSnprintfElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSprintfElementContent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidBuildContentModel(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidCtxtNormalizeAttributeValue(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidGetPotentialChildren(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidGetValidElements(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidNormalizeAttributeValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc; /* the document */
    int n_doc;
    xmlNodePtr elem; /* the parent */
    int n_elem;
    const xmlChar * name; /* the attribute name */
    int n_name;
    const xmlChar * value; /* the attribute value */
    int n_value;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        elem = gen_xmlNodePtr(n_elem);
        name = gen_const_xmlChar_ptr(n_name);
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlValidNormalizeAttributeValue(doc, elem, name, value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_xmlNodePtr(n_elem, elem);
        des_const_xmlChar_ptr(n_name, name);
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidNormalizeAttributeValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
#endif

    return(ret);
}


static int
test_xmlValidateAttributeDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateAttributeValue(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateDocument(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateDocumentFinal(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateDtd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateDtdFinal(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateElementDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateNameValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Name value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlValidateNameValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNameValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlValidateNamesValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Names value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlValidateNamesValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNamesValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlValidateNmtokenValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Nmtoken value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlValidateNmtokenValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokenValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlValidateNmtokensValue(void) {
    int ret = 0;

#ifdef LIBXML_VALID_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * value; /* an Nmtokens value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlValidateNmtokensValue(value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokensValue",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlValidateNotationDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateNotationUse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateOneAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateOneElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateOneNamespace(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidatePopElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidatePushCData(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidatePushElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlValidateRoot(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_valid(void) {
    int ret = 0;

    printf("Testing valid ...\n");
    ret += test_xmlAddAttributeDecl();
    ret += test_xmlAddElementDecl();
    ret += test_xmlAddID();
    ret += test_xmlAddNotationDecl();
    ret += test_xmlAddRef();
    ret += test_xmlCopyAttributeTable();
    ret += test_xmlCopyElementContent();
    ret += test_xmlCopyElementTable();
    ret += test_xmlCopyEnumeration();
    ret += test_xmlCopyNotationTable();
    ret += test_xmlCreateEnumeration();
    ret += test_xmlDumpAttributeDecl();
    ret += test_xmlDumpAttributeTable();
    ret += test_xmlDumpElementDecl();
    ret += test_xmlDumpElementTable();
    ret += test_xmlDumpNotationDecl();
    ret += test_xmlDumpNotationTable();
    ret += test_xmlGetDtdAttrDesc();
    ret += test_xmlGetDtdElementDesc();
    ret += test_xmlGetDtdNotationDesc();
    ret += test_xmlGetDtdQAttrDesc();
    ret += test_xmlGetDtdQElementDesc();
    ret += test_xmlGetID();
    ret += test_xmlGetRefs();
    ret += test_xmlIsID();
    ret += test_xmlIsMixedElement();
    ret += test_xmlIsRef();
    ret += test_xmlNewElementContent();
    ret += test_xmlNewValidCtxt();
    ret += test_xmlRemoveID();
    ret += test_xmlRemoveRef();
    ret += test_xmlSnprintfElementContent();
    ret += test_xmlSprintfElementContent();
    ret += test_xmlValidBuildContentModel();
    ret += test_xmlValidCtxtNormalizeAttributeValue();
    ret += test_xmlValidGetPotentialChildren();
    ret += test_xmlValidGetValidElements();
    ret += test_xmlValidNormalizeAttributeValue();
    ret += test_xmlValidateAttributeDecl();
    ret += test_xmlValidateAttributeValue();
    ret += test_xmlValidateDocument();
    ret += test_xmlValidateDocumentFinal();
    ret += test_xmlValidateDtd();
    ret += test_xmlValidateDtdFinal();
    ret += test_xmlValidateElement();
    ret += test_xmlValidateElementDecl();
    ret += test_xmlValidateNameValue();
    ret += test_xmlValidateNamesValue();
    ret += test_xmlValidateNmtokenValue();
    ret += test_xmlValidateNmtokensValue();
    ret += test_xmlValidateNotationDecl();
    ret += test_xmlValidateNotationUse();
    ret += test_xmlValidateOneAttribute();
    ret += test_xmlValidateOneElement();
    ret += test_xmlValidateOneNamespace();
    ret += test_xmlValidatePopElement();
    ret += test_xmlValidatePushCData();
    ret += test_xmlValidatePushElement();
    ret += test_xmlValidateRoot();

    if (ret != 0)
	printf("Module valid: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXIncludeNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXIncludeProcess(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* an XML document */
    int n_doc;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);

        ret_val = xmlXIncludeProcess(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcess",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlXIncludeProcessFlags(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlDocPtr doc; /* an XML document */
    int n_doc;
    int flags; /* a set of xmlParserOption used for parsing XML includes */
    int n_flags;

    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc);
        flags = gen_int(n_flags);

        ret_val = xmlXIncludeProcessFlags(doc, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc);
        des_int(n_flags, flags);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessFlags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_doc);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlXIncludeProcessNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXIncludeProcessTree(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr tree; /* a node in an XML document */
    int n_tree;

    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree);

        ret_val = xmlXIncludeProcessTree(tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTree",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_tree);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlXIncludeProcessTreeFlags(void) {
    int ret = 0;

#ifdef LIBXML_XINCLUDE_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr tree; /* a node in an XML document */
    int n_tree;
    int flags; /* a set of xmlParserOption used for parsing XML includes */
    int n_flags;

    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree);
        flags = gen_int(n_flags);

        ret_val = xmlXIncludeProcessTreeFlags(tree, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree);
        des_int(n_flags, flags);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTreeFlags",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_tree);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlXIncludeSetFlags(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xinclude(void) {
    int ret = 0;

    printf("Testing xinclude ...\n");
    ret += test_xmlXIncludeNewContext();
    ret += test_xmlXIncludeProcess();
    ret += test_xmlXIncludeProcessFlags();
    ret += test_xmlXIncludeProcessNode();
    ret += test_xmlXIncludeProcessTree();
    ret += test_xmlXIncludeProcessTreeFlags();
    ret += test_xmlXIncludeSetFlags();

    if (ret != 0)
	printf("Module xinclude: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAllocOutputBuffer(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAllocParserInputBuffer(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCheckFilename(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const char * path; /* the path to check */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_char_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_char_ptr(n_path);

        ret_val = xmlCheckFilename(path);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_path, path);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckFilename",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlCheckHTTPInput(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCleanupInputCallbacks(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}


static int
test_xmlCleanupOutputCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupOutputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlFileClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlFileMatch(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);

        ret_val = xmlFileMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlFileOpen(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlFileRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOFTPClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOFTPMatch(void) {
    int ret = 0;

#ifdef LIBXML_FTP_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);

        ret_val = xmlIOFTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlIOFTPOpen(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOFTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOHTTPClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOHTTPMatch(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;
    int ret_val;
    const char * filename; /* the URI for matching */
    int n_filename;

    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename);

        ret_val = xmlIOHTTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPMatch",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlIOHTTPOpen(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOHTTPOpenW(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlIOHTTPRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNoNetExternalEntityLoader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNormalizeWindowsPath(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * path; /* the input file path */
    int n_path;

    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path);

        ret_val = xmlNormalizeWindowsPath(path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, path);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNormalizeWindowsPath",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlOutputBufferClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferCreateFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferCreateFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferCreateFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferCreateIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferFlush(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferWrite(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferWriteEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlOutputBufferWriteString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserGetDirectory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateMem(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferCreateStatic(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferGrow(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferPush(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserInputBufferRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlPopInputCallbacks(void) {
    int ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlPopInputCallbacks();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPopInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}


static int
test_xmlRegisterDefaultInputCallbacks(void) {
    int ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultInputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }

    return(ret);
}


static int
test_xmlRegisterDefaultOutputCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_OUTPUT_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultOutputCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlRegisterHTTPPostCallbacks(void) {
    int ret = 0;

#ifdef LIBXML_HTTP_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterHTTPPostCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterHTTPPostCallbacks",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlRegisterInputCallbacks(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegisterOutputCallbacks(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlIO(void) {
    int ret = 0;

    printf("Testing xmlIO ...\n");
    ret += test_xmlAllocOutputBuffer();
    ret += test_xmlAllocParserInputBuffer();
    ret += test_xmlCheckFilename();
    ret += test_xmlCheckHTTPInput();
    ret += test_xmlCleanupInputCallbacks();
    ret += test_xmlCleanupOutputCallbacks();
    ret += test_xmlFileClose();
    ret += test_xmlFileMatch();
    ret += test_xmlFileOpen();
    ret += test_xmlFileRead();
    ret += test_xmlIOFTPClose();
    ret += test_xmlIOFTPMatch();
    ret += test_xmlIOFTPOpen();
    ret += test_xmlIOFTPRead();
    ret += test_xmlIOHTTPClose();
    ret += test_xmlIOHTTPMatch();
    ret += test_xmlIOHTTPOpen();
    ret += test_xmlIOHTTPOpenW();
    ret += test_xmlIOHTTPRead();
    ret += test_xmlNoNetExternalEntityLoader();
    ret += test_xmlNormalizeWindowsPath();
    ret += test_xmlOutputBufferClose();
    ret += test_xmlOutputBufferCreateFd();
    ret += test_xmlOutputBufferCreateFile();
    ret += test_xmlOutputBufferCreateFilename();
    ret += test_xmlOutputBufferCreateIO();
    ret += test_xmlOutputBufferFlush();
    ret += test_xmlOutputBufferWrite();
    ret += test_xmlOutputBufferWriteEscape();
    ret += test_xmlOutputBufferWriteString();
    ret += test_xmlParserGetDirectory();
    ret += test_xmlParserInputBufferCreateFd();
    ret += test_xmlParserInputBufferCreateFile();
    ret += test_xmlParserInputBufferCreateFilename();
    ret += test_xmlParserInputBufferCreateIO();
    ret += test_xmlParserInputBufferCreateMem();
    ret += test_xmlParserInputBufferCreateStatic();
    ret += test_xmlParserInputBufferGrow();
    ret += test_xmlParserInputBufferPush();
    ret += test_xmlParserInputBufferRead();
    ret += test_xmlPopInputCallbacks();
    ret += test_xmlRegisterDefaultInputCallbacks();
    ret += test_xmlRegisterDefaultOutputCallbacks();
    ret += test_xmlRegisterHTTPPostCallbacks();
    ret += test_xmlRegisterInputCallbacks();
    ret += test_xmlRegisterOutputCallbacks();

    if (ret != 0)
	printf("Module xmlIO: %d errors\n", ret);
    return(ret);
}

static int
test_xmlAutomataCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataGetInitState(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataIsDeterminist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewAllTrans(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewCountTrans(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewCountTrans2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewCountedTrans(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewCounter(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewCounterTrans(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewEpsilon(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewOnceTrans(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewOnceTrans2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewState(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewTransition(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataNewTransition2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlAutomataSetFinalState(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewAutomata(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlautomata(void) {
    int ret = 0;

    printf("Testing xmlautomata ...\n");
    ret += test_xmlAutomataCompile();
    ret += test_xmlAutomataGetInitState();
    ret += test_xmlAutomataIsDeterminist();
    ret += test_xmlAutomataNewAllTrans();
    ret += test_xmlAutomataNewCountTrans();
    ret += test_xmlAutomataNewCountTrans2();
    ret += test_xmlAutomataNewCountedTrans();
    ret += test_xmlAutomataNewCounter();
    ret += test_xmlAutomataNewCounterTrans();
    ret += test_xmlAutomataNewEpsilon();
    ret += test_xmlAutomataNewOnceTrans();
    ret += test_xmlAutomataNewOnceTrans2();
    ret += test_xmlAutomataNewState();
    ret += test_xmlAutomataNewTransition();
    ret += test_xmlAutomataNewTransition2();
    ret += test_xmlAutomataSetFinalState();
    ret += test_xmlNewAutomata();

    if (ret != 0)
	printf("Module xmlautomata: %d errors\n", ret);
    return(ret);
}

static int
test_initGenericErrorDefaultFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCopyError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCtxtGetLastError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlCtxtResetLastError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetLastError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserPrintFileContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserPrintFileInfo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserValidityError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserValidityWarning(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlParserWarning(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlResetError(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlResetLastError(void) {
    int ret = 0;



        xmlResetLastError();
        call_tests++;
        xmlResetLastError();

    return(ret);
}


static int
test_xmlSetGenericErrorFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSetStructuredErrorFunc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlerror(void) {
    int ret = 0;

    printf("Testing xmlerror ...\n");
    ret += test_initGenericErrorDefaultFunc();
    ret += test_xmlCopyError();
    ret += test_xmlCtxtGetLastError();
    ret += test_xmlCtxtResetLastError();
    ret += test_xmlGetLastError();
    ret += test_xmlParserError();
    ret += test_xmlParserPrintFileContext();
    ret += test_xmlParserPrintFileInfo();
    ret += test_xmlParserValidityError();
    ret += test_xmlParserValidityWarning();
    ret += test_xmlParserWarning();
    ret += test_xmlResetError();
    ret += test_xmlResetLastError();
    ret += test_xmlSetGenericErrorFunc();
    ret += test_xmlSetStructuredErrorFunc();

    if (ret != 0)
	printf("Module xmlerror: %d errors\n", ret);
    return(ret);
}
static int
test_xmlexports(void) {
    int ret = 0;

    printf("Testing xmlexports ...\n");

    if (ret != 0)
	printf("Module xmlexports: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNewTextReader(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextReaderFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderForDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderForFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderForFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderForIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderForMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderNewDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderNewFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderNewFile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderNewIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderNewMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderNewWalker(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlReaderWalker(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderAttributeCount(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderBaseUri(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstBaseUri(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstEncoding(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstLocalName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstNamespaceUri(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstPrefix(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstValue(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstXmlLang(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderConstXmlVersion(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderCurrentDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderCurrentNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderDepth(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderExpand(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderGetAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderGetAttributeNo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderGetAttributeNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderGetErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderGetParserProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderGetRemainder(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderHasAttributes(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderHasValue(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderIsDefault(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderIsEmptyElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderIsNamespaceDecl(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderIsValid(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderLocalName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderLocatorBaseURI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderLocatorLineNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderLookupNamespace(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderMoveToAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderMoveToAttributeNo(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderMoveToAttributeNs(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderMoveToElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderMoveToFirstAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderMoveToNextAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderName(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderNamespaceUri(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderNext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderNextSibling(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderNodeType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderNormalization(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderPrefix(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderPreserve(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderPreservePattern(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderQuoteChar(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderRead(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderReadAttributeValue(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderReadInnerXml(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderReadOuterXml(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderReadState(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderReadString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderRelaxNGSetSchema(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderRelaxNGValidate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderSetErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderSetParserProp(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderSetStructuredErrorHandler(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderStandalone(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderValue(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextReaderXmlLang(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlreader(void) {
    int ret = 0;

    printf("Testing xmlreader ...\n");
    ret += test_xmlNewTextReader();
    ret += test_xmlNewTextReaderFilename();
    ret += test_xmlReaderForDoc();
    ret += test_xmlReaderForFd();
    ret += test_xmlReaderForFile();
    ret += test_xmlReaderForIO();
    ret += test_xmlReaderForMemory();
    ret += test_xmlReaderNewDoc();
    ret += test_xmlReaderNewFd();
    ret += test_xmlReaderNewFile();
    ret += test_xmlReaderNewIO();
    ret += test_xmlReaderNewMemory();
    ret += test_xmlReaderNewWalker();
    ret += test_xmlReaderWalker();
    ret += test_xmlTextReaderAttributeCount();
    ret += test_xmlTextReaderBaseUri();
    ret += test_xmlTextReaderClose();
    ret += test_xmlTextReaderConstBaseUri();
    ret += test_xmlTextReaderConstEncoding();
    ret += test_xmlTextReaderConstLocalName();
    ret += test_xmlTextReaderConstName();
    ret += test_xmlTextReaderConstNamespaceUri();
    ret += test_xmlTextReaderConstPrefix();
    ret += test_xmlTextReaderConstString();
    ret += test_xmlTextReaderConstValue();
    ret += test_xmlTextReaderConstXmlLang();
    ret += test_xmlTextReaderConstXmlVersion();
    ret += test_xmlTextReaderCurrentDoc();
    ret += test_xmlTextReaderCurrentNode();
    ret += test_xmlTextReaderDepth();
    ret += test_xmlTextReaderExpand();
    ret += test_xmlTextReaderGetAttribute();
    ret += test_xmlTextReaderGetAttributeNo();
    ret += test_xmlTextReaderGetAttributeNs();
    ret += test_xmlTextReaderGetErrorHandler();
    ret += test_xmlTextReaderGetParserProp();
    ret += test_xmlTextReaderGetRemainder();
    ret += test_xmlTextReaderHasAttributes();
    ret += test_xmlTextReaderHasValue();
    ret += test_xmlTextReaderIsDefault();
    ret += test_xmlTextReaderIsEmptyElement();
    ret += test_xmlTextReaderIsNamespaceDecl();
    ret += test_xmlTextReaderIsValid();
    ret += test_xmlTextReaderLocalName();
    ret += test_xmlTextReaderLocatorBaseURI();
    ret += test_xmlTextReaderLocatorLineNumber();
    ret += test_xmlTextReaderLookupNamespace();
    ret += test_xmlTextReaderMoveToAttribute();
    ret += test_xmlTextReaderMoveToAttributeNo();
    ret += test_xmlTextReaderMoveToAttributeNs();
    ret += test_xmlTextReaderMoveToElement();
    ret += test_xmlTextReaderMoveToFirstAttribute();
    ret += test_xmlTextReaderMoveToNextAttribute();
    ret += test_xmlTextReaderName();
    ret += test_xmlTextReaderNamespaceUri();
    ret += test_xmlTextReaderNext();
    ret += test_xmlTextReaderNextSibling();
    ret += test_xmlTextReaderNodeType();
    ret += test_xmlTextReaderNormalization();
    ret += test_xmlTextReaderPrefix();
    ret += test_xmlTextReaderPreserve();
    ret += test_xmlTextReaderPreservePattern();
    ret += test_xmlTextReaderQuoteChar();
    ret += test_xmlTextReaderRead();
    ret += test_xmlTextReaderReadAttributeValue();
    ret += test_xmlTextReaderReadInnerXml();
    ret += test_xmlTextReaderReadOuterXml();
    ret += test_xmlTextReaderReadState();
    ret += test_xmlTextReaderReadString();
    ret += test_xmlTextReaderRelaxNGSetSchema();
    ret += test_xmlTextReaderRelaxNGValidate();
    ret += test_xmlTextReaderSetErrorHandler();
    ret += test_xmlTextReaderSetParserProp();
    ret += test_xmlTextReaderSetStructuredErrorHandler();
    ret += test_xmlTextReaderStandalone();
    ret += test_xmlTextReaderValue();
    ret += test_xmlTextReaderXmlLang();

    if (ret != 0)
	printf("Module xmlreader: %d errors\n", ret);
    return(ret);
}

static int
test_xmlRegExecPushString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegExecPushString2(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegNewExecCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegexpCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegexpExec(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegexpIsDeterminist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlRegexpPrint(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlregexp(void) {
    int ret = 0;

    printf("Testing xmlregexp ...\n");
    ret += test_xmlRegExecPushString();
    ret += test_xmlRegExecPushString2();
    ret += test_xmlRegNewExecCtxt();
    ret += test_xmlRegexpCompile();
    ret += test_xmlRegexpExec();
    ret += test_xmlRegexpIsDeterminist();
    ret += test_xmlRegexpPrint();

    if (ret != 0)
	printf("Module xmlregexp: %d errors\n", ret);
    return(ret);
}

static int
test_xmlSaveClose(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveFlush(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveSetAttrEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveSetEscape(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToFd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveToIO(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSaveTree(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlsave(void) {
    int ret = 0;

    printf("Testing xmlsave ...\n");
    ret += test_xmlSaveClose();
    ret += test_xmlSaveDoc();
    ret += test_xmlSaveFlush();
    ret += test_xmlSaveSetAttrEscape();
    ret += test_xmlSaveSetEscape();
    ret += test_xmlSaveToFd();
    ret += test_xmlSaveToFilename();
    ret += test_xmlSaveToIO();
    ret += test_xmlSaveTree();

    if (ret != 0)
	printf("Module xmlsave: %d errors\n", ret);
    return(ret);
}

static int
test_xmlSchemaDump(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewDocParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewMemParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewParserCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewValidCtxt(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaParse(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetParserErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetValidErrors(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaSetValidOptions(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidCtxtGetOptions(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateOneElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateStream(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlschemas(void) {
    int ret = 0;

    printf("Testing xmlschemas ...\n");
    ret += test_xmlSchemaDump();
    ret += test_xmlSchemaGetParserErrors();
    ret += test_xmlSchemaGetValidErrors();
    ret += test_xmlSchemaNewDocParserCtxt();
    ret += test_xmlSchemaNewMemParserCtxt();
    ret += test_xmlSchemaNewParserCtxt();
    ret += test_xmlSchemaNewValidCtxt();
    ret += test_xmlSchemaParse();
    ret += test_xmlSchemaSetParserErrors();
    ret += test_xmlSchemaSetValidErrors();
    ret += test_xmlSchemaSetValidOptions();
    ret += test_xmlSchemaValidCtxtGetOptions();
    ret += test_xmlSchemaValidateDoc();
    ret += test_xmlSchemaValidateOneElement();
    ret += test_xmlSchemaValidateStream();

    if (ret != 0)
	printf("Module xmlschemas: %d errors\n", ret);
    return(ret);
}

static int
test_xmlSchemaCheckFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaCleanupTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlSchemaCleanupTypes();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCleanupTypes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlSchemaCollapseString(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED
    int mem_base;
    xmlChar * ret_val;
    const xmlChar * value; /* a value */
    int n_value;

    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value);

        ret_val = xmlSchemaCollapseString(value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, value);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCollapseString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlSchemaCompareValues(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetBuiltInListSimpleTypeItemType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetBuiltInType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetFacetValueAsULong(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaGetPredefinedType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaInitTypes(void) {
    int ret = 0;

#ifdef LIBXML_SCHEMAS_ENABLED


        xmlSchemaInitTypes();
        call_tests++;
        xmlResetLastError();
#endif

    return(ret);
}


static int
test_xmlSchemaIsBuiltInTypeFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaNewFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValPredefTypeNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValPredefTypeNodeNoNorm(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateLengthFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidateListSimpleTypeFacet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlSchemaValidatePredefinedType(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlschemastypes(void) {
    int ret = 0;

    printf("Testing xmlschemastypes ...\n");
    ret += test_xmlSchemaCheckFacet();
    ret += test_xmlSchemaCleanupTypes();
    ret += test_xmlSchemaCollapseString();
    ret += test_xmlSchemaCompareValues();
    ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
    ret += test_xmlSchemaGetBuiltInType();
    ret += test_xmlSchemaGetFacetValueAsULong();
    ret += test_xmlSchemaGetPredefinedType();
    ret += test_xmlSchemaInitTypes();
    ret += test_xmlSchemaIsBuiltInTypeFacet();
    ret += test_xmlSchemaNewFacet();
    ret += test_xmlSchemaValPredefTypeNode();
    ret += test_xmlSchemaValPredefTypeNodeNoNorm();
    ret += test_xmlSchemaValidateFacet();
    ret += test_xmlSchemaValidateLengthFacet();
    ret += test_xmlSchemaValidateListSimpleTypeFacet();
    ret += test_xmlSchemaValidatePredefinedType();

    if (ret != 0)
	printf("Module xmlschemastypes: %d errors\n", ret);
    return(ret);
}

static int
test_xmlCharStrdup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const char * cur; /* the input char * */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur);

        ret_val = xmlCharStrdup(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrdup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlCharStrndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const char * cur; /* the input char * */
    int n_cur;
    int len; /* the len of @cur */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur);
        len = gen_int(n_len);

        ret_val = xmlCharStrndup(cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, cur);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlCheckUTF8(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlGetUTF8Char(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrEqual(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1);
        str2 = gen_const_xmlChar_ptr(n_str2);

        ret_val = xmlStrEqual(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1);
        des_const_xmlChar_ptr(n_str2, str2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrEqual",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlStrPrintf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrQEqual(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * pref; /* the prefix of the QName */
    int n_pref;
    const xmlChar * name; /* the localname of the QName */
    int n_name;
    const xmlChar * str; /* the second xmlChar * */
    int n_str;

    for (n_pref = 0;n_pref < gen_nb_const_xmlChar_ptr;n_pref++) {
    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        pref = gen_const_xmlChar_ptr(n_pref);
        name = gen_const_xmlChar_ptr(n_name);
        str = gen_const_xmlChar_ptr(n_str);

        ret_val = xmlStrQEqual(pref, name, str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pref, pref);
        des_const_xmlChar_ptr(n_name, name);
        des_const_xmlChar_ptr(n_str, str);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrQEqual",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_pref);
            printf(" %d", n_name);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlStrVPrintf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrcasecmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1);
        str2 = gen_const_xmlChar_ptr(n_str2);

        ret_val = xmlStrcasecmp(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1);
        des_const_xmlChar_ptr(n_str2, str2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcasecmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlStrcasestr(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrchr(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrcmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1);
        str2 = gen_const_xmlChar_ptr(n_str2);

        ret_val = xmlStrcmp(str1, str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1);
        des_const_xmlChar_ptr(n_str2, str2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlStrdup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * cur; /* the input xmlChar * */
    int n_cur;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur);

        ret_val = xmlStrdup(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrdup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlStrlen(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str; /* the xmlChar * array */
    int n_str;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str);

        ret_val = xmlStrlen(str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrlen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlStrncasecmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;
    int len; /* the max comparison length */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1);
        str2 = gen_const_xmlChar_ptr(n_str2);
        len = gen_int(n_len);

        ret_val = xmlStrncasecmp(str1, str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1);
        des_const_xmlChar_ptr(n_str2, str2);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncasecmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlStrncatNew(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str1; /* first xmlChar string */
    int n_str1;
    const xmlChar * str2; /* second xmlChar string */
    int n_str2;
    int len; /* the len of @str2 */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1);
        str2 = gen_const_xmlChar_ptr(n_str2);
        len = gen_int(n_len);

        ret_val = xmlStrncatNew(str1, str2, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1);
        des_const_xmlChar_ptr(n_str2, str2);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncatNew",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlStrncmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * str1; /* the first xmlChar * */
    int n_str1;
    const xmlChar * str2; /* the second xmlChar * */
    int n_str2;
    int len; /* the max comparison length */
    int n_len;

    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1);
        str2 = gen_const_xmlChar_ptr(n_str2);
        len = gen_int(n_len);

        ret_val = xmlStrncmp(str1, str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, str1);
        des_const_xmlChar_ptr(n_str2, str2);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlStrndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * cur; /* the input xmlChar * */
    int n_cur;
    int len; /* the len of @cur */
    int n_len;

    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur);
        len = gen_int(n_len);

        ret_val = xmlStrndup(cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, cur);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlStrstr(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlStrsub(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * str; /* the xmlChar * array (haystack) */
    int n_str;
    int start; /* the index of the first char (zero based) */
    int n_start;
    int len; /* the length of the substring */
    int n_len;

    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str);
        start = gen_int(n_start);
        len = gen_int(n_len);

        ret_val = xmlStrsub(str, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, str);
        des_int(n_start, start);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrsub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_str);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}


static int
test_xmlUTF8Charcmp(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf1; /* pointer to first UTF8 char */
    int n_utf1;
    const xmlChar * utf2; /* pointer to second UTF8 char */
    int n_utf2;

    for (n_utf1 = 0;n_utf1 < gen_nb_const_xmlChar_ptr;n_utf1++) {
    for (n_utf2 = 0;n_utf2 < gen_nb_const_xmlChar_ptr;n_utf2++) {
        mem_base = xmlMemBlocks();
        utf1 = gen_const_xmlChar_ptr(n_utf1);
        utf2 = gen_const_xmlChar_ptr(n_utf2);

        ret_val = xmlUTF8Charcmp(utf1, utf2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf1, utf1);
        des_const_xmlChar_ptr(n_utf2, utf2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Charcmp",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf1);
            printf(" %d", n_utf2);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlUTF8Size(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* pointer to the UTF8 character */
    int n_utf;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf);

        ret_val = xmlUTF8Size(utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Size",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlUTF8Strlen(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf);

        ret_val = xmlUTF8Strlen(utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strlen",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }

    return(ret);
}


static int
test_xmlUTF8Strloc(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    const xmlChar * utfchar; /* the UTF8 character to be found */
    int n_utfchar;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_utfchar = 0;n_utfchar < gen_nb_const_xmlChar_ptr;n_utfchar++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf);
        utfchar = gen_const_xmlChar_ptr(n_utfchar);

        ret_val = xmlUTF8Strloc(utf, utfchar);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf);
        des_const_xmlChar_ptr(n_utfchar, utfchar);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strloc",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_utfchar);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlUTF8Strndup(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * utf; /* the input UTF8 * */
    int n_utf;
    int len; /* the len of @utf (in chars) */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf);
        len = gen_int(n_len);

        ret_val = xmlUTF8Strndup(utf, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strndup",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlUTF8Strpos(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlUTF8Strsize(void) {
    int ret = 0;

    int mem_base;
    int ret_val;
    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;
    int len; /* the number of characters in the array */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf);
        len = gen_int(n_len);

        ret_val = xmlUTF8Strsize(utf, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsize",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }

    return(ret);
}


static int
test_xmlUTF8Strsub(void) {
    int ret = 0;

    int mem_base;
    xmlChar * ret_val;
    const xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
    int n_utf;
    int start; /* relative pos of first char */
    int n_start;
    int len; /* total number to copy */
    int n_len;

    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    for (n_len = 0;n_len < gen_nb_int;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf);
        start = gen_int(n_start);
        len = gen_int(n_len);

        ret_val = xmlUTF8Strsub(utf, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, utf);
        des_int(n_start, start);
        des_int(n_len, len);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsub",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_utf);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }

    return(ret);
}

static int
test_xmlstring(void) {
    int ret = 0;

    printf("Testing xmlstring ...\n");
    ret += test_xmlCharStrdup();
    ret += test_xmlCharStrndup();
    ret += test_xmlCheckUTF8();
    ret += test_xmlGetUTF8Char();
    ret += test_xmlStrEqual();
    ret += test_xmlStrPrintf();
    ret += test_xmlStrQEqual();
    ret += test_xmlStrVPrintf();
    ret += test_xmlStrcasecmp();
    ret += test_xmlStrcasestr();
    ret += test_xmlStrchr();
    ret += test_xmlStrcmp();
    ret += test_xmlStrdup();
    ret += test_xmlStrlen();
    ret += test_xmlStrncasecmp();
    ret += test_xmlStrncatNew();
    ret += test_xmlStrncmp();
    ret += test_xmlStrndup();
    ret += test_xmlStrstr();
    ret += test_xmlStrsub();
    ret += test_xmlUTF8Charcmp();
    ret += test_xmlUTF8Size();
    ret += test_xmlUTF8Strlen();
    ret += test_xmlUTF8Strloc();
    ret += test_xmlUTF8Strndup();
    ret += test_xmlUTF8Strpos();
    ret += test_xmlUTF8Strsize();
    ret += test_xmlUTF8Strsub();

    if (ret != 0)
	printf("Module xmlstring: %d errors\n", ret);
    return(ret);
}

static int
test_xmlNewTextWriter(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterDoc(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterFilename(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterMemory(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterPushParser(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlNewTextWriterTree(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndDTDEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndDocument(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterEndPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterFlush(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterFullEndElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterSetIndent(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterSetIndentString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartDTDEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartDocument(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterStartPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteBase64(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteBinHex(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTDEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntityContents(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTDInternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteDTDNotation(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatDTDInternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatRaw(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteFormatString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWritePI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteRaw(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteRawLen(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatAttribute(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatAttributeNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatCDATA(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatComment(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTD(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDAttlist(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatDTDInternalEntity(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatElement(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatElementNS(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatPI(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatRaw(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlTextWriterWriteVFormatString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xmlwriter(void) {
    int ret = 0;

    printf("Testing xmlwriter ...\n");
    ret += test_xmlNewTextWriter();
    ret += test_xmlNewTextWriterDoc();
    ret += test_xmlNewTextWriterFilename();
    ret += test_xmlNewTextWriterMemory();
    ret += test_xmlNewTextWriterPushParser();
    ret += test_xmlNewTextWriterTree();
    ret += test_xmlTextWriterEndAttribute();
    ret += test_xmlTextWriterEndCDATA();
    ret += test_xmlTextWriterEndComment();
    ret += test_xmlTextWriterEndDTD();
    ret += test_xmlTextWriterEndDTDAttlist();
    ret += test_xmlTextWriterEndDTDElement();
    ret += test_xmlTextWriterEndDTDEntity();
    ret += test_xmlTextWriterEndDocument();
    ret += test_xmlTextWriterEndElement();
    ret += test_xmlTextWriterEndPI();
    ret += test_xmlTextWriterFlush();
    ret += test_xmlTextWriterFullEndElement();
    ret += test_xmlTextWriterSetIndent();
    ret += test_xmlTextWriterSetIndentString();
    ret += test_xmlTextWriterStartAttribute();
    ret += test_xmlTextWriterStartAttributeNS();
    ret += test_xmlTextWriterStartCDATA();
    ret += test_xmlTextWriterStartComment();
    ret += test_xmlTextWriterStartDTD();
    ret += test_xmlTextWriterStartDTDAttlist();
    ret += test_xmlTextWriterStartDTDElement();
    ret += test_xmlTextWriterStartDTDEntity();
    ret += test_xmlTextWriterStartDocument();
    ret += test_xmlTextWriterStartElement();
    ret += test_xmlTextWriterStartElementNS();
    ret += test_xmlTextWriterStartPI();
    ret += test_xmlTextWriterWriteAttribute();
    ret += test_xmlTextWriterWriteAttributeNS();
    ret += test_xmlTextWriterWriteBase64();
    ret += test_xmlTextWriterWriteBinHex();
    ret += test_xmlTextWriterWriteCDATA();
    ret += test_xmlTextWriterWriteComment();
    ret += test_xmlTextWriterWriteDTD();
    ret += test_xmlTextWriterWriteDTDAttlist();
    ret += test_xmlTextWriterWriteDTDElement();
    ret += test_xmlTextWriterWriteDTDEntity();
    ret += test_xmlTextWriterWriteDTDExternalEntity();
    ret += test_xmlTextWriterWriteDTDExternalEntityContents();
    ret += test_xmlTextWriterWriteDTDInternalEntity();
    ret += test_xmlTextWriterWriteDTDNotation();
    ret += test_xmlTextWriterWriteElement();
    ret += test_xmlTextWriterWriteElementNS();
    ret += test_xmlTextWriterWriteFormatAttribute();
    ret += test_xmlTextWriterWriteFormatAttributeNS();
    ret += test_xmlTextWriterWriteFormatCDATA();
    ret += test_xmlTextWriterWriteFormatComment();
    ret += test_xmlTextWriterWriteFormatDTD();
    ret += test_xmlTextWriterWriteFormatDTDAttlist();
    ret += test_xmlTextWriterWriteFormatDTDElement();
    ret += test_xmlTextWriterWriteFormatDTDInternalEntity();
    ret += test_xmlTextWriterWriteFormatElement();
    ret += test_xmlTextWriterWriteFormatElementNS();
    ret += test_xmlTextWriterWriteFormatPI();
    ret += test_xmlTextWriterWriteFormatRaw();
    ret += test_xmlTextWriterWriteFormatString();
    ret += test_xmlTextWriterWritePI();
    ret += test_xmlTextWriterWriteRaw();
    ret += test_xmlTextWriterWriteRawLen();
    ret += test_xmlTextWriterWriteString();
    ret += test_xmlTextWriterWriteVFormatAttribute();
    ret += test_xmlTextWriterWriteVFormatAttributeNS();
    ret += test_xmlTextWriterWriteVFormatCDATA();
    ret += test_xmlTextWriterWriteVFormatComment();
    ret += test_xmlTextWriterWriteVFormatDTD();
    ret += test_xmlTextWriterWriteVFormatDTDAttlist();
    ret += test_xmlTextWriterWriteVFormatDTDElement();
    ret += test_xmlTextWriterWriteVFormatDTDInternalEntity();
    ret += test_xmlTextWriterWriteVFormatElement();
    ret += test_xmlTextWriterWriteVFormatElementNS();
    ret += test_xmlTextWriterWriteVFormatPI();
    ret += test_xmlTextWriterWriteVFormatRaw();
    ret += test_xmlTextWriterWriteVFormatString();

    if (ret != 0)
	printf("Module xmlwriter: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXPathCastBooleanToNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastBooleanToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    int val; /* a boolean */
    int n_val;

    for (n_val = 0;n_val < gen_nb_int;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val);

        ret_val = xmlXPathCastBooleanToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_int(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastBooleanToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlXPathCastNodeSetToBoolean(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNodeSetToNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNodeSetToString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNodeToNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNodeToString(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node; /* a node */
    int n_node;

    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node);

        ret_val = xmlXPathCastNodeToString(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeToString",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlXPathCastNumberToBoolean(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastNumberToString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastStringToBoolean(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    const xmlChar * val; /* a string */
    int n_val;

    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val);

        ret_val = xmlXPathCastStringToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, val);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastStringToBoolean",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
#endif

    return(ret);
}


static int
test_xmlXPathCastStringToNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastToBoolean(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastToNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCastToString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCmpNodes(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;
    int ret_val;
    xmlNodePtr node1; /* the first node */
    int n_node1;
    xmlNodePtr node2; /* the second node */
    int n_node2;

    for (n_node1 = 0;n_node1 < gen_nb_xmlNodePtr;n_node1++) {
    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
        mem_base = xmlMemBlocks();
        node1 = gen_xmlNodePtr(n_node1);
        node2 = gen_xmlNodePtr(n_node2);

        ret_val = xmlXPathCmpNodes(node1, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node1, node1);
        des_xmlNodePtr(n_node2, node2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCmpNodes",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf(" %d", n_node1);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
#endif

    return(ret);
}


static int
test_xmlXPathCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCompiledEval(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathConvertBoolean(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathConvertNumber(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathConvertString(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathCtxtCompile(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathEval(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathEvalExpression(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathEvalPredicate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathInit(void) {
    int ret = 0;

#ifdef LIBXML_XPATH_ENABLED
    int mem_base;

        mem_base = xmlMemBlocks();

        xmlXPathInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathInit",
	           xmlMemBlocks() - mem_base);
	    ret++;
            printf("\n");
        }
#endif

    return(ret);
}


static int
test_xmlXPathIsInf(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathIsNaN(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathNodeSetCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathObjectCopy(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPathOrderDocElems(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xpath(void) {
    int ret = 0;

    printf("Testing xpath ...\n");
    ret += test_xmlXPathCastBooleanToNumber();
    ret += test_xmlXPathCastBooleanToString();
    ret += test_xmlXPathCastNodeSetToBoolean();
    ret += test_xmlXPathCastNodeSetToNumber();
    ret += test_xmlXPathCastNodeSetToString();
    ret += test_xmlXPathCastNodeToNumber();
    ret += test_xmlXPathCastNodeToString();
    ret += test_xmlXPathCastNumberToBoolean();
    ret += test_xmlXPathCastNumberToString();
    ret += test_xmlXPathCastStringToBoolean();
    ret += test_xmlXPathCastStringToNumber();
    ret += test_xmlXPathCastToBoolean();
    ret += test_xmlXPathCastToNumber();
    ret += test_xmlXPathCastToString();
    ret += test_xmlXPathCmpNodes();
    ret += test_xmlXPathCompile();
    ret += test_xmlXPathCompiledEval();
    ret += test_xmlXPathConvertBoolean();
    ret += test_xmlXPathConvertNumber();
    ret += test_xmlXPathConvertString();
    ret += test_xmlXPathCtxtCompile();
    ret += test_xmlXPathEval();
    ret += test_xmlXPathEvalExpression();
    ret += test_xmlXPathEvalPredicate();
    ret += test_xmlXPathInit();
    ret += test_xmlXPathIsInf();
    ret += test_xmlXPathIsNaN();
    ret += test_xmlXPathNewContext();
    ret += test_xmlXPathNodeSetCreate();
    ret += test_xmlXPathObjectCopy();
    ret += test_xmlXPathOrderDocElems();

    if (ret != 0)
	printf("Module xpath: %d errors\n", ret);
    return(ret);
}

static int
test_xmlXPtrBuildNodeList(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrEval(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrEvalRangePredicate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetAdd(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetCreate(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetDel(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetMerge(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrLocationSetRemove(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewCollapsedRange(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewContext(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewLocationSetNodeSet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewLocationSetNodes(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewRange(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewRangeNodeObject(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewRangeNodePoint(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewRangeNodes(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewRangePointNode(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrNewRangePoints(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrRangeToFunction(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}


static int
test_xmlXPtrWrapLocationSet(void) {
    int ret = 0;


    /* missing type support */
    return(ret);
}

static int
test_xpointer(void) {
    int ret = 0;

    printf("Testing xpointer ...\n");
    ret += test_xmlXPtrBuildNodeList();
    ret += test_xmlXPtrEval();
    ret += test_xmlXPtrEvalRangePredicate();
    ret += test_xmlXPtrLocationSetAdd();
    ret += test_xmlXPtrLocationSetCreate();
    ret += test_xmlXPtrLocationSetDel();
    ret += test_xmlXPtrLocationSetMerge();
    ret += test_xmlXPtrLocationSetRemove();
    ret += test_xmlXPtrNewCollapsedRange();
    ret += test_xmlXPtrNewContext();
    ret += test_xmlXPtrNewLocationSetNodeSet();
    ret += test_xmlXPtrNewLocationSetNodes();
    ret += test_xmlXPtrNewRange();
    ret += test_xmlXPtrNewRangeNodeObject();
    ret += test_xmlXPtrNewRangeNodePoint();
    ret += test_xmlXPtrNewRangeNodes();
    ret += test_xmlXPtrNewRangePointNode();
    ret += test_xmlXPtrNewRangePoints();
    ret += test_xmlXPtrRangeToFunction();
    ret += test_xmlXPtrWrapLocationSet();

    if (ret != 0)
	printf("Module xpointer: %d errors\n", ret);
    return(ret);
}
