<api name='libxml2'>
  <files>
    <file name='debugXML'>
     <exports symbol='xmlDebugDumpString'/>
     <exports symbol='xmlDebugDumpAttr'/>
     <exports symbol='xmlDebugDumpAttrList'/>
     <exports symbol='xmlDebugDumpOneNode'/>
     <exports symbol='xmlDebugDumpNode'/>
     <exports symbol='xmlDebugDumpNodeList'/>
     <exports symbol='xmlDebugDumpDocumentHead'/>
     <exports symbol='xmlDebugDumpDocument'/>
     <exports symbol='xmlDebugDumpDTD'/>
     <exports symbol='xmlDebugDumpEntities'/>
     <exports symbol='xmlLsOneNode'/>
     <exports symbol='xmlLsCountNode'/>
     <exports symbol='xmlShellReadlineFunc'/>
     <exports symbol='xmlShellCtxt'/>
     <exports symbol='xmlShellCtxtPtr'/>
     <exports symbol='xmlShellCmd'/>
     <exports symbol='xmlShellPrintXPathError'/>
     <exports symbol='xmlShellPrintNode'/>
     <exports symbol='xmlShellPrintXPathResult'/>
     <exports symbol='xmlShellList'/>
     <exports symbol='xmlShellBase'/>
     <exports symbol='xmlShellDir'/>
     <exports symbol='xmlShellCat'/>
     <exports symbol='xmlShellLoad'/>
     <exports symbol='xmlShellWrite'/>
     <exports symbol='xmlShellSave'/>
     <exports symbol='xmlShellValidate'/>
     <exports symbol='xmlShellDu'/>
     <exports symbol='xmlShellPwd'/>
     <exports symbol='xmlShell'/>
    </file>
    <file name='DOCBparser'>
     <exports symbol='docbParserCtxt'/>
     <exports symbol='docbParserCtxtPtr'/>
     <exports symbol='docbParserNodeInfo'/>
     <exports symbol='docbSAXHandler'/>
     <exports symbol='docbSAXHandlerPtr'/>
     <exports symbol='docbParserInput'/>
     <exports symbol='docbParserInputPtr'/>
     <exports symbol='docbDocPtr'/>
     <exports symbol='docbNodePtr'/>
     <exports symbol='docbEncodeEntities'/>
     <exports symbol='docbSAXParseDoc'/>
     <exports symbol='docbParseDoc'/>
     <exports symbol='docbSAXParseFile'/>
     <exports symbol='docbParseFile'/>
     <exports symbol='docbFreeParserCtxt'/>
     <exports symbol='docbCreatePushParserCtxt'/>
     <exports symbol='docbParseChunk'/>
     <exports symbol='docbCreateFileParserCtxt'/>
     <exports symbol='docbParseDocument'/>
    </file>
    <file name='HTMLparser'>
     <exports symbol='htmlParserCtxt'/>
     <exports symbol='htmlParserCtxtPtr'/>
     <exports symbol='htmlParserNodeInfo'/>
     <exports symbol='htmlSAXHandler'/>
     <exports symbol='htmlSAXHandlerPtr'/>
     <exports symbol='htmlParserInput'/>
     <exports symbol='htmlParserInputPtr'/>
     <exports symbol='htmlDocPtr'/>
     <exports symbol='htmlNodePtr'/>
     <exports symbol='htmlElemDesc'/>
     <exports symbol='htmlElemDescPtr'/>
     <exports symbol='htmlEntityDesc'/>
     <exports symbol='htmlEntityDescPtr'/>
     <exports symbol='htmlTagLookup'/>
     <exports symbol='htmlEntityLookup'/>
     <exports symbol='htmlEntityValueLookup'/>
     <exports symbol='htmlIsAutoClosed'/>
     <exports symbol='htmlAutoCloseTag'/>
     <exports symbol='htmlParseEntityRef'/>
     <exports symbol='htmlParseCharRef'/>
     <exports symbol='htmlParseElement'/>
     <exports symbol='htmlSAXParseDoc'/>
     <exports symbol='htmlParseDoc'/>
     <exports symbol='htmlSAXParseFile'/>
     <exports symbol='htmlParseFile'/>
     <exports symbol='UTF8ToHtml'/>
     <exports symbol='htmlEncodeEntities'/>
     <exports symbol='htmlIsScriptAttribute'/>
     <exports symbol='htmlHandleOmittedElem'/>
     <exports symbol='htmlFreeParserCtxt'/>
     <exports symbol='htmlCreatePushParserCtxt'/>
     <exports symbol='htmlParseChunk'/>
    </file>
    <file name='SAX'>
     <exports symbol='getPublicId'/>
     <exports symbol='getSystemId'/>
     <exports symbol='setDocumentLocator'/>
     <exports symbol='getLineNumber'/>
     <exports symbol='getColumnNumber'/>
     <exports symbol='isStandalone'/>
     <exports symbol='hasInternalSubset'/>
     <exports symbol='hasExternalSubset'/>
     <exports symbol='internalSubset'/>
     <exports symbol='externalSubset'/>
     <exports symbol='getEntity'/>
     <exports symbol='getParameterEntity'/>
     <exports symbol='resolveEntity'/>
     <exports symbol='entityDecl'/>
     <exports symbol='attributeDecl'/>
     <exports symbol='elementDecl'/>
     <exports symbol='notationDecl'/>
     <exports symbol='unparsedEntityDecl'/>
     <exports symbol='startDocument'/>
     <exports symbol='endDocument'/>
     <exports symbol='attribute'/>
     <exports symbol='startElement'/>
     <exports symbol='endElement'/>
     <exports symbol='reference'/>
     <exports symbol='characters'/>
     <exports symbol='ignorableWhitespace'/>
     <exports symbol='processingInstruction'/>
     <exports symbol='globalNamespace'/>
     <exports symbol='setNamespace'/>
     <exports symbol='getNamespace'/>
     <exports symbol='checkNamespace'/>
     <exports symbol='namespaceDecl'/>
     <exports symbol='comment'/>
     <exports symbol='cdataBlock'/>
     <exports symbol='initxmlDefaultSAXHandler'/>
     <exports symbol='inithtmlDefaultSAXHandler'/>
     <exports symbol='initdocbDefaultSAXHandler'/>
     <exports symbol='xmlDefaultSAXHandlerInit'/>
     <exports symbol='htmlDefaultSAXHandlerInit'/>
     <exports symbol='docbDefaultSAXHandlerInit'/>
    </file>
    <file name='nanohttp'>
     <exports symbol='xmlNanoHTTPInit'/>
     <exports symbol='xmlNanoHTTPCleanup'/>
     <exports symbol='xmlNanoHTTPScanProxy'/>
     <exports symbol='xmlNanoHTTPFetch'/>
     <exports symbol='xmlNanoHTTPMethod'/>
     <exports symbol='xmlNanoHTTPMethodRedir'/>
     <exports symbol='xmlNanoHTTPOpen'/>
     <exports symbol='xmlNanoHTTPOpenRedir'/>
     <exports symbol='xmlNanoHTTPReturnCode'/>
     <exports symbol='xmlNanoHTTPAuthHeader'/>
     <exports symbol='xmlNanoHTTPRead'/>
     <exports symbol='xmlNanoHTTPSave'/>
     <exports symbol='xmlNanoHTTPClose'/>
    </file>
    <file name='entities'>
     <exports symbol='xmlEntityType'/>
     <exports symbol='xmlEntity'/>
     <exports symbol='xmlEntityPtr'/>
     <exports symbol='xmlEntitiesTablePtr'/>
     <exports symbol='xmlInitializePredefinedEntities'/>
     <exports symbol='xmlAddDocEntity'/>
     <exports symbol='xmlAddDtdEntity'/>
     <exports symbol='xmlGetPredefinedEntity'/>
     <exports symbol='xmlGetDocEntity'/>
     <exports symbol='xmlGetDtdEntity'/>
     <exports symbol='xmlGetParameterEntity'/>
     <exports symbol='xmlEncodeEntities'/>
     <exports symbol='xmlEncodeEntitiesReentrant'/>
     <exports symbol='xmlEncodeSpecialChars'/>
     <exports symbol='xmlCreateEntitiesTable'/>
     <exports symbol='xmlCopyEntitiesTable'/>
     <exports symbol='xmlFreeEntitiesTable'/>
     <exports symbol='xmlDumpEntitiesTable'/>
     <exports symbol='xmlDumpEntityDecl'/>
     <exports symbol='xmlCleanupPredefinedEntities'/>
    </file>
    <file name='xmlmemory'>
     <exports symbol='DEBUG_MEMORY'/>
     <exports symbol='MEM_LIST'/>
     <exports symbol='xmlFreeFunc'/>
     <exports symbol='xmlMallocFunc'/>
     <exports symbol='xmlReallocFunc'/>
     <exports symbol='xmlStrdupFunc'/>
     <exports symbol='xmlMemSetup'/>
     <exports symbol='xmlMemGet'/>
     <exports symbol='xmlInitMemory'/>
     <exports symbol='xmlMemUsed'/>
     <exports symbol='xmlMemDisplay'/>
     <exports symbol='xmlMemShow'/>
     <exports symbol='xmlMemoryDump'/>
     <exports symbol='xmlMalloc'/>
     <exports symbol='xmlRealloc'/>
     <exports symbol='xmlMemStrdup'/>
     <exports symbol='xmlMallocLoc'/>
     <exports symbol='xmlReallocLoc'/>
     <exports symbol='xmlMemStrdupLoc'/>
    </file>
    <file name='valid'>
     <exports symbol='xmlValidState'/>
     <exports symbol='xmlValidStatePtr'/>
     <exports symbol='xmlValidityErrorFunc'/>
     <exports symbol='xmlValidityWarningFunc'/>
     <exports symbol='xmlValidCtxt'/>
     <exports symbol='xmlValidCtxtPtr'/>
     <exports symbol='xmlNotationTablePtr'/>
     <exports symbol='xmlElementTablePtr'/>
     <exports symbol='xmlAttributeTablePtr'/>
     <exports symbol='xmlIDTablePtr'/>
     <exports symbol='xmlRefTablePtr'/>
     <exports symbol='xmlSplitQName2'/>
     <exports symbol='xmlAddNotationDecl'/>
     <exports symbol='xmlCopyNotationTable'/>
     <exports symbol='xmlFreeNotationTable'/>
     <exports symbol='xmlDumpNotationDecl'/>
     <exports symbol='xmlDumpNotationTable'/>
     <exports symbol='xmlNewElementContent'/>
     <exports symbol='xmlCopyElementContent'/>
     <exports symbol='xmlFreeElementContent'/>
     <exports symbol='xmlSnprintfElementContent'/>
     <exports symbol='xmlSprintfElementContent'/>
     <exports symbol='xmlAddElementDecl'/>
     <exports symbol='xmlCopyElementTable'/>
     <exports symbol='xmlFreeElementTable'/>
     <exports symbol='xmlDumpElementTable'/>
     <exports symbol='xmlDumpElementDecl'/>
     <exports symbol='xmlCreateEnumeration'/>
     <exports symbol='xmlFreeEnumeration'/>
     <exports symbol='xmlCopyEnumeration'/>
     <exports symbol='xmlAddAttributeDecl'/>
     <exports symbol='xmlCopyAttributeTable'/>
     <exports symbol='xmlFreeAttributeTable'/>
     <exports symbol='xmlDumpAttributeTable'/>
     <exports symbol='xmlDumpAttributeDecl'/>
     <exports symbol='xmlAddID'/>
     <exports symbol='xmlFreeIDTable'/>
     <exports symbol='xmlGetID'/>
     <exports symbol='xmlIsID'/>
     <exports symbol='xmlRemoveID'/>
     <exports symbol='xmlAddRef'/>
     <exports symbol='xmlFreeRefTable'/>
     <exports symbol='xmlIsRef'/>
     <exports symbol='xmlRemoveRef'/>
     <exports symbol='xmlGetRefs'/>
     <exports symbol='xmlValidateRoot'/>
     <exports symbol='xmlValidateElementDecl'/>
     <exports symbol='xmlValidNormalizeAttributeValue'/>
     <exports symbol='xmlValidateAttributeDecl'/>
     <exports symbol='xmlValidateAttributeValue'/>
     <exports symbol='xmlValidateNotationDecl'/>
     <exports symbol='xmlValidateDtd'/>
     <exports symbol='xmlValidateDtdFinal'/>
     <exports symbol='xmlValidateDocument'/>
     <exports symbol='xmlValidateElement'/>
     <exports symbol='xmlValidateOneElement'/>
     <exports symbol='xmlValidateOneAttribute'/>
     <exports symbol='xmlValidateDocumentFinal'/>
     <exports symbol='xmlValidateNotationUse'/>
     <exports symbol='xmlIsMixedElement'/>
     <exports symbol='xmlGetDtdAttrDesc'/>
     <exports symbol='xmlGetDtdQAttrDesc'/>
     <exports symbol='xmlGetDtdNotationDesc'/>
     <exports symbol='xmlGetDtdQElementDesc'/>
     <exports symbol='xmlGetDtdElementDesc'/>
     <exports symbol='xmlValidGetValidElements'/>
     <exports symbol='xmlValidGetPotentialChildren'/>
    </file>
    <file name='uri'>
     <exports symbol='xmlURI'/>
     <exports symbol='xmlURIPtr'/>
     <exports symbol='xmlCreateURI'/>
     <exports symbol='xmlBuildURI'/>
     <exports symbol='xmlParseURI'/>
     <exports symbol='xmlParseURIReference'/>
     <exports symbol='xmlSaveUri'/>
     <exports symbol='xmlPrintURI'/>
     <exports symbol='xmlURIEscapeStr'/>
     <exports symbol='xmlURIUnescapeString'/>
     <exports symbol='xmlNormalizeURIPath'/>
     <exports symbol='xmlURIEscape'/>
     <exports symbol='xmlFreeURI'/>
    </file>
    <file name='list'>
     <exports symbol='xmlLink'/>
     <exports symbol='xmlLinkPtr'/>
     <exports symbol='xmlList'/>
     <exports symbol='xmlListPtr'/>
     <exports symbol='xmlListDeallocator'/>
     <exports symbol='xmlListDataCompare'/>
     <exports symbol='xmlListWalker'/>
     <exports symbol='xmlListCreate'/>
     <exports symbol='xmlListDelete'/>
     <exports symbol='xmlListSearch'/>
     <exports symbol='xmlListReverseSearch'/>
     <exports symbol='xmlListInsert'/>
     <exports symbol='xmlListAppend'/>
     <exports symbol='xmlListRemoveFirst'/>
     <exports symbol='xmlListRemoveLast'/>
     <exports symbol='xmlListRemoveAll'/>
     <exports symbol='xmlListClear'/>
     <exports symbol='xmlListEmpty'/>
     <exports symbol='xmlListFront'/>
     <exports symbol='xmlListEnd'/>
     <exports symbol='xmlListSize'/>
     <exports symbol='xmlListPopFront'/>
     <exports symbol='xmlListPopBack'/>
     <exports symbol='xmlListPushFront'/>
     <exports symbol='xmlListPushBack'/>
     <exports symbol='xmlListReverse'/>
     <exports symbol='xmlListSort'/>
     <exports symbol='xmlListWalk'/>
     <exports symbol='xmlListReverseWalk'/>
     <exports symbol='xmlListMerge'/>
     <exports symbol='xmlListDup'/>
     <exports symbol='xmlListCopy'/>
     <exports symbol='xmlLinkGetData'/>
    </file>
    <file name='nanoftp'>
     <exports symbol='ftpListCallback'/>
     <exports symbol='ftpDataCallback'/>
     <exports symbol='xmlNanoFTPInit'/>
     <exports symbol='xmlNanoFTPCleanup'/>
     <exports symbol='xmlNanoFTPNewCtxt'/>
     <exports symbol='xmlNanoFTPFreeCtxt'/>
     <exports symbol='xmlNanoFTPConnectTo'/>
     <exports symbol='xmlNanoFTPOpen'/>
     <exports symbol='xmlNanoFTPConnect'/>
     <exports symbol='xmlNanoFTPClose'/>
     <exports symbol='xmlNanoFTPQuit'/>
     <exports symbol='xmlNanoFTPScanProxy'/>
     <exports symbol='xmlNanoFTPProxy'/>
     <exports symbol='xmlNanoFTPUpdateURL'/>
     <exports symbol='xmlNanoFTPGetResponse'/>
     <exports symbol='xmlNanoFTPCheckResponse'/>
     <exports symbol='xmlNanoFTPCwd'/>
     <exports symbol='xmlNanoFTPGetConnection'/>
     <exports symbol='xmlNanoFTPCloseConnection'/>
     <exports symbol='xmlNanoFTPList'/>
     <exports symbol='xmlNanoFTPGetSocket'/>
     <exports symbol='xmlNanoFTPGet'/>
     <exports symbol='xmlNanoFTPRead'/>
    </file>
    <file name='parserInternals'>
     <exports symbol='XML_MAX_NAMELEN'/>
     <exports symbol='INPUT_CHUNK'/>
     <exports symbol='IS_CHAR'/>
     <exports symbol='IS_BLANK'/>
     <exports symbol='IS_BASECHAR'/>
     <exports symbol='IS_DIGIT'/>
     <exports symbol='IS_COMBINING'/>
     <exports symbol='IS_EXTENDER'/>
     <exports symbol='IS_IDEOGRAPHIC'/>
     <exports symbol='IS_LETTER'/>
     <exports symbol='IS_PUBIDCHAR'/>
     <exports symbol='SKIP_EOL'/>
     <exports symbol='MOVETO_ENDTAG'/>
     <exports symbol='MOVETO_STARTTAG'/>
     <exports symbol='xmlIsBaseChar'/>
     <exports symbol='xmlIsBlank'/>
     <exports symbol='xmlIsPubidChar'/>
     <exports symbol='xmlIsLetter'/>
     <exports symbol='xmlIsDigit'/>
     <exports symbol='xmlIsIdeographic'/>
     <exports symbol='xmlIsCombining'/>
     <exports symbol='xmlIsExtender'/>
     <exports symbol='xmlIsChar'/>
     <exports symbol='xmlCreateFileParserCtxt'/>
     <exports symbol='xmlCreateMemoryParserCtxt'/>
     <exports symbol='xmlNewParserCtxt'/>
     <exports symbol='xmlCreateEntityParserCtxt'/>
     <exports symbol='xmlSwitchEncoding'/>
     <exports symbol='xmlSwitchToEncoding'/>
     <exports symbol='xmlFreeParserCtxt'/>
     <exports symbol='xmlHandleEntity'/>
     <exports symbol='xmlNewStringInputStream'/>
     <exports symbol='xmlNewEntityInputStream'/>
     <exports symbol='xmlPushInput'/>
     <exports symbol='xmlPopInput'/>
     <exports symbol='xmlFreeInputStream'/>
     <exports symbol='xmlNewInputFromFile'/>
     <exports symbol='xmlNewInputStream'/>
     <exports symbol='xmlSplitQName'/>
     <exports symbol='xmlNamespaceParseNCName'/>
     <exports symbol='xmlNamespaceParseQName'/>
     <exports symbol='xmlNamespaceParseNSDef'/>
     <exports symbol='xmlParseQuotedString'/>
     <exports symbol='xmlParseNamespace'/>
     <exports symbol='xmlScanName'/>
     <exports symbol='xmlParseName'/>
     <exports symbol='xmlParseNmtoken'/>
     <exports symbol='xmlParseEntityValue'/>
     <exports symbol='xmlParseAttValue'/>
     <exports symbol='xmlParseSystemLiteral'/>
     <exports symbol='xmlParsePubidLiteral'/>
     <exports symbol='xmlParseCharData'/>
     <exports symbol='xmlParseExternalID'/>
     <exports symbol='xmlParseComment'/>
     <exports symbol='xmlParsePITarget'/>
     <exports symbol='xmlParsePI'/>
     <exports symbol='xmlParseNotationDecl'/>
     <exports symbol='xmlParseEntityDecl'/>
     <exports symbol='xmlParseDefaultDecl'/>
     <exports symbol='xmlParseNotationType'/>
     <exports symbol='xmlParseEnumerationType'/>
     <exports symbol='xmlParseEnumeratedType'/>
     <exports symbol='xmlParseAttributeType'/>
     <exports symbol='xmlParseAttributeListDecl'/>
     <exports symbol='xmlParseElementMixedContentDecl'/>
     <exports symbol='xmlParseElementChildrenContentD'/>
     <exports symbol='xmlParseElementChildrenContentDecl'/>
     <exports symbol='xmlParseElementContentDecl'/>
     <exports symbol='xmlParseElementDecl'/>
     <exports symbol='xmlParseMarkupDecl'/>
     <exports symbol='xmlParseCharRef'/>
     <exports symbol='xmlParseEntityRef'/>
     <exports symbol='xmlParseReference'/>
     <exports symbol='xmlParsePEReference'/>
     <exports symbol='xmlParseDocTypeDecl'/>
     <exports symbol='xmlParseAttribute'/>
     <exports symbol='xmlParseStartTag'/>
     <exports symbol='xmlParseEndTag'/>
     <exports symbol='xmlParseCDSect'/>
     <exports symbol='xmlParseContent'/>
     <exports symbol='xmlParseElement'/>
     <exports symbol='xmlParseVersionNum'/>
     <exports symbol='xmlParseVersionInfo'/>
     <exports symbol='xmlParseEncName'/>
     <exports symbol='xmlParseEncodingDecl'/>
     <exports symbol='xmlParseSDDecl'/>
     <exports symbol='xmlParseXMLDecl'/>
     <exports symbol='xmlParseTextDecl'/>
     <exports symbol='xmlParseMisc'/>
     <exports symbol='xmlParseExternalSubset'/>
     <exports symbol='XML_SUBSTITUTE_NONE'/>
     <exports symbol='XML_SUBSTITUTE_REF'/>
     <exports symbol='XML_SUBSTITUTE_PEREF'/>
     <exports symbol='XML_SUBSTITUTE_BOTH'/>
     <exports symbol='xmlDecodeEntities'/>
     <exports symbol='xmlStringDecodeEntities'/>
     <exports symbol='nodePush'/>
     <exports symbol='nodePop'/>
     <exports symbol='inputPush'/>
     <exports symbol='inputPop'/>
     <exports symbol='namePop'/>
     <exports symbol='namePush'/>
     <exports symbol='xmlSkipBlankChars'/>
     <exports symbol='xmlStringCurrentChar'/>
     <exports symbol='xmlParserHandlePEReference'/>
     <exports symbol='xmlParserHandleReference'/>
     <exports symbol='xmlCheckLanguageID'/>
     <exports symbol='xmlCurrentChar'/>
     <exports symbol='xmlCopyCharMultiByte'/>
     <exports symbol='xmlCopyChar'/>
     <exports symbol='xmlNextChar'/>
     <exports symbol='xmlParserInputShrink'/>
     <exports symbol='htmlInitAutoClose'/>
     <exports symbol='htmlCreateFileParserCtxt'/>
     <exports symbol='xmlEntityReferenceFunc'/>
     <exports symbol='xmlSetEntityReferenceFunc'/>
    </file>
    <file name='tree'>
     <exports symbol='xmlParserInputBuffer'/>
     <exports symbol='xmlParserInputBufferPtr'/>
     <exports symbol='xmlOutputBuffer'/>
     <exports symbol='xmlOutputBufferPtr'/>
     <exports symbol='xmlParserInput'/>
     <exports symbol='xmlParserInputPtr'/>
     <exports symbol='xmlParserCtxt'/>
     <exports symbol='xmlParserCtxtPtr'/>
     <exports symbol='BASE_BUFFER_SIZE'/>
     <exports symbol='XML_XML_NAMESPACE'/>
     <exports symbol='xmlElementType'/>
     <exports symbol='xmlChar'/>
     <exports symbol='BAD_CAST'/>
     <exports symbol='xmlNotation'/>
     <exports symbol='xmlNotationPtr'/>
     <exports symbol='xmlAttributeType'/>
     <exports symbol='xmlAttributeDefault'/>
     <exports symbol='xmlEnumeration'/>
     <exports symbol='xmlEnumerationPtr'/>
     <exports symbol='xmlAttribute'/>
     <exports symbol='xmlAttributePtr'/>
     <exports symbol='xmlElementContentType'/>
     <exports symbol='xmlElementContentOccur'/>
     <exports symbol='xmlElementContent'/>
     <exports symbol='xmlElementContentPtr'/>
     <exports symbol='xmlElementTypeVal'/>
     <exports symbol='xmlElement'/>
     <exports symbol='xmlElementPtr'/>
     <exports symbol='XML_LOCAL_NAMESPACE'/>
     <exports symbol='xmlNsType'/>
     <exports symbol='xmlNs'/>
     <exports symbol='xmlNsPtr'/>
     <exports symbol='xmlDtd'/>
     <exports symbol='xmlDtdPtr'/>
     <exports symbol='xmlAttr'/>
     <exports symbol='xmlAttrPtr'/>
     <exports symbol='xmlID'/>
     <exports symbol='xmlIDPtr'/>
     <exports symbol='xmlRef'/>
     <exports symbol='xmlRefPtr'/>
     <exports symbol='xmlBufferAllocationScheme'/>
     <exports symbol='xmlBuffer'/>
     <exports symbol='xmlBufferPtr'/>
     <exports symbol='xmlNode'/>
     <exports symbol='xmlNodePtr'/>
     <exports symbol='XML_GET_CONTENT'/>
     <exports symbol='XML_GET_LINE'/>
     <exports symbol='xmlDoc'/>
     <exports symbol='xmlDocPtr'/>
     <exports symbol='xmlChildrenNode'/>
     <exports symbol='xmlRootNode'/>
     <exports symbol='xmlSetBufferAllocationScheme'/>
     <exports symbol='xmlGetBufferAllocationScheme'/>
     <exports symbol='xmlBufferCreate'/>
     <exports symbol='xmlBufferCreateSize'/>
     <exports symbol='xmlBufferResize'/>
     <exports symbol='xmlBufferFree'/>
     <exports symbol='xmlBufferDump'/>
     <exports symbol='xmlBufferAdd'/>
     <exports symbol='xmlBufferAddHead'/>
     <exports symbol='xmlBufferCat'/>
     <exports symbol='xmlBufferCCat'/>
     <exports symbol='xmlBufferShrink'/>
     <exports symbol='xmlBufferGrow'/>
     <exports symbol='xmlBufferEmpty'/>
     <exports symbol='xmlBufferContent'/>
     <exports symbol='xmlBufferSetAllocationScheme'/>
     <exports symbol='xmlBufferLength'/>
     <exports symbol='xmlCreateIntSubset'/>
     <exports symbol='xmlNewDtd'/>
     <exports symbol='xmlGetIntSubset'/>
     <exports symbol='xmlFreeDtd'/>
     <exports symbol='xmlNewGlobalNs'/>
     <exports symbol='xmlNewNs'/>
     <exports symbol='xmlFreeNs'/>
     <exports symbol='xmlFreeNsList'/>
     <exports symbol='xmlNewDoc'/>
     <exports symbol='xmlFreeDoc'/>
     <exports symbol='xmlNewDocProp'/>
     <exports symbol='xmlNewProp'/>
     <exports symbol='xmlNewNsProp'/>
     <exports symbol='xmlFreePropList'/>
     <exports symbol='xmlFreeProp'/>
     <exports symbol='xmlCopyProp'/>
     <exports symbol='xmlCopyPropList'/>
     <exports symbol='xmlCopyDtd'/>
     <exports symbol='xmlCopyDoc'/>
     <exports symbol='xmlNewDocNode'/>
     <exports symbol='xmlNewDocRawNode'/>
     <exports symbol='xmlNewNode'/>
     <exports symbol='xmlNewChild'/>
     <exports symbol='xmlNewTextChild'/>
     <exports symbol='xmlNewDocText'/>
     <exports symbol='xmlNewText'/>
     <exports symbol='xmlNewPI'/>
     <exports symbol='xmlNewDocTextLen'/>
     <exports symbol='xmlNewTextLen'/>
     <exports symbol='xmlNewDocComment'/>
     <exports symbol='xmlNewComment'/>
     <exports symbol='xmlNewCDataBlock'/>
     <exports symbol='xmlNewCharRef'/>
     <exports symbol='xmlNewReference'/>
     <exports symbol='xmlCopyNode'/>
     <exports symbol='xmlDocCopyNode'/>
     <exports symbol='xmlCopyNodeList'/>
     <exports symbol='xmlNewDocFragment'/>
     <exports symbol='xmlGetLineNo'/>
     <exports symbol='xmlGetNodePath'/>
     <exports symbol='xmlDocGetRootElement'/>
     <exports symbol='xmlGetLastChild'/>
     <exports symbol='xmlNodeIsText'/>
     <exports symbol='xmlIsBlankNode'/>
     <exports symbol='xmlDocSetRootElement'/>
     <exports symbol='xmlNodeSetName'/>
     <exports symbol='xmlAddChild'/>
     <exports symbol='xmlAddChildList'/>
     <exports symbol='xmlReplaceNode'/>
     <exports symbol='xmlAddSibling'/>
     <exports symbol='xmlAddPrevSibling'/>
     <exports symbol='xmlAddNextSibling'/>
     <exports symbol='xmlUnlinkNode'/>
     <exports symbol='xmlTextMerge'/>
     <exports symbol='xmlTextConcat'/>
     <exports symbol='xmlFreeNodeList'/>
     <exports symbol='xmlFreeNode'/>
     <exports symbol='xmlSetTreeDoc'/>
     <exports symbol='xmlSetListDoc'/>
     <exports symbol='xmlSearchNs'/>
     <exports symbol='xmlSearchNsByHref'/>
     <exports symbol='xmlGetNsList'/>
     <exports symbol='xmlSetNs'/>
     <exports symbol='xmlCopyNamespace'/>
     <exports symbol='xmlCopyNamespaceList'/>
     <exports symbol='xmlSetProp'/>
     <exports symbol='xmlGetProp'/>
     <exports symbol='xmlHasProp'/>
     <exports symbol='xmlHasNsProp'/>
     <exports symbol='xmlSetNsProp'/>
     <exports symbol='xmlGetNsProp'/>
     <exports symbol='xmlStringGetNodeList'/>
     <exports symbol='xmlStringLenGetNodeList'/>
     <exports symbol='xmlNodeListGetString'/>
     <exports symbol='xmlNodeListGetRawString'/>
     <exports symbol='xmlNodeSetContent'/>
     <exports symbol='xmlNodeSetContentLen'/>
     <exports symbol='xmlNodeAddContent'/>
     <exports symbol='xmlNodeAddContentLen'/>
     <exports symbol='xmlNodeGetContent'/>
     <exports symbol='xmlNodeGetLang'/>
     <exports symbol='xmlNodeSetLang'/>
     <exports symbol='xmlNodeGetSpacePreserve'/>
     <exports symbol='xmlNodeSetSpacePreserve'/>
     <exports symbol='xmlNodeGetBase'/>
     <exports symbol='xmlNodeSetBase'/>
     <exports symbol='xmlRemoveProp'/>
     <exports symbol='xmlUnsetProp'/>
     <exports symbol='xmlUnsetNsProp'/>
     <exports symbol='xmlBufferWriteXmlCHAR'/>
     <exports symbol='xmlBufferWriteCHAR'/>
     <exports symbol='xmlBufferWriteChar'/>
     <exports symbol='xmlBufferWriteQuotedString'/>
     <exports symbol='xmlReconciliateNs'/>
     <exports symbol='xmlDocDumpFormatMemory'/>
     <exports symbol='xmlDocDumpMemory'/>
     <exports symbol='xmlDocDumpMemoryEnc'/>
     <exports symbol='xmlDocDumpFormatMemoryEnc'/>
     <exports symbol='xmlDocDump'/>
     <exports symbol='xmlElemDump'/>
     <exports symbol='xmlSaveFile'/>
     <exports symbol='xmlSaveFormatFile'/>
     <exports symbol='xmlNodeDump'/>
     <exports symbol='xmlSaveFileTo'/>
     <exports symbol='xmlSaveFormatFileTo'/>
     <exports symbol='xmlNodeDumpOutput'/>
     <exports symbol='xmlSaveFormatFileEnc'/>
     <exports symbol='xmlSaveFileEnc'/>
     <exports symbol='xmlGetDocCompressMode'/>
     <exports symbol='xmlSetDocCompressMode'/>
     <exports symbol='xmlGetCompressMode'/>
     <exports symbol='xmlSetCompressMode'/>
    </file>
    <file name='HTMLtree'>
     <exports symbol='HTML_TEXT_NODE'/>
     <exports symbol='HTML_ENTITY_REF_NODE'/>
     <exports symbol='HTML_COMMENT_NODE'/>
     <exports symbol='HTML_PRESERVE_NODE'/>
     <exports symbol='HTML_PI_NODE'/>
     <exports symbol='htmlNewDoc'/>
     <exports symbol='htmlNewDocNoDtD'/>
     <exports symbol='htmlGetMetaEncoding'/>
     <exports symbol='htmlSetMetaEncoding'/>
     <exports symbol='htmlDocDumpMemory'/>
     <exports symbol='htmlDocDump'/>
     <exports symbol='htmlSaveFile'/>
     <exports symbol='htmlNodeDump'/>
     <exports symbol='htmlNodeDumpFile'/>
     <exports symbol='htmlNodeDumpFileFormat'/>
     <exports symbol='htmlSaveFileEnc'/>
     <exports symbol='htmlSaveFileFormat'/>
     <exports symbol='htmlNodeDumpFormatOutput'/>
     <exports symbol='htmlDocContentDumpOutput'/>
     <exports symbol='htmlDocContentDumpFormatOutput'/>
    </file>
    <file name='xpathInternals'>
     <exports symbol='xmlXPathSetError'/>
     <exports symbol='xmlXPathSetArityError'/>
     <exports symbol='xmlXPathSetTypeError'/>
     <exports symbol='xmlXPathGetError'/>
     <exports symbol='xmlXPathCheckError'/>
     <exports symbol='xmlXPathGetDocument'/>
     <exports symbol='xmlXPathGetContextNode'/>
     <exports symbol='xmlXPathPopBoolean'/>
     <exports symbol='xmlXPathPopNumber'/>
     <exports symbol='xmlXPathPopString'/>
     <exports symbol='xmlXPathPopNodeSet'/>
     <exports symbol='xmlXPathPopExternal'/>
     <exports symbol='xmlXPathReturnBoolean'/>
     <exports symbol='xmlXPathReturnTrue'/>
     <exports symbol='xmlXPathReturnFalse'/>
     <exports symbol='xmlXPathReturnNumber'/>
     <exports symbol='xmlXPathReturnString'/>
     <exports symbol='xmlXPathReturnEmptyString'/>
     <exports symbol='xmlXPathReturnNodeSet'/>
     <exports symbol='xmlXPathReturnEmptyNodeSet'/>
     <exports symbol='xmlXPathReturnExternal'/>
     <exports symbol='xmlXPathStackIsNodeSet'/>
     <exports symbol='xmlXPathStackIsExternal'/>
     <exports symbol='xmlXPathEmptyNodeSet'/>
     <exports symbol='CHECK_ERROR'/>
     <exports symbol='CHECK_ERROR0'/>
     <exports symbol='XP_ERROR'/>
     <exports symbol='XP_ERROR0'/>
     <exports symbol='CHECK_TYPE'/>
     <exports symbol='CHECK_TYPE0'/>
     <exports symbol='CHECK_ARITY'/>
     <exports symbol='CAST_TO_STRING'/>
     <exports symbol='CAST_TO_NUMBER'/>
     <exports symbol='CAST_TO_BOOLEAN'/>
     <exports symbol='xmlXPathVariableLookupFunc'/>
     <exports symbol='xmlXPathRegisterVariableLookup'/>
     <exports symbol='xmlXPathFuncLookupFunc'/>
     <exports symbol='xmlXPathRegisterFuncLookup'/>
     <exports symbol='xmlXPatherror'/>
     <exports symbol='xmlXPathDebugDumpObject'/>
     <exports symbol='xmlXPathDebugDumpCompExpr'/>
     <exports symbol='xmlXPathNodeSetContains'/>
     <exports symbol='xmlXPathDifference'/>
     <exports symbol='xmlXPathIntersection'/>
     <exports symbol='xmlXPathDistinctSorted'/>
     <exports symbol='xmlXPathDistinct'/>
     <exports symbol='xmlXPathHasSameNodes'/>
     <exports symbol='xmlXPathNodeLeadingSorted'/>
     <exports symbol='xmlXPathLeadingSorted'/>
     <exports symbol='xmlXPathNodeLeading'/>
     <exports symbol='xmlXPathLeading'/>
     <exports symbol='xmlXPathNodeTrailingSorted'/>
     <exports symbol='xmlXPathTrailingSorted'/>
     <exports symbol='xmlXPathNodeTrailing'/>
     <exports symbol='xmlXPathTrailing'/>
     <exports symbol='xmlXPathRegisterNs'/>
     <exports symbol='xmlXPathNsLookup'/>
     <exports symbol='xmlXPathRegisteredNsCleanup'/>
     <exports symbol='xmlXPathRegisterFunc'/>
     <exports symbol='xmlXPathRegisterFuncNS'/>
     <exports symbol='xmlXPathRegisterVariable'/>
     <exports symbol='xmlXPathRegisterVariableNS'/>
     <exports symbol='xmlXPathFunctionLookup'/>
     <exports symbol='xmlXPathFunctionLookupNS'/>
     <exports symbol='xmlXPathRegisteredFuncsCleanup'/>
     <exports symbol='xmlXPathVariableLookup'/>
     <exports symbol='xmlXPathVariableLookupNS'/>
     <exports symbol='xmlXPathRegisteredVariablesCleanup'/>
     <exports symbol='xmlXPathNewParserContext'/>
     <exports symbol='xmlXPathFreeParserContext'/>
     <exports symbol='valuePop'/>
     <exports symbol='valuePush'/>
     <exports symbol='xmlXPathNewString'/>
     <exports symbol='xmlXPathNewCString'/>
     <exports symbol='xmlXPathWrapString'/>
     <exports symbol='xmlXPathWrapCString'/>
     <exports symbol='xmlXPathNewFloat'/>
     <exports symbol='xmlXPathNewBoolean'/>
     <exports symbol='xmlXPathNewNodeSet'/>
     <exports symbol='xmlXPathNewValueTree'/>
     <exports symbol='xmlXPathNodeSetAdd'/>
     <exports symbol='xmlXPathNodeSetAddUnique'/>
     <exports symbol='xmlXPathNodeSetSort'/>
     <exports symbol='xmlXPathIdFunction'/>
     <exports symbol='xmlXPathRoot'/>
     <exports symbol='xmlXPathEvalExpr'/>
     <exports symbol='xmlXPathParseName'/>
     <exports symbol='xmlXPathParseNCName'/>
     <exports symbol='xmlXPathStringEvalNumber'/>
     <exports symbol='xmlXPathEvaluatePredicateResult'/>
     <exports symbol='xmlXPathInit'/>
     <exports symbol='xmlXPathStringFunction'/>
     <exports symbol='xmlXPathRegisterAllFunctions'/>
     <exports symbol='xmlXPathNodeSetCreate'/>
     <exports symbol='xmlXPathNodeSetMerge'/>
     <exports symbol='xmlXPathNodeSetDel'/>
     <exports symbol='xmlXPathNodeSetRemove'/>
     <exports symbol='xmlXPathFreeNodeSet'/>
     <exports symbol='xmlXPathNewNodeSetList'/>
     <exports symbol='xmlXPathWrapNodeSet'/>
     <exports symbol='xmlXPathWrapExternal'/>
     <exports symbol='xmlXPathFreeNodeSetList'/>
     <exports symbol='xmlXPathFreeObject'/>
     <exports symbol='xmlXPathNewContext'/>
     <exports symbol='xmlXPathFreeContext'/>
     <exports symbol='xmlXPathEqualValues'/>
     <exports symbol='xmlXPathCompareValues'/>
     <exports symbol='xmlXPathValueFlipSign'/>
     <exports symbol='xmlXPathAddValues'/>
     <exports symbol='xmlXPathSubValues'/>
     <exports symbol='xmlXPathMultValues'/>
     <exports symbol='xmlXPathDivValues'/>
     <exports symbol='xmlXPathModValues'/>
     <exports symbol='xmlXPathIsNodeType'/>
     <exports symbol='xmlXPathNextSelf'/>
     <exports symbol='xmlXPathNextChild'/>
     <exports symbol='xmlXPathNextDescendant'/>
     <exports symbol='xmlXPathNextDescendantOrSelf'/>
     <exports symbol='xmlXPathNextParent'/>
     <exports symbol='xmlXPathNextAncestorOrSelf'/>
     <exports symbol='xmlXPathNextFollowingSibling'/>
     <exports symbol='xmlXPathNextFollowing'/>
     <exports symbol='xmlXPathNextNamespace'/>
     <exports symbol='xmlXPathNextAttribute'/>
     <exports symbol='xmlXPathNextPreceding'/>
     <exports symbol='xmlXPathNextAncestor'/>
     <exports symbol='xmlXPathNextPrecedingSibling'/>
     <exports symbol='xmlXPathLastFunction'/>
     <exports symbol='xmlXPathPositionFunction'/>
     <exports symbol='xmlXPathCountFunction'/>
     <exports symbol='xmlXPathLocalNameFunction'/>
     <exports symbol='xmlXPathNamespaceURIFunction'/>
     <exports symbol='xmlXPathStringLengthFunction'/>
     <exports symbol='xmlXPathConcatFunction'/>
     <exports symbol='xmlXPathContainsFunction'/>
     <exports symbol='xmlXPathStartsWithFunction'/>
     <exports symbol='xmlXPathSubstringFunction'/>
     <exports symbol='xmlXPathSubstringBeforeFunction'/>
     <exports symbol='xmlXPathSubstringAfterFunction'/>
     <exports symbol='xmlXPathNormalizeFunction'/>
     <exports symbol='xmlXPathTranslateFunction'/>
     <exports symbol='xmlXPathNotFunction'/>
     <exports symbol='xmlXPathTrueFunction'/>
     <exports symbol='xmlXPathFalseFunction'/>
     <exports symbol='xmlXPathLangFunction'/>
     <exports symbol='xmlXPathNumberFunction'/>
     <exports symbol='xmlXPathSumFunction'/>
     <exports symbol='xmlXPathFloorFunction'/>
     <exports symbol='xmlXPathCeilingFunction'/>
     <exports symbol='xmlXPathRoundFunction'/>
     <exports symbol='xmlXPathBooleanFunction'/>
    </file>
    <file name='xinclude'>
     <exports symbol='xmlXIncludeProcess'/>
    </file>
    <file name='xpointer'>
     <exports symbol='xmlLocationSet'/>
     <exports symbol='xmlLocationSetPtr'/>
     <exports symbol='xmlXPtrLocationSetCreate'/>
     <exports symbol='xmlXPtrFreeLocationSet'/>
     <exports symbol='xmlXPtrLocationSetMerge'/>
     <exports symbol='xmlXPtrNewRange'/>
     <exports symbol='xmlXPtrNewRangePoints'/>
     <exports symbol='xmlXPtrNewRangeNodePoint'/>
     <exports symbol='xmlXPtrNewRangePointNode'/>
     <exports symbol='xmlXPtrNewRangeNodes'/>
     <exports symbol='xmlXPtrNewLocationSetNodes'/>
     <exports symbol='xmlXPtrNewLocationSetNodeSet'/>
     <exports symbol='xmlXPtrNewRangeNodeObject'/>
     <exports symbol='xmlXPtrNewCollapsedRange'/>
     <exports symbol='xmlXPtrLocationSetAdd'/>
     <exports symbol='xmlXPtrWrapLocationSet'/>
     <exports symbol='xmlXPtrLocationSetDel'/>
     <exports symbol='xmlXPtrLocationSetRemove'/>
     <exports symbol='xmlXPtrNewContext'/>
     <exports symbol='xmlXPtrEval'/>
     <exports symbol='xmlXPtrRangeToFunction'/>
     <exports symbol='xmlXPtrBuildNodeList'/>
     <exports symbol='xmlXPtrEvalRangePredicate'/>
    </file>
    <file name='threads'>
     <exports symbol='xmlMutex'/>
     <exports symbol='xmlMutexPtr'/>
     <exports symbol='xmlNewMutex'/>
     <exports symbol='xmlMutexLock'/>
     <exports symbol='xmlMutexUnlock'/>
     <exports symbol='xmlFreeMutex'/>
     <exports symbol='xmlRMutex'/>
     <exports symbol='xmlRMutexPtr'/>
     <exports symbol='xmlNewRMutex'/>
     <exports symbol='xmlRMutexLock'/>
     <exports symbol='xmlRMutexUnlock'/>
     <exports symbol='xmlFreeRMutex'/>
     <exports symbol='xmlInitThreads'/>
     <exports symbol='xmlLockLibrary'/>
     <exports symbol='xmlUnlockLibrary'/>
     <exports symbol='xmlGetThreadId'/>
     <exports symbol='xmlIsMainThread'/>
     <exports symbol='xmlCleanupThreads'/>
     <exports symbol='xmlGetGlobalState'/>
    </file>
    <file name='globals'>
     <exports symbol='xmlGlobalState'/>
     <exports symbol='xmlGlobalStatePtr'/>
     <exports symbol='xmlInitializeGlobalState'/>
     <exports symbol='xmlMalloc'/>
     <exports symbol='xmlRealloc'/>
     <exports symbol='xmlFree'/>
     <exports symbol='xmlMemStrdup'/>
     <exports symbol='docbDefaultSAXHandler'/>
     <exports symbol='htmlDefaultSAXHandler'/>
     <exports symbol='oldXMLWDcompatibility'/>
     <exports symbol='xmlBufferAllocScheme'/>
     <exports symbol='xmlDefaultBufferSize'/>
     <exports symbol='xmlDefaultSAXHandler'/>
     <exports symbol='xmlDefaultSAXLocator'/>
     <exports symbol='xmlDoValidityCheckingDefaultValue'/>
     <exports symbol='xmlGenericError'/>
     <exports symbol='xmlGenericErrorContext'/>
     <exports symbol='xmlGetWarningsDefaultValue'/>
     <exports symbol='xmlIndentTreeOutput'/>
     <exports symbol='xmlKeepBlanksDefaultValue'/>
     <exports symbol='xmlLineNumbersDefaultValue'/>
     <exports symbol='xmlLoadExtDtdDefaultValue'/>
     <exports symbol='xmlParserDebugEntities'/>
     <exports symbol='xmlParserVersion'/>
     <exports symbol='xmlPedanticParserDefaultValue'/>
     <exports symbol='xmlSaveNoEmptyTags'/>
     <exports symbol='xmlSubstituteEntitiesDefaultValue'/>
    </file>
    <file name='catalog'>
     <exports symbol='XML_CATALOGS_NAMESPACE'/>
     <exports symbol='XML_CATALOG_PI'/>
     <exports symbol='xmlCatalogPrefer'/>
     <exports symbol='xmlCatalogAllow'/>
     <exports symbol='xmlCatalog'/>
     <exports symbol='xmlCatalogPtr'/>
     <exports symbol='xmlNewCatalog'/>
     <exports symbol='xmlLoadACatalog'/>
     <exports symbol='xmlLoadSGMLSuperCatalog'/>
     <exports symbol='xmlConvertSGMLCatalog'/>
     <exports symbol='xmlACatalogAdd'/>
     <exports symbol='xmlACatalogRemove'/>
     <exports symbol='xmlACatalogResolve'/>
     <exports symbol='xmlACatalogResolveSystem'/>
     <exports symbol='xmlACatalogResolvePublic'/>
     <exports symbol='xmlACatalogResolveURI'/>
     <exports symbol='xmlACatalogDump'/>
     <exports symbol='xmlFreeCatalog'/>
     <exports symbol='xmlCatalogIsEmpty'/>
     <exports symbol='xmlInitializeCatalog'/>
     <exports symbol='xmlLoadCatalog'/>
     <exports symbol='xmlLoadCatalogs'/>
     <exports symbol='xmlCatalogCleanup'/>
     <exports symbol='xmlCatalogDump'/>
     <exports symbol='xmlCatalogResolve'/>
     <exports symbol='xmlCatalogResolveSystem'/>
     <exports symbol='xmlCatalogResolvePublic'/>
     <exports symbol='xmlCatalogResolveURI'/>
     <exports symbol='xmlCatalogAdd'/>
     <exports symbol='xmlCatalogRemove'/>
     <exports symbol='xmlParseCatalogFile'/>
     <exports symbol='xmlCatalogConvert'/>
     <exports symbol='xmlCatalogFreeLocal'/>
     <exports symbol='xmlCatalogAddLocal'/>
     <exports symbol='xmlCatalogLocalResolve'/>
     <exports symbol='xmlCatalogLocalResolveURI'/>
     <exports symbol='xmlCatalogSetDebug'/>
     <exports symbol='xmlCatalogSetDefaultPrefer'/>
     <exports symbol='xmlCatalogSetDefaults'/>
     <exports symbol='xmlCatalogGetDefaults'/>
     <exports symbol='xmlCatalogGetSystem'/>
     <exports symbol='xmlCatalogGetPublic'/>
    </file>
    <file name='xmlversion'>
     <exports symbol='xmlCheckVersion'/>
     <exports symbol='LIBXML_DOTTED_VERSION'/>
     <exports symbol='LIBXML_VERSION'/>
     <exports symbol='LIBXML_VERSION_STRING'/>
     <exports symbol='LIBXML_TEST_VERSION'/>
     <exports symbol='WITH_TRIO'/>
     <exports symbol='WITHOUT_TRIO'/>
     <exports symbol='LIBXML_THREAD_ENABLED'/>
     <exports symbol='LIBXML_FTP_ENABLED'/>
     <exports symbol='LIBXML_HTTP_ENABLED'/>
     <exports symbol='LIBXML_HTML_ENABLED'/>
     <exports symbol='LIBXML_CATALOG_ENABLED'/>
     <exports symbol='LIBXML_DOCB_ENABLED'/>
     <exports symbol='LIBXML_XPATH_ENABLED'/>
     <exports symbol='LIBXML_XPTR_ENABLED'/>
     <exports symbol='LIBXML_XINCLUDE_ENABLED'/>
     <exports symbol='LIBXML_ICONV_ENABLED'/>
     <exports symbol='LIBXML_DEBUG_ENABLED'/>
     <exports symbol='DEBUG_MEMORY_LOCATION'/>
     <exports symbol='LIBXML_DLL_IMPORT'/>
     <exports symbol='ATTRIBUTE_UNUSED'/>
    </file>
    <file name='parser'>
     <exports symbol='XML_DEFAULT_VERSION'/>
     <exports symbol='xmlParserInputDeallocate'/>
     <exports symbol='xmlParserInput'/>
     <exports symbol='xmlParserNodeInfo'/>
     <exports symbol='xmlParserNodeInfoPtr'/>
     <exports symbol='xmlParserNodeInfoSeq'/>
     <exports symbol='xmlParserNodeInfoSeqPtr'/>
     <exports symbol='xmlParserInputState'/>
     <exports symbol='XML_DETECT_IDS'/>
     <exports symbol='XML_COMPLETE_ATTRS'/>
     <exports symbol='xmlParserCtxt'/>
     <exports symbol='xmlSAXLocator'/>
     <exports symbol='xmlSAXLocatorPtr'/>
     <exports symbol='resolveEntitySAXFunc'/>
     <exports symbol='internalSubsetSAXFunc'/>
     <exports symbol='externalSubsetSAXFunc'/>
     <exports symbol='getEntitySAXFunc'/>
     <exports symbol='getParameterEntitySAXFunc'/>
     <exports symbol='entityDeclSAXFunc'/>
     <exports symbol='notationDeclSAXFunc'/>
     <exports symbol='attributeDeclSAXFunc'/>
     <exports symbol='elementDeclSAXFunc'/>
     <exports symbol='unparsedEntityDeclSAXFunc'/>
     <exports symbol='setDocumentLocatorSAXFunc'/>
     <exports symbol='startDocumentSAXFunc'/>
     <exports symbol='endDocumentSAXFunc'/>
     <exports symbol='startElementSAXFunc'/>
     <exports symbol='endElementSAXFunc'/>
     <exports symbol='attributeSAXFunc'/>
     <exports symbol='referenceSAXFunc'/>
     <exports symbol='charactersSAXFunc'/>
     <exports symbol='ignorableWhitespaceSAXFunc'/>
     <exports symbol='processingInstructionSAXFunc'/>
     <exports symbol='commentSAXFunc'/>
     <exports symbol='cdataBlockSAXFunc'/>
     <exports symbol='warningSAXFunc'/>
     <exports symbol='errorSAXFunc'/>
     <exports symbol='fatalErrorSAXFunc'/>
     <exports symbol='isStandaloneSAXFunc'/>
     <exports symbol='hasInternalSubsetSAXFunc'/>
     <exports symbol='hasExternalSubsetSAXFunc'/>
     <exports symbol='xmlSAXHandler'/>
     <exports symbol='xmlSAXHandlerPtr'/>
     <exports symbol='xmlExternalEntityLoader'/>
     <exports symbol='xmlSubstituteEntitiesDefaultValue'/>
     <exports symbol='xmlInitParser'/>
     <exports symbol='xmlCleanupParser'/>
     <exports symbol='xmlParserInputRead'/>
     <exports symbol='xmlParserInputGrow'/>
     <exports symbol='xmlStrdup'/>
     <exports symbol='xmlStrndup'/>
     <exports symbol='xmlCharStrndup'/>
     <exports symbol='xmlCharStrdup'/>
     <exports symbol='xmlStrsub'/>
     <exports symbol='xmlStrchr'/>
     <exports symbol='xmlStrstr'/>
     <exports symbol='xmlStrcasestr'/>
     <exports symbol='xmlStrcmp'/>
     <exports symbol='xmlStrncmp'/>
     <exports symbol='xmlStrcasecmp'/>
     <exports symbol='xmlStrncasecmp'/>
     <exports symbol='xmlStrEqual'/>
     <exports symbol='xmlStrlen'/>
     <exports symbol='xmlStrcat'/>
     <exports symbol='xmlStrncat'/>
     <exports symbol='xmlParseDoc'/>
     <exports symbol='xmlParseMemory'/>
     <exports symbol='xmlParseFile'/>
     <exports symbol='xmlSubstituteEntitiesDefault'/>
     <exports symbol='xmlKeepBlanksDefault'/>
     <exports symbol='xmlStopParser'/>
     <exports symbol='xmlPedanticParserDefault'/>
     <exports symbol='xmlLineNumbersDefault'/>
     <exports symbol='xmlRecoverDoc'/>
     <exports symbol='xmlRecoverMemory'/>
     <exports symbol='xmlRecoverFile'/>
     <exports symbol='xmlParseDocument'/>
     <exports symbol='xmlParseExtParsedEnt'/>
     <exports symbol='xmlSAXParseDoc'/>
     <exports symbol='xmlSAXUserParseFile'/>
     <exports symbol='xmlSAXUserParseMemory'/>
     <exports symbol='xmlSAXParseMemory'/>
     <exports symbol='xmlSAXParseFile'/>
     <exports symbol='xmlSAXParseFileWithData'/>
     <exports symbol='xmlSAXParseEntity'/>
     <exports symbol='xmlParseEntity'/>
     <exports symbol='xmlParseDTD'/>
     <exports symbol='xmlSAXParseDTD'/>
     <exports symbol='xmlIOParseDTD'/>
     <exports symbol='xmlParseBalancedChunkMemory'/>
     <exports symbol='xmlParseExternalEntity'/>
     <exports symbol='xmlParseCtxtExternalEntity'/>
     <exports symbol='xmlDefaultSAXHandlerInit'/>
     <exports symbol='htmlDefaultSAXHandlerInit'/>
     <exports symbol='xmlInitParserCtxt'/>
     <exports symbol='xmlClearParserCtxt'/>
     <exports symbol='xmlFreeParserCtxt'/>
     <exports symbol='xmlSetupParserForBuffer'/>
     <exports symbol='xmlCreateDocParserCtxt'/>
     <exports symbol='xmlGetFeaturesList'/>
     <exports symbol='xmlGetFeature'/>
     <exports symbol='xmlSetFeature'/>
     <exports symbol='xmlCreatePushParserCtxt'/>
     <exports symbol='xmlParseChunk'/>
     <exports symbol='xmlCreateIOParserCtxt'/>
     <exports symbol='xmlNewIOInputStream'/>
     <exports symbol='xmlParserFindNodeInfo'/>
     <exports symbol='xmlInitNodeInfoSeq'/>
     <exports symbol='xmlClearNodeInfoSeq'/>
     <exports symbol='xmlParserFindNodeInfoIndex'/>
     <exports symbol='xmlParserAddNodeInfo'/>
     <exports symbol='xmlSetExternalEntityLoader'/>
     <exports symbol='xmlGetExternalEntityLoader'/>
     <exports symbol='xmlLoadExternalEntity'/>
    </file>
    <file name='xmlerror'>
     <exports symbol='xmlParserErrors'/>
     <exports symbol='xmlGenericErrorFunc'/>
     <exports symbol='xmlSetGenericErrorFunc'/>
     <exports symbol='initGenericErrorDefaultFunc'/>
     <exports symbol='xmlParserError'/>
     <exports symbol='xmlParserWarning'/>
     <exports symbol='xmlParserValidityError'/>
     <exports symbol='xmlParserValidityWarning'/>
     <exports symbol='xmlParserPrintFileInfo'/>
     <exports symbol='xmlParserPrintFileContext'/>
    </file>
    <file name='encoding'>
     <exports symbol='xmlCharEncoding'/>
     <exports symbol='xmlCharEncodingInputFunc'/>
     <exports symbol='xmlCharEncodingOutputFunc'/>
     <exports symbol='xmlCharEncodingHandler'/>
     <exports symbol='xmlCharEncodingHandlerPtr'/>
     <exports symbol='xmlInitCharEncodingHandlers'/>
     <exports symbol='xmlCleanupCharEncodingHandlers'/>
     <exports symbol='xmlRegisterCharEncodingHandler'/>
     <exports symbol='xmlGetCharEncodingHandler'/>
     <exports symbol='xmlFindCharEncodingHandler'/>
     <exports symbol='xmlAddEncodingAlias'/>
     <exports symbol='xmlDelEncodingAlias'/>
     <exports symbol='xmlGetEncodingAlias'/>
     <exports symbol='xmlCleanupEncodingAliases'/>
     <exports symbol='xmlParseCharEncoding'/>
     <exports symbol='xmlGetCharEncodingName'/>
     <exports symbol='xmlDetectCharEncoding'/>
     <exports symbol='xmlCharEncOutFunc'/>
     <exports symbol='xmlCharEncInFunc'/>
     <exports symbol='xmlCharEncFirstLine'/>
     <exports symbol='xmlCharEncCloseFunc'/>
     <exports symbol='UTF8Toisolat1'/>
     <exports symbol='isolat1ToUTF8'/>
     <exports symbol='xmlCheckUTF8'/>
     <exports symbol='xmlUTF8Strsize'/>
     <exports symbol='xmlUTF8Strndup'/>
     <exports symbol='xmlUTF8Strpos'/>
     <exports symbol='xmlUTF8Strloc'/>
     <exports symbol='xmlUTF8Strsub'/>
     <exports symbol='xmlUTF8Strlen'/>
    </file>
    <file name='hash'>
     <exports symbol='xmlHashTable'/>
     <exports symbol='xmlHashTablePtr'/>
     <exports symbol='xmlHashDeallocator'/>
     <exports symbol='xmlHashCopier'/>
     <exports symbol='xmlHashScanner'/>
     <exports symbol='xmlHashScannerFull'/>
     <exports symbol='xmlHashCreate'/>
     <exports symbol='xmlHashFree'/>
     <exports symbol='xmlHashAddEntry'/>
     <exports symbol='xmlHashUpdateEntry'/>
     <exports symbol='xmlHashAddEntry2'/>
     <exports symbol='xmlHashUpdateEntry2'/>
     <exports symbol='xmlHashAddEntry3'/>
     <exports symbol='xmlHashUpdateEntry3'/>
     <exports symbol='xmlHashRemoveEntry'/>
     <exports symbol='xmlHashRemoveEntry2'/>
     <exports symbol='xmlHashRemoveEntry3'/>
     <exports symbol='xmlHashLookup'/>
     <exports symbol='xmlHashLookup2'/>
     <exports symbol='xmlHashLookup3'/>
     <exports symbol='xmlHashCopy'/>
     <exports symbol='xmlHashSize'/>
     <exports symbol='xmlHashScan'/>
     <exports symbol='xmlHashScan3'/>
     <exports symbol='xmlHashScanFull'/>
     <exports symbol='xmlHashScanFull3'/>
    </file>
    <file name='xmlIO'>
     <exports symbol='xmlInputMatchCallback'/>
     <exports symbol='xmlInputOpenCallback'/>
     <exports symbol='xmlInputReadCallback'/>
     <exports symbol='xmlInputCloseCallback'/>
     <exports symbol='xmlParserInputBuffer'/>
     <exports symbol='xmlOutputMatchCallback'/>
     <exports symbol='xmlOutputOpenCallback'/>
     <exports symbol='xmlOutputWriteCallback'/>
     <exports symbol='xmlOutputCloseCallback'/>
     <exports symbol='xmlOutputBuffer'/>
     <exports symbol='xmlCleanupInputCallbacks'/>
     <exports symbol='xmlCleanupOutputCallbacks'/>
     <exports symbol='xmlRegisterDefaultInputCallbacks'/>
     <exports symbol='xmlAllocParserInputBuffer'/>
     <exports symbol='xmlParserInputBufferCreateFname'/>
     <exports symbol='xmlParserInputBufferCreateFilename'/>
     <exports symbol='xmlParserInputBufferCreateFile'/>
     <exports symbol='xmlParserInputBufferCreateFd'/>
     <exports symbol='xmlParserInputBufferCreateMem'/>
     <exports symbol='xmlParserInputBufferCreateIO'/>
     <exports symbol='xmlParserInputBufferRead'/>
     <exports symbol='xmlParserInputBufferGrow'/>
     <exports symbol='xmlParserInputBufferPush'/>
     <exports symbol='xmlFreeParserInputBuffer'/>
     <exports symbol='xmlParserGetDirectory'/>
     <exports symbol='xmlRegisterInputCallbacks'/>
     <exports symbol='xmlRegisterDefaultOutputCallbacks'/>
     <exports symbol='xmlAllocOutputBuffer'/>
     <exports symbol='xmlOutputBufferCreateFilename'/>
     <exports symbol='xmlOutputBufferCreateFile'/>
     <exports symbol='xmlOutputBufferCreateFd'/>
     <exports symbol='xmlOutputBufferCreateIO'/>
     <exports symbol='xmlOutputBufferWrite'/>
     <exports symbol='xmlOutputBufferWriteString'/>
     <exports symbol='xmlOutputBufferFlush'/>
     <exports symbol='xmlOutputBufferClose'/>
     <exports symbol='xmlRegisterOutputCallbacks'/>
     <exports symbol='xmlIOHTTPOpenW'/>
     <exports symbol='xmlRegisterHTTPPostCallbacks'/>
     <exports symbol='xmlNoNetExternalEntityLoader'/>
    </file>
    <file name='xpath'>
     <exports symbol='xmlXPathContext'/>
     <exports symbol='xmlXPathContextPtr'/>
     <exports symbol='xmlXPathParserContext'/>
     <exports symbol='xmlXPathParserContextPtr'/>
     <exports symbol='xmlXPathError'/>
     <exports symbol='xmlNodeSet'/>
     <exports symbol='xmlNodeSetPtr'/>
     <exports symbol='xmlXPathObjectType'/>
     <exports symbol='xmlXPathObject'/>
     <exports symbol='xmlXPathObjectPtr'/>
     <exports symbol='xmlXPathConvertFunc'/>
     <exports symbol='xmlXPathType'/>
     <exports symbol='xmlXPathTypePtr'/>
     <exports symbol='xmlXPathVariable'/>
     <exports symbol='xmlXPathVariablePtr'/>
     <exports symbol='xmlXPathEvalFunc'/>
     <exports symbol='xmlXPathFunct'/>
     <exports symbol='xmlXPathFuncPtr'/>
     <exports symbol='xmlXPathAxisFunc'/>
     <exports symbol='xmlXPathAxis'/>
     <exports symbol='xmlXPathAxisPtr'/>
     <exports symbol='xmlXPathCompExpr'/>
     <exports symbol='xmlXPathCompExprPtr'/>
     <exports symbol='xmlXPathFunction'/>
     <exports symbol='xmlXPathIsNaN'/>
     <exports symbol='xmlXPathIsInf'/>
     <exports symbol='xmlXPathNodeSetGetLength'/>
     <exports symbol='xmlXPathNodeSetItem'/>
     <exports symbol='xmlXPathNodeSetIsEmpty'/>
     <exports symbol='xmlXPathFreeObject'/>
     <exports symbol='xmlXPathNodeSetCreate'/>
     <exports symbol='xmlXPathFreeNodeSetList'/>
     <exports symbol='xmlXPathFreeNodeSet'/>
     <exports symbol='xmlXPathObjectCopy'/>
     <exports symbol='xmlXPathCmpNodes'/>
     <exports symbol='xmlXPathCastNumberToBoolean'/>
     <exports symbol='xmlXPathCastStringToBoolean'/>
     <exports symbol='xmlXPathCastNodeSetToBoolean'/>
     <exports symbol='xmlXPathCastToBoolean'/>
     <exports symbol='xmlXPathCastBooleanToNumber'/>
     <exports symbol='xmlXPathCastStringToNumber'/>
     <exports symbol='xmlXPathCastNodeToNumber'/>
     <exports symbol='xmlXPathCastNodeSetToNumber'/>
     <exports symbol='xmlXPathCastToNumber'/>
     <exports symbol='xmlXPathCastBooleanToString'/>
     <exports symbol='xmlXPathCastNumberToString'/>
     <exports symbol='xmlXPathCastNodeToString'/>
     <exports symbol='xmlXPathCastNodeSetToString'/>
     <exports symbol='xmlXPathCastToString'/>
     <exports symbol='xmlXPathConvertBoolean'/>
     <exports symbol='xmlXPathConvertNumber'/>
     <exports symbol='xmlXPathConvertString'/>
     <exports symbol='xmlXPathInit'/>
     <exports symbol='xmlXPathNewContext'/>
     <exports symbol='xmlXPathFreeContext'/>
     <exports symbol='xmlXPathEval'/>
     <exports symbol='xmlXPathEvalExpression'/>
     <exports symbol='xmlXPathEvalPredicate'/>
     <exports symbol='xmlXPathCompile'/>
     <exports symbol='xmlXPathCompiledEval'/>
     <exports symbol='xmlXPathFreeCompExpr'/>
    </file>
  </files>
  <symbols>
    <macro name='ATTRIBUTE_UNUSED' file='xmlversion' info='Macro used to signal to GCC unused function parameters'/>
    <macro name='BAD_CAST' file='tree' info='Macro to cast a string to an xmlChar * when one know its safe.'/>
    <macro name='BASE_BUFFER_SIZE' file='tree'/>
    <macro name='CAST_TO_BOOLEAN' file='xpathInternals' info='Macro to try to cast the value on the top of the XPath stack to a boolean'/>
    <macro name='CAST_TO_NUMBER' file='xpathInternals' info='Macro to try to cast the value on the top of the XPath stack to a number'/>
    <macro name='CAST_TO_STRING' file='xpathInternals' info='Macro to try to cast the value on the top of the XPath stack to a string'/>
    <macro name='CHECK_ARITY' file='xpathInternals' info='Macro to check that the number of args passed to an XPath function matches'/>
    <macro name='CHECK_ERROR' file='xpathInternals' info='macro to return from the function if an XPath error was detected'/>
    <macro name='CHECK_ERROR0' file='xpathInternals' info='macro to return 0 from the function if an XPath error was detected'/>
    <macro name='CHECK_TYPE' file='xpathInternals' info='Macro to check that the value on top of the XPath stack is of a given type.'/>
    <macro name='CHECK_TYPE0' file='xpathInternals' info='Macro to check that the value on top of the XPath stack is of a given type. return(0) in case of failure'/>
    <macro name='DEBUG_MEMORY' file='xmlmemory' info='should be activated only done when debugging libxml. It replaces the allocator with a collect and debug shell to the libc allocator. DEBUG_MEMORY should be activated only when debugging libxml i.e. if libxml has been configured with --with-debug-mem too'/>
    <macro name='DEBUG_MEMORY_LOCATION' file='xmlversion' info='Whether the memory debugging is configured in'/>
    <macro name='HTML_COMMENT_NODE' file='HTMLtree' info='Macro, a comment in a HTML document is really implemented the same way as a comment in an XML document.'/>
    <macro name='HTML_ENTITY_REF_NODE' file='HTMLtree' info='Macro, an entity reference in a HTML document is really implemented the same way as an entity reference in an XML document.'/>
    <macro name='HTML_PI_NODE' file='HTMLtree' info='Macro, a processing instruction in a HTML document is really implemented the same way as a processing instruction in an XML document.'/>
    <macro name='HTML_PRESERVE_NODE' file='HTMLtree' info='Macro, a preserved node in a HTML document is really implemented the same way as a CDATA section in an XML document.'/>
    <macro name='HTML_TEXT_NODE' file='HTMLtree' info='Macro, a text node in a HTML document is really implemented the same way as a text node in an XML document.'/>
    <macro name='INPUT_CHUNK' file='parserInternals' info='The parser tries to always have that amount of input ready one of the point is providing context when reporting errors'/>
    <macro name='IS_BASECHAR' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_BLANK' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_CHAR' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_COMBINING' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_DIGIT' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_EXTENDER' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_IDEOGRAPHIC' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_LETTER' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='IS_PUBIDCHAR' file='parserInternals' info='Macro to check the following production in the XML spec '/>
    <macro name='LIBXML_CATALOG_ENABLED' file='xmlversion' info='Whether the Catalog support is configured in'/>
    <macro name='LIBXML_DEBUG_ENABLED' file='xmlversion' info='Whether Debugging module is configured in'/>
    <macro name='LIBXML_DLL_IMPORT' file='xmlversion' info='Used on Windows (MS C compiler only) to declare a variable as imported from the library. This macro should be empty when compiling libxml itself. It should expand to __declspec(dllimport) when the client code includes this header, and that only if the client links dynamically against libxml. For this to work, we need three macros. One tells us which compiler is being used and luckily the compiler defines such a thing: _MSC_VER. The second macro tells us if we are compiling libxml or the client code and we define the macro IN_LIBXML on the compiler's command line for this purpose. The third macro, LIBXML_STATIC, must be defined by any client code which links against libxml statically.'/>
    <macro name='LIBXML_DOCB_ENABLED' file='xmlversion' info='Whether the SGML Docbook support is configured in'/>
    <macro name='LIBXML_DOTTED_VERSION' file='xmlversion' info='the version string like "1.2.3"'/>
    <macro name='LIBXML_FTP_ENABLED' file='xmlversion' info='Whether the FTP support is configured in'/>
    <macro name='LIBXML_HTML_ENABLED' file='xmlversion' info='Whether the HTML support is configured in'/>
    <macro name='LIBXML_HTTP_ENABLED' file='xmlversion' info='Whether the HTTP support is configured in'/>
    <macro name='LIBXML_ICONV_ENABLED' file='xmlversion' info='Whether iconv support is available'/>
    <macro name='LIBXML_TEST_VERSION' file='xmlversion' info='Macro to check that the libxml version in use is compatible with the version the software has been compiled against'/>
    <macro name='LIBXML_THREAD_ENABLED' file='xmlversion'/>
    <macro name='LIBXML_VERSION' file='xmlversion' info='the version number: 1.2.3 value is 1002003'/>
    <macro name='LIBXML_VERSION_STRING' file='xmlversion' info='the version number string, 1.2.3 value is "1002003"'/>
    <macro name='LIBXML_XINCLUDE_ENABLED' file='xmlversion' info='Whether XInclude is configured in'/>
    <macro name='LIBXML_XPATH_ENABLED' file='xmlversion' info='Whether XPath is configured in'/>
    <macro name='LIBXML_XPTR_ENABLED' file='xmlversion' info='Whether XPointer is configured in'/>
    <macro name='MEM_LIST' file='xmlmemory' info='keep track of all allocated blocks for error reporting'/>
    <macro name='MOVETO_ENDTAG' file='parserInternals' info='Skips to the next '&gt;' char'/>
    <macro name='MOVETO_STARTTAG' file='parserInternals' info='Skips to the next '&lt;' char'/>
    <macro name='SKIP_EOL' file='parserInternals' info='Skips the end of line chars'/>
    <function name='UTF8ToHtml' file='HTMLparser'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out.</info>
      <return type='int'/>
      <arg name='out' type='unsigned char *'/>
      <arg name='outlen' type='int *'/>
      <arg name='in' type='const unsigned char *'/>
      <arg name='inlen' type='int *'/>
    </function>
    <function name='UTF8Toisolat1' file='encoding'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ISO Latin 1 block of chars out.</info>
      <return type='int'/>
      <arg name='out' type='unsigned char *'/>
      <arg name='outlen' type='int *'/>
      <arg name='in' type='const unsigned char *'/>
      <arg name='inlen' type='int *'/>
    </function>
    <macro name='WITHOUT_TRIO' file='xmlversion' info='defined if the trio support should not be configured in'/>
    <macro name='WITH_TRIO' file='xmlversion' info='defined if the trio support need to be configured in'/>
    <const name='XML_ATTRIBUTE_CDATA' file='tree'/>
    <const name='XML_ATTRIBUTE_DECL' file='tree'/>
    <const name='XML_ATTRIBUTE_ENTITIES' file='tree'/>
    <const name='XML_ATTRIBUTE_ENTITY' file='tree'/>
    <const name='XML_ATTRIBUTE_ENUMERATION' file='tree'/>
    <const name='XML_ATTRIBUTE_FIXED' file='tree'/>
    <const name='XML_ATTRIBUTE_ID' file='tree'/>
    <const name='XML_ATTRIBUTE_IDREF' file='tree'/>
    <const name='XML_ATTRIBUTE_IDREFS' file='tree'/>
    <const name='XML_ATTRIBUTE_IMPLIED' file='tree'/>
    <const name='XML_ATTRIBUTE_NMTOKEN' file='tree'/>
    <const name='XML_ATTRIBUTE_NMTOKENS' file='tree'/>
    <const name='XML_ATTRIBUTE_NODE' file='tree'/>
    <const name='XML_ATTRIBUTE_NONE' file='tree'/>
    <const name='XML_ATTRIBUTE_NOTATION' file='tree'/>
    <const name='XML_ATTRIBUTE_REQUIRED' file='tree'/>
    <const name='XML_BUFFER_ALLOC_DOUBLEIT' file='tree'/>
    <const name='XML_BUFFER_ALLOC_EXACT' file='tree'/>
    <macro name='XML_CATALOGS_NAMESPACE' file='catalog' info='The namespace for the XML Catalogs elements'/>
    <macro name='XML_CATALOG_PI' file='catalog'/>
    <const name='XML_CATA_ALLOW_ALL' file='catalog'/>
    <const name='XML_CATA_ALLOW_DOCUMENT' file='catalog'/>
    <const name='XML_CATA_ALLOW_GLOBAL' file='catalog'/>
    <const name='XML_CATA_ALLOW_NONE' file='catalog'/>
    <const name='XML_CATA_PREFER_NONE' file='catalog'/>
    <const name='XML_CATA_PREFER_PUBLIC' file='catalog'/>
    <const name='XML_CATA_PREFER_SYSTEM' file='catalog'/>
    <const name='XML_CDATA_SECTION_NODE' file='tree'/>
    <const name='XML_CHAR_ENCODING_2022_JP' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_1' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_2' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_3' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_4' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_5' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_6' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_7' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_8' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_9' file='encoding'/>
    <const name='XML_CHAR_ENCODING_ASCII' file='encoding'/>
    <const name='XML_CHAR_ENCODING_EBCDIC' file='encoding'/>
    <const name='XML_CHAR_ENCODING_ERROR' file='encoding'/>
    <const name='XML_CHAR_ENCODING_EUC_JP' file='encoding'/>
    <const name='XML_CHAR_ENCODING_NONE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_SHIFT_JIS' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS2' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4BE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4LE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4_2143' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4_3412' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UTF16BE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UTF16LE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UTF8' file='encoding'/>
    <const name='XML_COMMENT_NODE' file='tree'/>
    <macro name='XML_COMPLETE_ATTRS' file='parser' info='Bit in the loadsubset context field to tell to do complete the elements attributes lists with the ones defaulted from the DTDs Use it to initialize xmlLoadExtDtdDefaultValue'/>
    <macro name='XML_DEFAULT_VERSION' file='parser' info='The default version of XML used: 1.0'/>
    <macro name='XML_DETECT_IDS' file='parser' info='Bit in the loadsubset context field to tell to do ID/REFs lookups Use it to initialize xmlLoadExtDtdDefaultValue'/>
    <const name='XML_DOCB_DOCUMENT_NODE' file='tree'/>
    <const name='XML_DOCUMENT_FRAG_NODE' file='tree'/>
    <const name='XML_DOCUMENT_NODE' file='tree'/>
    <const name='XML_DOCUMENT_TYPE_NODE' file='tree'/>
    <const name='XML_DTD_NODE' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_ELEMENT' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_MULT' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_ONCE' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_OPT' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_OR' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_PCDATA' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_PLUS' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_SEQ' file='tree'/>
    <const name='XML_ELEMENT_DECL' file='tree'/>
    <const name='XML_ELEMENT_NODE' file='tree'/>
    <const name='XML_ELEMENT_TYPE_ANY' file='tree'/>
    <const name='XML_ELEMENT_TYPE_ELEMENT' file='tree'/>
    <const name='XML_ELEMENT_TYPE_EMPTY' file='tree'/>
    <const name='XML_ELEMENT_TYPE_MIXED' file='tree'/>
    <const name='XML_ELEMENT_TYPE_UNDEFINED' file='tree'/>
    <const name='XML_ENTITY_DECL' file='tree'/>
    <const name='XML_ENTITY_NODE' file='tree'/>
    <const name='XML_ENTITY_REF_NODE' file='tree'/>
    <const name='XML_ERR_ATTLIST_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ATTLIST_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_REDEFINED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_WITHOUT_VALUE' file='xmlerror'/>
    <const name='XML_ERR_CDATA_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_AT_EOF' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_IN_DTD' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_IN_EPILOG' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_IN_PROLOG' file='xmlerror'/>
    <const name='XML_ERR_COMMENT_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_CONDSEC_INVALID' file='xmlerror'/>
    <const name='XML_ERR_CONDSEC_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_CONDSEC_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_DOCTYPE_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_DOCUMENT_EMPTY' file='xmlerror'/>
    <const name='XML_ERR_DOCUMENT_END' file='xmlerror'/>
    <const name='XML_ERR_DOCUMENT_START' file='xmlerror'/>
    <const name='XML_ERR_ELEMCONTENT_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ELEMCONTENT_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ENCODING_NAME' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_AT_EOF' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_IN_DTD' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_IN_EPILOG' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_IN_PROLOG' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_NO_NAME' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_SEMICOL_MISSING' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_BOUNDARY' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_CHAR_ERROR' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_IS_EXTERNAL' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_IS_PARAMETER' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_LOOP' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_PE_INTERNAL' file='xmlerror'/>
    <const name='XML_ERR_EQUAL_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_EXTRA_CONTENT' file='xmlerror'/>
    <const name='XML_ERR_EXT_ENTITY_STANDALONE' file='xmlerror'/>
    <const name='XML_ERR_EXT_SUBSET_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_GT_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_HYPHEN_IN_COMMENT' file='xmlerror'/>
    <const name='XML_ERR_INTERNAL_ERROR' file='xmlerror'/>
    <const name='XML_ERR_INVALID_CHAR' file='xmlerror'/>
    <const name='XML_ERR_INVALID_CHARREF' file='xmlerror'/>
    <const name='XML_ERR_INVALID_DEC_CHARREF' file='xmlerror'/>
    <const name='XML_ERR_INVALID_ENCODING' file='xmlerror'/>
    <const name='XML_ERR_INVALID_HEX_CHARREF' file='xmlerror'/>
    <const name='XML_ERR_INVALID_URI' file='xmlerror'/>
    <const name='XML_ERR_LITERAL_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_LITERAL_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_LTSLASH_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_LT_IN_ATTRIBUTE' file='xmlerror'/>
    <const name='XML_ERR_LT_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_MISPLACED_CDATA_END' file='xmlerror'/>
    <const name='XML_ERR_MIXED_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_MIXED_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_NAME_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_NMTOKEN_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_NOTATION_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_NOTATION_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_NOT_WELL_BALANCED' file='xmlerror'/>
    <const name='XML_ERR_NO_DTD' file='xmlerror'/>
    <const name='XML_ERR_NO_MEMORY' file='xmlerror'/>
    <const name='XML_ERR_NS_DECL_ERROR' file='xmlerror'/>
    <const name='XML_ERR_OK' file='xmlerror'/>
    <const name='XML_ERR_PCDATA_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_PEREF_AT_EOF' file='xmlerror'/>
    <const name='XML_ERR_PEREF_IN_EPILOG' file='xmlerror'/>
    <const name='XML_ERR_PEREF_IN_INT_SUBSET' file='xmlerror'/>
    <const name='XML_ERR_PEREF_IN_PROLOG' file='xmlerror'/>
    <const name='XML_ERR_PEREF_NO_NAME' file='xmlerror'/>
    <const name='XML_ERR_PEREF_SEMICOL_MISSING' file='xmlerror'/>
    <const name='XML_ERR_PI_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_PI_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_PUBID_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_RESERVED_XML_NAME' file='xmlerror'/>
    <const name='XML_ERR_SEPARATOR_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_SPACE_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_STANDALONE_VALUE' file='xmlerror'/>
    <const name='XML_ERR_STRING_NOT_CLOSED' file='xmlerror'/>
    <const name='XML_ERR_STRING_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_TAG_NAME_MISMATCH' file='xmlerror'/>
    <const name='XML_ERR_TAG_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_UNDECLARED_ENTITY' file='xmlerror'/>
    <const name='XML_ERR_UNKNOWN_ENCODING' file='xmlerror'/>
    <const name='XML_ERR_UNPARSED_ENTITY' file='xmlerror'/>
    <const name='XML_ERR_UNSUPPORTED_ENCODING' file='xmlerror'/>
    <const name='XML_ERR_URI_FRAGMENT' file='xmlerror'/>
    <const name='XML_ERR_URI_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_VALUE_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_XMLDECL_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_XMLDECL_NOT_STARTED' file='xmlerror'/>
    <const name='XML_EXTERNAL_GENERAL_PARSED_ENTITY' file='entities'/>
    <const name='XML_EXTERNAL_GENERAL_UNPARSED_ENTITY' file='entities'/>
    <const name='XML_EXTERNAL_PARAMETER_ENTITY' file='entities'/>
    <macro name='XML_GET_CONTENT' file='tree' info='macro to extract the content pointer of a node'/>
    <macro name='XML_GET_LINE' file='tree' info='macro to extract the line number of an element node. This will work only if line numbering is activated by calling xmlLineNumbersDefault(1) before parsing'/>
    <const name='XML_HTML_DOCUMENT_NODE' file='tree'/>
    <const name='XML_INTERNAL_GENERAL_ENTITY' file='entities'/>
    <const name='XML_INTERNAL_PARAMETER_ENTITY' file='entities'/>
    <const name='XML_INTERNAL_PREDEFINED_ENTITY' file='entities'/>
    <macro name='XML_LOCAL_NAMESPACE' file='tree' info='A namespace declaration node'/>
    <macro name='XML_MAX_NAMELEN' file='parserInternals' info='Identifiers can be longer, but this will be more costly at runtime.'/>
    <const name='XML_NAMESPACE_DECL' file='tree'/>
    <const name='XML_NOTATION_NODE' file='tree'/>
    <const name='XML_PARSER_ATTRIBUTE_VALUE' file='parser'/>
    <const name='XML_PARSER_CDATA_SECTION' file='parser'/>
    <const name='XML_PARSER_COMMENT' file='parser'/>
    <const name='XML_PARSER_CONTENT' file='parser'/>
    <const name='XML_PARSER_DTD' file='parser'/>
    <const name='XML_PARSER_END_TAG' file='parser'/>
    <const name='XML_PARSER_ENTITY_DECL' file='parser'/>
    <const name='XML_PARSER_ENTITY_VALUE' file='parser'/>
    <const name='XML_PARSER_EOF' file='parser'/>
    <const name='XML_PARSER_EPILOG' file='parser'/>
    <const name='XML_PARSER_IGNORE' file='parser'/>
    <const name='XML_PARSER_MISC' file='parser'/>
    <const name='XML_PARSER_PI' file='parser'/>
    <const name='XML_PARSER_PROLOG' file='parser'/>
    <const name='XML_PARSER_START' file='parser'/>
    <const name='XML_PARSER_START_TAG' file='parser'/>
    <const name='XML_PARSER_SYSTEM_LITERAL' file='parser'/>
    <const name='XML_PI_NODE' file='tree'/>
    <macro name='XML_SUBSTITUTE_BOTH' file='parserInternals' info='Both general and parameter entities need to be substituted'/>
    <macro name='XML_SUBSTITUTE_NONE' file='parserInternals' info='If no entities need to be substituted'/>
    <macro name='XML_SUBSTITUTE_PEREF' file='parserInternals' info='Whether parameter entities need to be substituted'/>
    <macro name='XML_SUBSTITUTE_REF' file='parserInternals' info='Whether general entities need to be substituted'/>
    <const name='XML_TEXT_NODE' file='tree'/>
    <const name='XML_WAR_CATALOG_PI' file='xmlerror'/>
    <const name='XML_WAR_UNDECLARED_ENTITY' file='xmlerror'/>
    <const name='XML_XINCLUDE_END' file='tree'/>
    <const name='XML_XINCLUDE_START' file='tree'/>
    <macro name='XML_XML_NAMESPACE' file='tree' info='This is the namespace for the special xml: prefix predefined in the XML Namespace specification'/>
    <const name='XPATH_BOOLEAN' file='xpath'/>
    <const name='XPATH_ENCODING_ERROR' file='xpath'/>
    <const name='XPATH_EXPRESSION_OK' file='xpath'/>
    <const name='XPATH_EXPR_ERROR' file='xpath'/>
    <const name='XPATH_INVALID_ARITY' file='xpath'/>
    <const name='XPATH_INVALID_CHAR_ERROR' file='xpath'/>
    <const name='XPATH_INVALID_CTXT_POSITION' file='xpath'/>
    <const name='XPATH_INVALID_CTXT_SIZE' file='xpath'/>
    <const name='XPATH_INVALID_OPERAND' file='xpath'/>
    <const name='XPATH_INVALID_PREDICATE_ERROR' file='xpath'/>
    <const name='XPATH_INVALID_TYPE' file='xpath'/>
    <const name='XPATH_LOCATIONSET' file='xpath'/>
    <const name='XPATH_MEMORY_ERROR' file='xpath'/>
    <const name='XPATH_NODESET' file='xpath'/>
    <const name='XPATH_NUMBER' file='xpath'/>
    <const name='XPATH_NUMBER_ERROR' file='xpath'/>
    <const name='XPATH_POINT' file='xpath'/>
    <const name='XPATH_RANGE' file='xpath'/>
    <const name='XPATH_START_LITERAL_ERROR' file='xpath'/>
    <const name='XPATH_STRING' file='xpath'/>
    <const name='XPATH_UNCLOSED_ERROR' file='xpath'/>
    <const name='XPATH_UNDEFINED' file='xpath'/>
    <const name='XPATH_UNDEF_PREFIX_ERROR' file='xpath'/>
    <const name='XPATH_UNDEF_VARIABLE_ERROR' file='xpath'/>
    <const name='XPATH_UNFINISHED_LITERAL_ERROR' file='xpath'/>
    <const name='XPATH_UNKNOWN_FUNC_ERROR' file='xpath'/>
    <const name='XPATH_USERS' file='xpath'/>
    <const name='XPATH_VARIABLE_REF_ERROR' file='xpath'/>
    <const name='XPATH_XSLT_TREE' file='xpath'/>
    <const name='XPTR_RESOURCE_ERROR' file='xpath'/>
    <const name='XPTR_SUB_RESOURCE_ERROR' file='xpath'/>
    <const name='XPTR_SYNTAX_ERROR' file='xpath'/>
    <macro name='XP_ERROR' file='xpathInternals' info='Macro to raise an XPath error and return'/>
    <macro name='XP_ERROR0' file='xpathInternals' info='Macro to raise an XPath error and return 0'/>
    <function name='attribute' file='SAX'>
      <info>Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='fullname' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='attributeDecl' file='SAX'>
      <info>An attribute definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='elem' type='const xmlChar *'/>
      <arg name='fullname' type='const xmlChar *'/>
      <arg name='type' type='int'/>
      <arg name='def' type='int'/>
      <arg name='defaultValue' type='const xmlChar *'/>
      <arg name='tree' type='xmlEnumerationPtr'/>
    </function>
    <functype name='attributeDeclSAXFunc' file='parser'/>
    <functype name='attributeSAXFunc' file='parser'/>
    <function name='cdataBlock' file='SAX'>
      <info>called when a pcdata block has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='value' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <functype name='cdataBlockSAXFunc' file='parser'/>
    <function name='characters' file='SAX'>
      <info>receiving some chars from the parser.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='ch' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <functype name='charactersSAXFunc' file='parser'/>
    <function name='checkNamespace' file='SAX'>
      <info>Check that the current element namespace is the same as the one read upon parsing.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='nameSpace' type='xmlChar *'/>
    </function>
    <function name='comment' file='SAX'>
      <info>A comment has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <functype name='commentSAXFunc' file='parser'/>
    <function name='docbCreateFileParserCtxt' file='DOCBparser'>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='docbParserCtxtPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='docbCreatePushParserCtxt' file='DOCBparser'>
      <info>Create a parser context for using the DocBook SGML parser in push mode To allow content encoding detection, size should be &gt;= 4 The value of filename is used for fetching external entities and error/warning reports.</info>
      <return type='docbParserCtxtPtr'/>
      <arg name='sax' type='docbSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='chunk' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <macro name='docbDefaultSAXHandler' file='globals'/>
    <function name='docbDefaultSAXHandlerInit' file='SAX'>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <typedef name='docbDocPtr' file='DOCBparser'/>
    <function name='docbEncodeEntities' file='DOCBparser'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus SGML entities block of chars out.</info>
      <return type='int'/>
      <arg name='out' type='unsigned char *'/>
      <arg name='outlen' type='int *'/>
      <arg name='in' type='const unsigned char *'/>
      <arg name='inlen' type='int *'/>
      <arg name='quoteChar' type='int'/>
    </function>
    <function name='docbFreeParserCtxt' file='DOCBparser'>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='docbParserCtxtPtr'/>
    </function>
    <typedef name='docbNodePtr' file='DOCBparser'/>
    <function name='docbParseChunk' file='DOCBparser'>
      <info>Parse a Chunk of memory</info>
      <return type='int'/>
      <arg name='ctxt' type='docbParserCtxtPtr'/>
      <arg name='chunk' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='terminate' type='int'/>
    </function>
    <function name='docbParseDoc' file='DOCBparser'>
      <info>parse an SGML in-memory document and build a tree.</info>
      <return type='docbDocPtr'/>
      <arg name='cur' type='xmlChar *'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='docbParseDocument' file='DOCBparser'>
      <info>parse an SGML document (and build a tree if using the standard SAX interface).</info>
      <return type='int'/>
      <arg name='ctxt' type='docbParserCtxtPtr'/>
    </function>
    <function name='docbParseFile' file='DOCBparser'>
      <info>parse a Docbook SGML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='docbDocPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <typedef name='docbParserCtxt' file='DOCBparser'/>
    <typedef name='docbParserCtxtPtr' file='DOCBparser'/>
    <typedef name='docbParserInput' file='DOCBparser'/>
    <typedef name='docbParserInputPtr' file='DOCBparser'/>
    <typedef name='docbParserNodeInfo' file='DOCBparser'/>
    <typedef name='docbSAXHandler' file='DOCBparser'/>
    <typedef name='docbSAXHandlerPtr' file='DOCBparser'/>
    <function name='docbSAXParseDoc' file='DOCBparser'>
      <info>parse an SGML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='docbDocPtr'/>
      <arg name='cur' type='xmlChar *'/>
      <arg name='encoding' type='const char *'/>
      <arg name='sax' type='docbSAXHandlerPtr'/>
      <arg name='userData' type='void *'/>
    </function>
    <function name='docbSAXParseFile' file='DOCBparser'>
      <info>parse an SGML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='docbDocPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='encoding' type='const char *'/>
      <arg name='sax' type='docbSAXHandlerPtr'/>
      <arg name='userData' type='void *'/>
    </function>
    <function name='elementDecl' file='SAX'>
      <info>An element definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='type' type='int'/>
      <arg name='content' type='xmlElementContentPtr'/>
    </function>
    <functype name='elementDeclSAXFunc' file='parser'/>
    <function name='endDocument' file='SAX'>
      <info>called when the document end has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
    </function>
    <functype name='endDocumentSAXFunc' file='parser'/>
    <function name='endElement' file='SAX'>
      <info>called when the end of an element has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <functype name='endElementSAXFunc' file='parser'/>
    <function name='entityDecl' file='SAX'>
      <info>An entity definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='type' type='int'/>
      <arg name='publicId' type='const xmlChar *'/>
      <arg name='systemId' type='const xmlChar *'/>
      <arg name='content' type='xmlChar *'/>
    </function>
    <functype name='entityDeclSAXFunc' file='parser'/>
    <functype name='errorSAXFunc' file='parser'/>
    <function name='externalSubset' file='SAX'>
      <info>Callback on external subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <functype name='externalSubsetSAXFunc' file='parser'/>
    <functype name='fatalErrorSAXFunc' file='parser'/>
    <functype name='ftpDataCallback' file='nanoftp' info='A callback for the xmlNanoFTPGet command'/>
    <functype name='ftpListCallback' file='nanoftp' info='A callback for the xmlNanoFTPList command Note that only one of year and day:minute are specified'/>
    <function name='getColumnNumber' file='SAX'>
      <info>Return the column number of the current parsing point.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='getEntity' file='SAX'>
      <info>Get an entity by name</info>
      <return type='xmlEntityPtr'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <functype name='getEntitySAXFunc' file='parser'/>
    <function name='getLineNumber' file='SAX'>
      <info>Return the line number of the current parsing point.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='getNamespace' file='SAX'>
      <info>Get the current element namespace.</info>
      <return type='xmlNsPtr'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='getParameterEntity' file='SAX'>
      <info>Get a parameter entity by name</info>
      <return type='xmlEntityPtr'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <functype name='getParameterEntitySAXFunc' file='parser'/>
    <function name='getPublicId' file='SAX'>
      <info>Return the public ID e.g. "-//SGMLSOURCE//DTD DEMO//EN"</info>
      <return type='const xmlChar *'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='getSystemId' file='SAX'>
      <info>Return the system ID, basically URL or filename e.g. http://www.sgmlsource.com/dtds/memo.dtd</info>
      <return type='const xmlChar *'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='globalNamespace' file='SAX'>
      <info>An old global namespace has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='href' type='const xmlChar *'/>
      <arg name='prefix' type='const xmlChar *'/>
    </function>
    <function name='hasExternalSubset' file='SAX'>
      <info>Does this document has an external subset</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <functype name='hasExternalSubsetSAXFunc' file='parser'/>
    <function name='hasInternalSubset' file='SAX'>
      <info>Does this document has an internal subset</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <functype name='hasInternalSubsetSAXFunc' file='parser'/>
    <function name='htmlAutoCloseTag' file='HTMLparser'>
      <info>The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if the element or one of it's children would autoclose the given tag.</info>
      <return type='int'/>
      <arg name='doc' type='htmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='elem' type='htmlNodePtr'/>
    </function>
    <function name='htmlCreateFileParserCtxt' file='parserInternals'>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='htmlParserCtxtPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='htmlCreatePushParserCtxt' file='HTMLparser'>
      <info>Create a parser context for using the HTML parser in push mode To allow content encoding detection, size should be &gt;= 4 The value of filename is used for fetching external entities and error/warning reports.</info>
      <return type='htmlParserCtxtPtr'/>
      <arg name='sax' type='htmlSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='chunk' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <macro name='htmlDefaultSAXHandler' file='globals'/>
    <function name='htmlDefaultSAXHandlerInit' file='parser'>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='htmlDocContentDumpFormatOutput' file='HTMLtree'>
      <info>Dump an HTML document.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
      <arg name='format' type='int'/>
    </function>
    <function name='htmlDocContentDumpOutput' file='HTMLtree'>
      <info>Dump an HTML document. Formating return/spaces are added.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='htmlDocDump' file='HTMLtree'>
      <info>Dump an HTML document to an open FILE.</info>
      <return type='int'/>
      <arg name='f' type='FILE *'/>
      <arg name='cur' type='xmlDocPtr'/>
    </function>
    <function name='htmlDocDumpMemory' file='HTMLtree'>
      <info>Dump an HTML document in memory and return the xmlChar * and it's size. It's up to the caller to free the memory.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='mem' type='xmlChar **'/>
      <arg name='size' type='int *'/>
    </function>
    <typedef name='htmlDocPtr' file='HTMLparser'/>
    <struct name='htmlElemDesc' file='HTMLparser'/>
    <typedef name='htmlElemDescPtr' file='HTMLparser'/>
    <function name='htmlEncodeEntities' file='HTMLparser'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out.</info>
      <return type='int'/>
      <arg name='out' type='unsigned char *'/>
      <arg name='outlen' type='int *'/>
      <arg name='in' type='const unsigned char *'/>
      <arg name='inlen' type='int *'/>
      <arg name='quoteChar' type='int'/>
    </function>
    <struct name='htmlEntityDesc' file='HTMLparser'/>
    <typedef name='htmlEntityDescPtr' file='HTMLparser'/>
    <function name='htmlEntityLookup' file='HTMLparser'>
      <info>Lookup the given entity in EntitiesTable </info>
      <return type='const htmlEntityDesc *'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='htmlEntityValueLookup' file='HTMLparser'>
      <info>Lookup the given entity in EntitiesTable </info>
      <return type='const htmlEntityDesc *'/>
      <arg name='value' type='unsigned int'/>
    </function>
    <function name='htmlFreeParserCtxt' file='HTMLparser'>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='htmlParserCtxtPtr'/>
    </function>
    <function name='htmlGetMetaEncoding' file='HTMLtree'>
      <info>Encoding definition lookup in the Meta tags</info>
      <return type='const xmlChar *'/>
      <arg name='doc' type='htmlDocPtr'/>
    </function>
    <function name='htmlHandleOmittedElem' file='HTMLparser'>
      <info>Set and return the previous value for handling HTML omitted tags.</info>
      <return type='int'/>
      <arg name='val' type='int'/>
    </function>
    <function name='htmlInitAutoClose' file='parserInternals'>
      <info>Initialize the htmlStartCloseIndex for fast lookup of closing tags names. This is not reentrant. Call xmlInitParser() once before processing in case of use in multithreaded programs.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='htmlIsAutoClosed' file='HTMLparser'>
      <info>The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if a tag is autoclosed by one of it's child</info>
      <return type='int'/>
      <arg name='doc' type='htmlDocPtr'/>
      <arg name='elem' type='htmlNodePtr'/>
    </function>
    <function name='htmlIsScriptAttribute' file='HTMLparser'>
      <info>Check if an attribute is of content type Script</info>
      <return type='int'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='htmlNewDoc' file='HTMLtree'>
      <info>Creates a new HTML document</info>
      <return type='htmlDocPtr'/>
      <arg name='URI' type='const xmlChar *'/>
      <arg name='ExternalID' type='const xmlChar *'/>
    </function>
    <function name='htmlNewDocNoDtD' file='HTMLtree'>
      <info>Creates a new HTML document without a DTD node if URI and ExternalID are NULL</info>
      <return type='htmlDocPtr'/>
      <arg name='URI' type='const xmlChar *'/>
      <arg name='ExternalID' type='const xmlChar *'/>
    </function>
    <function name='htmlNodeDump' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too, and formatting returns are added.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='htmlNodeDumpFile' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too, and formatting returns are added.</info>
      <return type='void'/>
      <arg name='out' type='FILE *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='htmlNodeDumpFileFormat' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too. </info>
      <return type='int'/>
      <arg name='out' type='FILE *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='encoding' type='const char *'/>
      <arg name='format' type='int'/>
    </function>
    <function name='htmlNodeDumpFormatOutput' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='encoding' type='const char *'/>
      <arg name='format' type='int'/>
    </function>
    <typedef name='htmlNodePtr' file='HTMLparser'/>
    <function name='htmlParseCharRef' file='HTMLparser'>
      <info>parse Reference declarations </info>
      <return type='int'/>
      <arg name='ctxt' type='htmlParserCtxtPtr'/>
    </function>
    <function name='htmlParseChunk' file='HTMLparser'>
      <info>Parse a Chunk of memory</info>
      <return type='int'/>
      <arg name='ctxt' type='htmlParserCtxtPtr'/>
      <arg name='chunk' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='terminate' type='int'/>
    </function>
    <function name='htmlParseDoc' file='HTMLparser'>
      <info>parse an HTML in-memory document and build a tree.</info>
      <return type='htmlDocPtr'/>
      <arg name='cur' type='xmlChar *'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='htmlParseElement' file='HTMLparser'>
      <info>parse an HTML element, this is highly recursive </info>
      <return type='void'/>
      <arg name='ctxt' type='htmlParserCtxtPtr'/>
    </function>
    <function name='htmlParseEntityRef' file='HTMLparser'>
      <info>parse an HTML ENTITY references </info>
      <return type='const htmlEntityDesc *'/>
      <arg name='ctxt' type='htmlParserCtxtPtr'/>
      <arg name='str' type='xmlChar **'/>
    </function>
    <function name='htmlParseFile' file='HTMLparser'>
      <info>parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='htmlDocPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <typedef name='htmlParserCtxt' file='HTMLparser'/>
    <typedef name='htmlParserCtxtPtr' file='HTMLparser'/>
    <typedef name='htmlParserInput' file='HTMLparser'/>
    <typedef name='htmlParserInputPtr' file='HTMLparser'/>
    <typedef name='htmlParserNodeInfo' file='HTMLparser'/>
    <typedef name='htmlSAXHandler' file='HTMLparser'/>
    <typedef name='htmlSAXHandlerPtr' file='HTMLparser'/>
    <function name='htmlSAXParseDoc' file='HTMLparser'>
      <info>Parse an HTML in-memory document. If sax is not NULL, use the SAX callbacks to handle parse events. If sax is NULL, fallback to the default DOM behavior and return a tree.</info>
      <return type='htmlDocPtr'/>
      <arg name='cur' type='xmlChar *'/>
      <arg name='encoding' type='const char *'/>
      <arg name='sax' type='htmlSAXHandlerPtr'/>
      <arg name='userData' type='void *'/>
    </function>
    <function name='htmlSAXParseFile' file='HTMLparser'>
      <info>parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='htmlDocPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='encoding' type='const char *'/>
      <arg name='sax' type='htmlSAXHandlerPtr'/>
      <arg name='userData' type='void *'/>
    </function>
    <function name='htmlSaveFile' file='HTMLtree'>
      <info>Dump an HTML document to a file. If filename is "-" the stdout file is used.</info>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='cur' type='xmlDocPtr'/>
    </function>
    <function name='htmlSaveFileEnc' file='HTMLtree'>
      <info>Dump an HTML document to a file using a given encoding and formatting returns/spaces are added.</info>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='htmlSaveFileFormat' file='HTMLtree'>
      <info>Dump an HTML document to a file using a given encoding.</info>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
      <arg name='format' type='int'/>
    </function>
    <function name='htmlSetMetaEncoding' file='HTMLtree'>
      <info>Sets the current encoding in the Meta tags NOTE: this will not change the document content encoding, just the META flag associated.</info>
      <return type='int'/>
      <arg name='doc' type='htmlDocPtr'/>
      <arg name='encoding' type='const xmlChar *'/>
    </function>
    <function name='htmlTagLookup' file='HTMLparser'>
      <info>Lookup the HTML tag in the ElementTable</info>
      <return type='const htmlElemDesc *'/>
      <arg name='tag' type='const xmlChar *'/>
    </function>
    <function name='ignorableWhitespace' file='SAX'>
      <info>receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='ch' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <functype name='ignorableWhitespaceSAXFunc' file='parser'/>
    <function name='initGenericErrorDefaultFunc' file='xmlerror'>
      <return type='void'/>
      <arg name='handler' type='xmlGenericErrorFunc *'/>
    </function>
    <function name='initdocbDefaultSAXHandler' file='SAX'>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *'/>
    </function>
    <function name='inithtmlDefaultSAXHandler' file='SAX'>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *'/>
    </function>
    <function name='initxmlDefaultSAXHandler' file='SAX'>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *'/>
      <arg name='warning' type='int'/>
    </function>
    <function name='inputPop' file='parserInternals'>
      <info>Pops the top parser input from the input stack</info>
      <return type='xmlParserInputPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='inputPush' file='parserInternals'>
      <info>Pushes a new parser input on top of the input stack</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='value' type='xmlParserInputPtr'/>
    </function>
    <function name='internalSubset' file='SAX'>
      <info>Callback on internal subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <functype name='internalSubsetSAXFunc' file='parser'/>
    <function name='isStandalone' file='SAX'>
      <info>Is this document tagged standalone ?</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <functype name='isStandaloneSAXFunc' file='parser'/>
    <function name='isolat1ToUTF8' file='encoding'>
      <info>Take a block of ISO Latin 1 chars in and try to convert it to an UTF-8 block of chars out.</info>
      <return type='int'/>
      <arg name='out' type='unsigned char *'/>
      <arg name='outlen' type='int *'/>
      <arg name='in' type='const unsigned char *'/>
      <arg name='inlen' type='int *'/>
    </function>
    <function name='namePop' file='parserInternals'>
      <info>Pops the top element name from the name stack</info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='namePush' file='parserInternals'>
      <info>Pushes a new element name on top of the name stack</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='value' type='xmlChar *'/>
    </function>
    <function name='namespaceDecl' file='SAX'>
      <info>A namespace has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='href' type='const xmlChar *'/>
      <arg name='prefix' type='const xmlChar *'/>
    </function>
    <function name='nodePop' file='parserInternals'>
      <info>Pops the top element node from the node stack</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='nodePush' file='parserInternals'>
      <info>Pushes a new element node on top of the node stack</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='value' type='xmlNodePtr'/>
    </function>
    <function name='notationDecl' file='SAX'>
      <info>What to do when a notation declaration has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='publicId' type='const xmlChar *'/>
      <arg name='systemId' type='const xmlChar *'/>
    </function>
    <functype name='notationDeclSAXFunc' file='parser'/>
    <macro name='oldXMLWDcompatibility' file='globals'/>
    <function name='processingInstruction' file='SAX'>
      <info>A processing instruction has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='target' type='const xmlChar *'/>
      <arg name='data' type='const xmlChar *'/>
    </function>
    <functype name='processingInstructionSAXFunc' file='parser'/>
    <function name='reference' file='SAX'>
      <info>called when an entity reference is detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <functype name='referenceSAXFunc' file='parser'/>
    <function name='resolveEntity' file='SAX'>
      <info>The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it's own entity resolution routine</info>
      <return type='xmlParserInputPtr'/>
      <arg name='ctx' type='void *'/>
      <arg name='publicId' type='const xmlChar *'/>
      <arg name='systemId' type='const xmlChar *'/>
    </function>
    <functype name='resolveEntitySAXFunc' file='parser'/>
    <function name='setDocumentLocator' file='SAX'>
      <info>Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='loc' type='xmlSAXLocatorPtr'/>
    </function>
    <functype name='setDocumentLocatorSAXFunc' file='parser'/>
    <function name='setNamespace' file='SAX'>
      <info>Set the current element namespace.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='startDocument' file='SAX'>
      <info>called when the document start being processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
    </function>
    <functype name='startDocumentSAXFunc' file='parser'/>
    <function name='startElement' file='SAX'>
      <info>called when an opening tag has been processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='fullname' type='const xmlChar *'/>
      <arg name='atts' type='const xmlChar **'/>
    </function>
    <functype name='startElementSAXFunc' file='parser'/>
    <function name='unparsedEntityDecl' file='SAX'>
      <info>What to do when an unparsed entity declaration is parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='publicId' type='const xmlChar *'/>
      <arg name='systemId' type='const xmlChar *'/>
      <arg name='notationName' type='const xmlChar *'/>
    </function>
    <functype name='unparsedEntityDeclSAXFunc' file='parser'/>
    <function name='valuePop' file='xpathInternals'>
      <info>Pops the top XPath object from the value stack</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='valuePush' file='xpathInternals'>
      <info>Pushes a new XPath object on top of the value stack</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='value' type='xmlXPathObjectPtr'/>
    </function>
    <functype name='warningSAXFunc' file='parser'/>
    <function name='xmlACatalogAdd' file='catalog'>
      <info>Add an entry in the catalog, it may overwrite existing but different entries.</info>
      <return type='int'/>
      <arg name='catal' type='xmlCatalogPtr'/>
      <arg name='type' type='const xmlChar *'/>
      <arg name='orig' type='const xmlChar *'/>
      <arg name='replace' type='const xmlChar *'/>
    </function>
    <function name='xmlACatalogDump' file='catalog'>
      <info>Free up all the memory associated with catalogs</info>
      <return type='void'/>
      <arg name='catal' type='xmlCatalogPtr'/>
      <arg name='out' type='FILE *'/>
    </function>
    <function name='xmlACatalogRemove' file='catalog'>
      <info>Remove an entry from the catalog</info>
      <return type='int'/>
      <arg name='catal' type='xmlCatalogPtr'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlACatalogResolve' file='catalog'>
      <info>Do a complete resolution lookup of an External Identifier</info>
      <return type='xmlChar *'/>
      <arg name='catal' type='xmlCatalogPtr'/>
      <arg name='pubID' type='const xmlChar *'/>
      <arg name='sysID' type='const xmlChar *'/>
    </function>
    <function name='xmlACatalogResolvePublic' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID in that catalog</info>
      <return type='xmlChar *'/>
      <arg name='catal' type='xmlCatalogPtr'/>
      <arg name='pubID' type='const xmlChar *'/>
    </function>
    <function name='xmlACatalogResolveSystem' file='catalog'>
      <info>Try to lookup the catalog resource for a system ID</info>
      <return type='xmlChar *'/>
      <arg name='catal' type='xmlCatalogPtr'/>
      <arg name='sysID' type='const xmlChar *'/>
    </function>
    <function name='xmlACatalogResolveURI' file='catalog'>
      <info>Do a complete resolution lookup of an URI</info>
      <return type='xmlChar *'/>
      <arg name='catal' type='xmlCatalogPtr'/>
      <arg name='URI' type='const xmlChar *'/>
    </function>
    <function name='xmlAddAttributeDecl' file='valid'>
      <info>Register a new attribute declaration Note that tree becomes the ownership of the DTD</info>
      <return type='xmlAttributePtr'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='elem' type='const xmlChar *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='ns' type='const xmlChar *'/>
      <arg name='type' type='xmlAttributeType'/>
      <arg name='def' type='xmlAttributeDefault'/>
      <arg name='defaultValue' type='const xmlChar *'/>
      <arg name='tree' type='xmlEnumerationPtr'/>
    </function>
    <function name='xmlAddChild' file='tree'>
      <info>Add a new child element, to parent, at the end of the child list merging adjacent TEXT nodes (in which case cur is freed)</info>
      <return type='xmlNodePtr'/>
      <arg name='parent' type='xmlNodePtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlAddChildList' file='tree'>
      <info>Add a list of node at the end of the child list of the parent merging adjacent TEXT nodes (cur may be freed)</info>
      <return type='xmlNodePtr'/>
      <arg name='parent' type='xmlNodePtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlAddDocEntity' file='entities'>
      <info>Register a new entity for this document.</info>
      <return type='xmlEntityPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='type' type='int'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlAddDtdEntity' file='entities'>
      <info>Register a new entity for this document DTD external subset.</info>
      <return type='xmlEntityPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='type' type='int'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlAddElementDecl' file='valid'>
      <info>Register a new element declaration</info>
      <return type='xmlElementPtr'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='type' type='xmlElementTypeVal'/>
      <arg name='content' type='xmlElementContentPtr'/>
    </function>
    <function name='xmlAddEncodingAlias' file='encoding'>
      <info>Registers and alias alias for an encoding named name. Existing alias will be overwritten.</info>
      <return type='int'/>
      <arg name='name' type='const char *'/>
      <arg name='alias' type='const char *'/>
    </function>
    <function name='xmlAddID' file='valid'>
      <info>Register a new id declaration</info>
      <return type='xmlIDPtr'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='value' type='const xmlChar *'/>
      <arg name='attr' type='xmlAttrPtr'/>
    </function>
    <function name='xmlAddNextSibling' file='tree'>
      <info>Add a new element elem as the next siblings of cur If the new element was already inserted in a document it is first unlinked from its existing context. As a result of text merging elem may be freed.</info>
      <return type='xmlNodePtr'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='elem' type='xmlNodePtr'/>
    </function>
    <function name='xmlAddNotationDecl' file='valid'>
      <info>Register a new notation declaration</info>
      <return type='xmlNotationPtr'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='PublicID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <function name='xmlAddPrevSibling' file='tree'>
      <info>Add a new element elem as the previous siblings of cur merging adjacent TEXT nodes (elem may be freed) If the new element was already inserted in a document it is first unlinked from its existing context.</info>
      <return type='xmlNodePtr'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='elem' type='xmlNodePtr'/>
    </function>
    <function name='xmlAddRef' file='valid'>
      <info>Register a new ref declaration</info>
      <return type='xmlRefPtr'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='value' type='const xmlChar *'/>
      <arg name='attr' type='xmlAttrPtr'/>
    </function>
    <function name='xmlAddSibling' file='tree'>
      <info>Add a new element elem to the list of siblings of cur merging adjacent TEXT nodes (elem may be freed) If the new element was already inserted in a document it is first unlinked from its existing context.</info>
      <return type='xmlNodePtr'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='elem' type='xmlNodePtr'/>
    </function>
    <function name='xmlAllocOutputBuffer' file='xmlIO'>
      <info>Create a buffered parser output</info>
      <return type='xmlOutputBufferPtr'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr'/>
    </function>
    <function name='xmlAllocParserInputBuffer' file='xmlIO'>
      <info>Create a buffered parser input for progressive parsing</info>
      <return type='xmlParserInputBufferPtr'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <struct name='xmlAttr' file='tree' info='A attribute on an XML node.'/>
    <typedef name='xmlAttrPtr' file='tree'/>
    <struct name='xmlAttribute' file='tree' info='an Attribute declaration in a DTD'/>
    <enum name='xmlAttributeDefault' file='tree'/>
    <typedef name='xmlAttributePtr' file='tree'/>
    <typedef name='xmlAttributeTablePtr' file='valid'/>
    <enum name='xmlAttributeType' file='tree'/>
    <struct name='xmlBuffer' file='tree' info='A buffer structure'/>
    <function name='xmlBufferAdd' file='tree'>
      <info>Add a string range to an XML buffer. if len == -1, the length of str is recomputed.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlBufferAddHead' file='tree'>
      <info>Add a string range to the beginning of an XML buffer. if len == -1, the length of str is recomputed.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <macro name='xmlBufferAllocScheme' file='globals'/>
    <enum name='xmlBufferAllocationScheme' file='tree'/>
    <function name='xmlBufferCCat' file='tree'>
      <info>Append a zero terminated C string to an XML buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='str' type='const char *'/>
    </function>
    <function name='xmlBufferCat' file='tree'>
      <info>Append a zero terminated string to an XML buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='str' type='const xmlChar *'/>
    </function>
    <function name='xmlBufferContent' file='tree'>
      <info>Function to extract the content of a buffer</info>
      <return type='const xmlChar *'/>
      <arg name='buf' type='const xmlBufferPtr'/>
    </function>
    <function name='xmlBufferCreate' file='tree'>
      <info>routine to create an XML buffer.</info>
      <return type='xmlBufferPtr'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlBufferCreateSize' file='tree'>
      <info>routine to create an XML buffer.</info>
      <return type='xmlBufferPtr'/>
      <arg name='size' type='size_t'/>
    </function>
    <function name='xmlBufferDump' file='tree'>
      <info>Dumps an XML buffer to a FILE *.</info>
      <return type='int'/>
      <arg name='file' type='FILE *'/>
      <arg name='buf' type='xmlBufferPtr'/>
    </function>
    <function name='xmlBufferEmpty' file='tree'>
      <info>empty a buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
    </function>
    <function name='xmlBufferFree' file='tree'>
      <info>Frees an XML buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
    </function>
    <function name='xmlBufferGrow' file='tree'>
      <info>Grow the available space of an XML buffer.</info>
      <return type='int'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='len' type='unsigned int'/>
    </function>
    <function name='xmlBufferLength' file='tree'>
      <info>Function to get the length of a buffer</info>
      <return type='int'/>
      <arg name='buf' type='const xmlBufferPtr'/>
    </function>
    <typedef name='xmlBufferPtr' file='tree'/>
    <function name='xmlBufferResize' file='tree'>
      <info>Resize a buffer to accommodate minimum size of size.</info>
      <return type='int'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='size' type='unsigned int'/>
    </function>
    <function name='xmlBufferSetAllocationScheme' file='tree'>
      <info>Sets the allocation scheme for this buffer</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='scheme' type='xmlBufferAllocationScheme'/>
    </function>
    <function name='xmlBufferShrink' file='tree'>
      <info>Remove the beginning of an XML buffer.</info>
      <return type='int'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='len' type='unsigned int'/>
    </function>
    <function name='xmlBufferWriteCHAR' file='tree'>
      <info>routine which manages and grows an output buffer. This one adds xmlChars at the end of the buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='string' type='const xmlChar *'/>
    </function>
    <function name='xmlBufferWriteChar' file='tree'>
      <info>routine which manage and grows an output buffer. This one add C chars at the end of the array.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='string' type='const char *'/>
    </function>
    <function name='xmlBufferWriteQuotedString' file='tree'>
      <info>routine which manage and grows an output buffer. This one writes a quoted or double quoted xmlChar string, checking first if it holds quote or double-quotes internally</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='string' type='const xmlChar *'/>
    </function>
    <function name='xmlBufferWriteXmlCHAR' file='tree'>
      <info>For VMS only. routine which manages and grows an output buffer. This one adds xmlChars at the end of the buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='string' type='const xmlChar *'/>
    </function>
    <function name='xmlBuildURI' file='uri'>
      <info>Computes he final URI of the reference done by checking that the given URI is valid, and building the final URI using the base URI. This is processed according to section 5.2 of the RFC 2396 </info>
      <return type='xmlChar *'/>
      <arg name='URI' type='const xmlChar *'/>
      <arg name='base' type='const xmlChar *'/>
    </function>
    <struct name='xmlCatalog' file='catalog'/>
    <function name='xmlCatalogAdd' file='catalog'>
      <info>Add an entry in the catalog, it may overwrite existing but different entries. If called before any other catalog routine, allows to override the default shared catalog put in place by xmlInitializeCatalog();</info>
      <return type='int'/>
      <arg name='type' type='const xmlChar *'/>
      <arg name='orig' type='const xmlChar *'/>
      <arg name='replace' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogAddLocal' file='catalog'>
      <info>Add the new entry to the catalog list</info>
      <return type='void *'/>
      <arg name='catalogs' type='void *'/>
      <arg name='URL' type='const xmlChar *'/>
    </function>
    <enum name='xmlCatalogAllow' file='catalog'/>
    <function name='xmlCatalogCleanup' file='catalog'>
      <info>Free up all the memory associated with catalogs</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCatalogConvert' file='catalog'>
      <info>Convert all the SGML catalog entries as XML ones</info>
      <return type='int'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCatalogDump' file='catalog'>
      <info>Free up all the memory associated with catalogs</info>
      <return type='void'/>
      <arg name='out' type='FILE *'/>
    </function>
    <function name='xmlCatalogFreeLocal' file='catalog'>
      <info>Free up the memory associated to the catalog list</info>
      <return type='void'/>
      <arg name='catalogs' type='void *'/>
    </function>
    <function name='xmlCatalogGetDefaults' file='catalog'>
      <info>Used to get the user preference w.r.t. to what catalogs should be accepted</info>
      <return type='xmlCatalogAllow'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCatalogGetPublic' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID DEPRECATED, use xmlCatalogResolvePublic()</info>
      <return type='const xmlChar *'/>
      <arg name='pubID' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogGetSystem' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID DEPRECATED, use xmlCatalogResolveSystem()</info>
      <return type='const xmlChar *'/>
      <arg name='sysID' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogIsEmpty' file='catalog'>
      <info>Check is a catalog is empty</info>
      <return type='int'/>
      <arg name='catal' type='xmlCatalogPtr'/>
    </function>
    <function name='xmlCatalogLocalResolve' file='catalog'>
      <info>Do a complete resolution lookup of an External Identifier using a document's private catalog list</info>
      <return type='xmlChar *'/>
      <arg name='catalogs' type='void *'/>
      <arg name='pubID' type='const xmlChar *'/>
      <arg name='sysID' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogLocalResolveURI' file='catalog'>
      <info>Do a complete resolution lookup of an URI using a document's private catalog list</info>
      <return type='xmlChar *'/>
      <arg name='catalogs' type='void *'/>
      <arg name='URI' type='const xmlChar *'/>
    </function>
    <enum name='xmlCatalogPrefer' file='catalog'/>
    <typedef name='xmlCatalogPtr' file='catalog'/>
    <function name='xmlCatalogRemove' file='catalog'>
      <info>Remove an entry from the catalog</info>
      <return type='int'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogResolve' file='catalog'>
      <info>Do a complete resolution lookup of an External Identifier</info>
      <return type='xmlChar *'/>
      <arg name='pubID' type='const xmlChar *'/>
      <arg name='sysID' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogResolvePublic' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID</info>
      <return type='xmlChar *'/>
      <arg name='pubID' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogResolveSystem' file='catalog'>
      <info>Try to lookup the catalog resource for a system ID</info>
      <return type='xmlChar *'/>
      <arg name='sysID' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogResolveURI' file='catalog'>
      <info>Do a complete resolution lookup of an URI</info>
      <return type='xmlChar *'/>
      <arg name='URI' type='const xmlChar *'/>
    </function>
    <function name='xmlCatalogSetDebug' file='catalog'>
      <info>Used to set the debug level for catalog operation, 0 disable debugging, 1 enable it</info>
      <return type='int'/>
      <arg name='level' type='int'/>
    </function>
    <function name='xmlCatalogSetDefaultPrefer' file='catalog'>
      <info>Allows to set the preference between public and system for deletion in XML Catalog resolution. C.f. section 4.1.1 of the spec Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM</info>
      <return type='xmlCatalogPrefer'/>
      <arg name='prefer' type='xmlCatalogPrefer'/>
    </function>
    <function name='xmlCatalogSetDefaults' file='catalog'>
      <info>Used to set the user preference w.r.t. to what catalogs should be accepted</info>
      <return type='void'/>
      <arg name='allow' type='xmlCatalogAllow'/>
    </function>
    <typedef name='xmlChar' file='tree' info='This is a basic byte in an UTF-8 encoded string. It's unsigned allowing to pinpoint case where char * are assigned to xmlChar * (possibly making serialization back impossible).'/>
    <function name='xmlCharEncCloseFunc' file='encoding'>
      <info>Generic front-end for encoding handler close function</info>
      <return type='int'/>
      <arg name='handler' type='xmlCharEncodingHandler *'/>
    </function>
    <function name='xmlCharEncFirstLine' file='encoding'>
      <info>Front-end for the encoding handler input function, but handle only the very first line, i.e. limit itself to 45 chars.</info>
      <return type='int'/>
      <arg name='handler' type='xmlCharEncodingHandler *'/>
      <arg name='out' type='xmlBufferPtr'/>
      <arg name='in' type='xmlBufferPtr'/>
    </function>
    <function name='xmlCharEncInFunc' file='encoding'>
      <info>Generic front-end for the encoding handler input function</info>
      <return type='int'/>
      <arg name='handler' type='xmlCharEncodingHandler *'/>
      <arg name='out' type='xmlBufferPtr'/>
      <arg name='in' type='xmlBufferPtr'/>
    </function>
    <function name='xmlCharEncOutFunc' file='encoding'>
      <info>Generic front-end for the encoding handler output function a first call with in == NULL has to be made firs to initiate the output in case of non-stateless encoding needing to initiate their state or the output (like the BOM in UTF16). In case of UTF8 sequence conversion errors for the given encoder, the content will be automatically remapped to a CharRef sequence.</info>
      <return type='int'/>
      <arg name='handler' type='xmlCharEncodingHandler *'/>
      <arg name='out' type='xmlBufferPtr'/>
      <arg name='in' type='xmlBufferPtr'/>
    </function>
    <enum name='xmlCharEncoding' file='encoding'/>
    <struct name='xmlCharEncodingHandler' file='encoding'/>
    <typedef name='xmlCharEncodingHandlerPtr' file='encoding'/>
    <functype name='xmlCharEncodingInputFunc' file='encoding' info='Take a block of chars in the original encoding and try to convert it to an UTF-8 block of chars out.'/>
    <functype name='xmlCharEncodingOutputFunc' file='encoding' info='Take a block of UTF-8 chars in and try to convert it to an other encoding. Note: a first call designed to produce heading info is called with in = NULL. If stateful this should also initialize the encoder state'/>
    <function name='xmlCharStrdup' file='parser'>
      <info>a strdup for char's to xmlChar's</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='const char *'/>
    </function>
    <function name='xmlCharStrndup' file='parser'>
      <info>a strndup for char's to xmlChar's</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='const char *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlCheckLanguageID' file='parserInternals'>
      <info>Checks that the value conforms to the LanguageID production: </info>
      <return type='int'/>
      <arg name='lang' type='const xmlChar *'/>
    </function>
    <function name='xmlCheckUTF8' file='encoding'>
      <info>Checks utf for being valid utf-8. utf is assumed to be null-terminated. This function is not super-strict, as it will allow longer utf-8 sequences than necessary. Note that Java is capable of producing these sequences if provoked. Also note, this routine checks for the 4-byte maximum size, but does not check for 0x10ffff maximum value.</info>
      <return type='int'/>
      <arg name='utf' type='const unsigned char *'/>
    </function>
    <function name='xmlCheckVersion' file='xmlversion'>
      <info>check the compiled lib version against the include one. This can warn or immediately kill the application</info>
      <return type='void'/>
      <arg name='version' type='int'/>
    </function>
    <macro name='xmlChildrenNode' file='tree' info='Macro for compatibility naming layer with libxml1'/>
    <function name='xmlCleanupCharEncodingHandlers' file='encoding'>
      <info>Cleanup the memory allocated for the char encoding support, it unregisters all the encoding handlers and the aliases.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCleanupEncodingAliases' file='encoding'>
      <info>Unregisters all aliases</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCleanupInputCallbacks' file='xmlIO'>
      <info>clears the entire input callback table. this includes the compiled-in I/O.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCleanupOutputCallbacks' file='xmlIO'>
      <info>clears the entire output callback table. this includes the compiled-in I/O callbacks.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCleanupParser' file='parser'>
      <info>Cleanup function for the XML parser. It tries to reclaim all parsing related global memory allocated for the parser processing. It doesn't deallocate any document related memory. Calling this function should not prevent reusing the parser.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCleanupPredefinedEntities' file='entities'>
      <info>Cleanup up the predefined entities table.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCleanupThreads' file='threads'>
      <info>xmlCleanupThreads() is used to to cleanup all the thread related data of the libxml2 library once processing has ended.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlClearNodeInfoSeq' file='parser'>
      <info>-- Clear (release memory and reinitialize) node info sequence</info>
      <return type='void'/>
      <arg name='seq' type='xmlParserNodeInfoSeqPtr'/>
    </function>
    <function name='xmlClearParserCtxt' file='parser'>
      <info>Clear (release owned resources) and reinitialize a parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlConvertSGMLCatalog' file='catalog'>
      <info>Convert all the SGML catalog entries as XML ones</info>
      <return type='int'/>
      <arg name='catal' type='xmlCatalogPtr'/>
    </function>
    <function name='xmlCopyAttributeTable' file='valid'>
      <info>Build a copy of an attribute table.</info>
      <return type='xmlAttributeTablePtr'/>
      <arg name='table' type='xmlAttributeTablePtr'/>
    </function>
    <function name='xmlCopyChar' file='parserInternals'>
      <info>append the char value in the array</info>
      <return type='int'/>
      <arg name='len' type='int'/>
      <arg name='out' type='xmlChar *'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlCopyCharMultiByte' file='parserInternals'>
      <info>append the char value in the array</info>
      <return type='int'/>
      <arg name='out' type='xmlChar *'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlCopyDoc' file='tree'>
      <info>Do a copy of the document info. If recursive, the content tree will be copied too as well as DTD, namespaces and entities.</info>
      <return type='xmlDocPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='recursive' type='int'/>
    </function>
    <function name='xmlCopyDtd' file='tree'>
      <info>Do a copy of the dtd.</info>
      <return type='xmlDtdPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
    </function>
    <function name='xmlCopyElementContent' file='valid'>
      <info>Build a copy of an element content description.</info>
      <return type='xmlElementContentPtr'/>
      <arg name='content' type='xmlElementContentPtr'/>
    </function>
    <function name='xmlCopyElementTable' file='valid'>
      <info>Build a copy of an element table.</info>
      <return type='xmlElementTablePtr'/>
      <arg name='table' type='xmlElementTablePtr'/>
    </function>
    <function name='xmlCopyEntitiesTable' file='entities'>
      <info>Build a copy of an entity table.</info>
      <return type='xmlEntitiesTablePtr'/>
      <arg name='table' type='xmlEntitiesTablePtr'/>
    </function>
    <function name='xmlCopyEnumeration' file='valid'>
      <info>Copy an enumeration attribute node (recursive).</info>
      <return type='xmlEnumerationPtr'/>
      <arg name='cur' type='xmlEnumerationPtr'/>
    </function>
    <function name='xmlCopyNamespace' file='tree'>
      <info>Do a copy of the namespace.</info>
      <return type='xmlNsPtr'/>
      <arg name='cur' type='xmlNsPtr'/>
    </function>
    <function name='xmlCopyNamespaceList' file='tree'>
      <info>Do a copy of an namespace list.</info>
      <return type='xmlNsPtr'/>
      <arg name='cur' type='xmlNsPtr'/>
    </function>
    <function name='xmlCopyNode' file='tree'>
      <info>Do a copy of the node.</info>
      <return type='xmlNodePtr'/>
      <arg name='node' type='const xmlNodePtr'/>
      <arg name='recursive' type='int'/>
    </function>
    <function name='xmlCopyNodeList' file='tree'>
      <info>Do a recursive copy of the node list.</info>
      <return type='xmlNodePtr'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlCopyNotationTable' file='valid'>
      <info>Build a copy of a notation table.</info>
      <return type='xmlNotationTablePtr'/>
      <arg name='table' type='xmlNotationTablePtr'/>
    </function>
    <function name='xmlCopyProp' file='tree'>
      <info>Do a copy of the attribute.</info>
      <return type='xmlAttrPtr'/>
      <arg name='target' type='xmlNodePtr'/>
      <arg name='cur' type='xmlAttrPtr'/>
    </function>
    <function name='xmlCopyPropList' file='tree'>
      <info>Do a copy of an attribute list.</info>
      <return type='xmlAttrPtr'/>
      <arg name='target' type='xmlNodePtr'/>
      <arg name='cur' type='xmlAttrPtr'/>
    </function>
    <function name='xmlCreateDocParserCtxt' file='parser'>
      <info>Creates a parser context for an XML in-memory document.</info>
      <return type='xmlParserCtxtPtr'/>
      <arg name='cur' type='xmlChar *'/>
    </function>
    <function name='xmlCreateEntitiesTable' file='entities'>
      <info>create and initialize an empty entities hash table.</info>
      <return type='xmlEntitiesTablePtr'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCreateEntityParserCtxt' file='parserInternals'>
      <info>Create a parser context for an external entity Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlParserCtxtPtr'/>
      <arg name='URL' type='const xmlChar *'/>
      <arg name='ID' type='const xmlChar *'/>
      <arg name='base' type='const xmlChar *'/>
    </function>
    <function name='xmlCreateEnumeration' file='valid'>
      <info>create and initialize an enumeration attribute node.</info>
      <return type='xmlEnumerationPtr'/>
      <arg name='name' type='xmlChar *'/>
    </function>
    <function name='xmlCreateFileParserCtxt' file='parserInternals'>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlParserCtxtPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlCreateIOParserCtxt' file='parser'>
      <info>Create a parser context for using the XML parser with an existing I/O stream</info>
      <return type='xmlParserCtxtPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='ioread' type='xmlInputReadCallback'/>
      <arg name='ioclose' type='xmlInputCloseCallback'/>
      <arg name='ioctx' type='void *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlCreateIntSubset' file='tree'>
      <info>Create the internal subset of a document</info>
      <return type='xmlDtdPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <function name='xmlCreateMemoryParserCtxt' file='parserInternals'>
      <info>Create a parser context for an XML in-memory document.</info>
      <return type='xmlParserCtxtPtr'/>
      <arg name='buffer' type='const char *'/>
      <arg name='size' type='int'/>
    </function>
    <function name='xmlCreatePushParserCtxt' file='parser'>
      <info>Create a parser context for using the XML parser in push mode To allow content encoding detection, size should be &gt;= 4 The value of filename is used for fetching external entities and error/warning reports.</info>
      <return type='xmlParserCtxtPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='chunk' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlCreateURI' file='uri'>
      <info>Simply creates an empty xmlURI</info>
      <return type='xmlURIPtr'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlCurrentChar' file='parserInternals'>
      <info>The current char value, if using UTF-8 this may actually span multiple bytes in the input buffer. Implement the end of line normalization: 2.11 End-of-Line Handling Wherever an external parsed entity or the literal entity value of an internal parsed entity contains either the literal two-character sequence "xDxA" or a standalone literal xD, an XML processor must pass to the application the single character xA. This behavior can conveniently be produced by normalizing all line breaks to xA on input, before parsing.)</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='len' type='int *'/>
    </function>
    <function name='xmlDebugDumpAttr' file='debugXML'>
      <info>Dumps debug information for the attribute</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='attr' type='xmlAttrPtr'/>
      <arg name='depth' type='int'/>
    </function>
    <function name='xmlDebugDumpAttrList' file='debugXML'>
      <info>Dumps debug information for the attribute list</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='attr' type='xmlAttrPtr'/>
      <arg name='depth' type='int'/>
    </function>
    <function name='xmlDebugDumpDTD' file='debugXML'>
      <info>Dumps debug information for the DTD</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='dtd' type='xmlDtdPtr'/>
    </function>
    <function name='xmlDebugDumpDocument' file='debugXML'>
      <info>Dumps debug information for the document, it's recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlDebugDumpDocumentHead' file='debugXML'>
      <info>Dumps debug information cncerning the document, not recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlDebugDumpEntities' file='debugXML'>
      <info>Dumps debug information for all the entities in use by the document</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlDebugDumpNode' file='debugXML'>
      <info>Dumps debug information for the element node, it is recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='depth' type='int'/>
    </function>
    <function name='xmlDebugDumpNodeList' file='debugXML'>
      <info>Dumps debug information for the list of element node, it is recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='depth' type='int'/>
    </function>
    <function name='xmlDebugDumpOneNode' file='debugXML'>
      <info>Dumps debug information for the element node, it is not recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='depth' type='int'/>
    </function>
    <function name='xmlDebugDumpString' file='debugXML'>
      <info>Dumps informations about the string, shorten it if necessary</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='str' type='const xmlChar *'/>
    </function>
    <function name='xmlDecodeEntities' file='parserInternals'>
      <info>This function is deprecated, we now always process entities content through xmlStringDecodeEntities </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='len' type='int'/>
      <arg name='what' type='int'/>
      <arg name='end' type='xmlChar'/>
      <arg name='end2' type='xmlChar'/>
      <arg name='end3' type='xmlChar'/>
    </function>
    <macro name='xmlDefaultBufferSize' file='globals'/>
    <macro name='xmlDefaultSAXHandler' file='globals'/>
    <function name='xmlDefaultSAXHandlerInit' file='parser'>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <macro name='xmlDefaultSAXLocator' file='globals'/>
    <function name='xmlDelEncodingAlias' file='encoding'>
      <info>Unregisters an encoding alias alias</info>
      <return type='int'/>
      <arg name='alias' type='const char *'/>
    </function>
    <function name='xmlDetectCharEncoding' file='encoding'>
      <info>Guess the encoding of the entity using the first bytes of the entity content accordingly of the non-normative appendix F of the XML-1.0 recommendation.</info>
      <return type='xmlCharEncoding'/>
      <arg name='in' type='const unsigned char *'/>
      <arg name='len' type='int'/>
    </function>
    <macro name='xmlDoValidityCheckingDefaultValue' file='globals'/>
    <struct name='xmlDoc' file='tree' info='An XML document.'/>
    <function name='xmlDocCopyNode' file='tree'>
      <info>Do a copy of the node to a given document.</info>
      <return type='xmlNodePtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='recursive' type='int'/>
    </function>
    <function name='xmlDocDump' file='tree'>
      <info>Dump an XML document to an open FILE.</info>
      <return type='int'/>
      <arg name='f' type='FILE *'/>
      <arg name='cur' type='xmlDocPtr'/>
    </function>
    <function name='xmlDocDumpFormatMemory' file='tree'>
      <info>Dump an XML document in memory and return the xmlChar * and it's size. It's up to the caller to free the memory.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='mem' type='xmlChar **'/>
      <arg name='size' type='int *'/>
      <arg name='format' type='int'/>
    </function>
    <function name='xmlDocDumpFormatMemoryEnc' file='tree'>
      <info>Dump the current DOM tree into memory using the character encoding specified by the caller. Note it is up to the caller of this function to free the allocated memory.</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr out_'/>
      <arg name='ptr' type='xmlChar **doc_txt_'/>
      <arg name='len' type='int * doc_txt_'/>
      <arg name='encoding' type='const char *txt_'/>
      <arg name='format' type='int'/>
    </function>
    <function name='xmlDocDumpMemory' file='tree'>
      <info>Dump an XML document in memory and return the xmlChar * and it's size. It's up to the caller to free the memory.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='mem' type='xmlChar **'/>
      <arg name='size' type='int *'/>
    </function>
    <function name='xmlDocDumpMemoryEnc' file='tree'>
      <info>Dump the current DOM tree into memory using the character encoding specified by the caller. Note it is up to the caller of this function to free the allocated memory.</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr out_'/>
      <arg name='ptr' type='xmlChar **doc_txt_'/>
      <arg name='len' type='int * doc_txt_'/>
      <arg name='encoding' type='const char *txt_'/>
    </function>
    <function name='xmlDocGetRootElement' file='tree'>
      <info>Get the root element of the document (doc-&gt;children is a list containing possibly comments, PIs, etc ...).</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <typedef name='xmlDocPtr' file='tree'/>
    <function name='xmlDocSetRootElement' file='tree'>
      <info>Set the root element of the document (doc-&gt;children is a list containing possibly comments, PIs, etc ...).</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='root' type='xmlNodePtr'/>
    </function>
    <struct name='xmlDtd' file='tree' info='An XML DTD, as defined by &lt;!DOCTYPE ... There is actually one for the internal subset and for the external subset'/>
    <typedef name='xmlDtdPtr' file='tree'/>
    <function name='xmlDumpAttributeDecl' file='valid'>
      <info>This will dump the content of the attribute declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='attr' type='xmlAttributePtr'/>
    </function>
    <function name='xmlDumpAttributeTable' file='valid'>
      <info>This will dump the content of the attribute table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='table' type='xmlAttributeTablePtr'/>
    </function>
    <function name='xmlDumpElementDecl' file='valid'>
      <info>This will dump the content of the element declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='elem' type='xmlElementPtr'/>
    </function>
    <function name='xmlDumpElementTable' file='valid'>
      <info>This will dump the content of the element table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='table' type='xmlElementTablePtr'/>
    </function>
    <function name='xmlDumpEntitiesTable' file='entities'>
      <info>This will dump the content of the entity table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='table' type='xmlEntitiesTablePtr'/>
    </function>
    <function name='xmlDumpEntityDecl' file='entities'>
      <info>This will dump the content of the entity table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='ent' type='xmlEntityPtr'/>
    </function>
    <function name='xmlDumpNotationDecl' file='valid'>
      <info>This will dump the content the notation declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='nota' type='xmlNotationPtr'/>
    </function>
    <function name='xmlDumpNotationTable' file='valid'>
      <info>This will dump the content of the notation table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='table' type='xmlNotationTablePtr'/>
    </function>
    <function name='xmlElemDump' file='tree'>
      <info>Dump an XML/HTML node, recursive behaviour, children are printed too.</info>
      <return type='void'/>
      <arg name='f' type='FILE *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <struct name='xmlElement' file='tree' info='an XML Element declaration from a DTD'/>
    <struct name='xmlElementContent' file='tree' info='an XML Element content as stored after parsing an element definition in a DTD.'/>
    <enum name='xmlElementContentOccur' file='tree'/>
    <typedef name='xmlElementContentPtr' file='tree'/>
    <enum name='xmlElementContentType' file='tree'/>
    <typedef name='xmlElementPtr' file='tree'/>
    <typedef name='xmlElementTablePtr' file='valid'/>
    <enum name='xmlElementType' file='tree'/>
    <enum name='xmlElementTypeVal' file='tree'/>
    <function name='xmlEncodeEntities' file='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities and non ASCII values with their entities and CharRef counterparts. </info>
      <return type='const xmlChar *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='input' type='const xmlChar *'/>
    </function>
    <function name='xmlEncodeEntitiesReentrant' file='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities and non ASCII values with their entities and CharRef counterparts. Contrary to xmlEncodeEntities, this routine is reentrant, and result must be deallocated.</info>
      <return type='xmlChar *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='input' type='const xmlChar *'/>
    </function>
    <function name='xmlEncodeSpecialChars' file='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities this routine is reentrant, and result must be deallocated.</info>
      <return type='xmlChar *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='input' type='const xmlChar *'/>
    </function>
    <typedef name='xmlEntitiesTablePtr' file='entities'/>
    <struct name='xmlEntity' file='entities'/>
    <typedef name='xmlEntityPtr' file='entities'/>
    <functype name='xmlEntityReferenceFunc' file='parserInternals'/>
    <enum name='xmlEntityType' file='entities'/>
    <struct name='xmlEnumeration' file='tree' info='list structure used when there is an enumeration in DTDs'/>
    <typedef name='xmlEnumerationPtr' file='tree'/>
    <functype name='xmlExternalEntityLoader' file='parser' info='External entity loaders types'/>
    <function name='xmlFindCharEncodingHandler' file='encoding'>
      <info>Search in the registered set the handler able to read/write that encoding.</info>
      <return type='xmlCharEncodingHandlerPtr'/>
      <arg name='name' type='const char *'/>
    </function>
    <macro name='xmlFree' file='globals'/>
    <function name='xmlFreeAttributeTable' file='valid'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlAttributeTablePtr'/>
    </function>
    <function name='xmlFreeCatalog' file='catalog'>
      <info>Free the memory allocated to a Catalog</info>
      <return type='void'/>
      <arg name='catal' type='xmlCatalogPtr'/>
    </function>
    <function name='xmlFreeDoc' file='tree'>
      <info>Free up all the structures used by a document, tree included.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr'/>
    </function>
    <function name='xmlFreeDtd' file='tree'>
      <info>Free a DTD structure.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDtdPtr'/>
    </function>
    <function name='xmlFreeElementContent' file='valid'>
      <info>Free an element content structure. This is a recursive call !</info>
      <return type='void'/>
      <arg name='cur' type='xmlElementContentPtr'/>
    </function>
    <function name='xmlFreeElementTable' file='valid'>
      <info>Deallocate the memory used by an element hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlElementTablePtr'/>
    </function>
    <function name='xmlFreeEntitiesTable' file='entities'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlEntitiesTablePtr'/>
    </function>
    <function name='xmlFreeEnumeration' file='valid'>
      <info>free an enumeration attribute node (recursive).</info>
      <return type='void'/>
      <arg name='cur' type='xmlEnumerationPtr'/>
    </function>
    <functype name='xmlFreeFunc' file='xmlmemory'/>
    <function name='xmlFreeIDTable' file='valid'>
      <info>Deallocate the memory used by an ID hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlIDTablePtr'/>
    </function>
    <function name='xmlFreeInputStream' file='parserInternals'>
      <info>Free up an input stream.</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr'/>
    </function>
    <function name='xmlFreeMutex' file='threads'>
      <info>xmlFreeMutex() is used to reclaim resources associated with a libxml2 token struct.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr'/>
    </function>
    <function name='xmlFreeNode' file='tree'>
      <info>Free a node, this is a recursive behaviour, all the children are freed too. This doesn't unlink the child from the list, use xmlUnlinkNode() first.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlFreeNodeList' file='tree'>
      <info>Free a node and all its siblings, this is a recursive behaviour, all the children are freed too.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlFreeNotationTable' file='valid'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlNotationTablePtr'/>
    </function>
    <function name='xmlFreeNs' file='tree'>
      <info>Free up the structures associated to a namespace</info>
      <return type='void'/>
      <arg name='cur' type='xmlNsPtr'/>
    </function>
    <function name='xmlFreeNsList' file='tree'>
      <info>Free up all the structures associated to the chained namespaces.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNsPtr'/>
    </function>
    <function name='xmlFreeParserCtxt' file='parserInternals'>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlFreeParserInputBuffer' file='xmlIO'>
      <info>Free up the memory used by a buffered parser input</info>
      <return type='void'/>
      <arg name='in' type='xmlParserInputBufferPtr'/>
    </function>
    <function name='xmlFreeProp' file='tree'>
      <info>Free one attribute, all the content is freed too</info>
      <return type='void'/>
      <arg name='cur' type='xmlAttrPtr'/>
    </function>
    <function name='xmlFreePropList' file='tree'>
      <info>Free a property and all its siblings, all the children are freed too.</info>
      <return type='void'/>
      <arg name='cur' type='xmlAttrPtr'/>
    </function>
    <function name='xmlFreeRMutex' file='threads'>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr'/>
    </function>
    <function name='xmlFreeRefTable' file='valid'>
      <info>Deallocate the memory used by an Ref hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlRefTablePtr'/>
    </function>
    <function name='xmlFreeURI' file='uri'>
      <info>Free up the xmlURI struct</info>
      <return type='void'/>
      <arg name='uri' type='xmlURIPtr'/>
    </function>
    <macro name='xmlGenericError' file='globals'/>
    <macro name='xmlGenericErrorContext' file='globals'/>
    <functype name='xmlGenericErrorFunc' file='xmlerror'/>
    <function name='xmlGetBufferAllocationScheme' file='tree'>
      <info>Types are XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,  improves performance</info>
      <return type='xmlBufferAllocationScheme'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlGetCharEncodingHandler' file='encoding'>
      <info>Search in the registered set the handler able to read/write that encoding.</info>
      <return type='xmlCharEncodingHandlerPtr'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlGetCharEncodingName' file='encoding'>
      <info>The "canonical" name for XML encoding. C.f. http://www.w3.org/TR/REC-xmlcharencoding Section 4.3.3 Character Encoding in Entities</info>
      <return type='const char *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlGetCompressMode' file='tree'>
      <info>get the default compression mode used, ZLIB based.</info>
      <return type='int'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlGetDocCompressMode' file='tree'>
      <info>get the compression ratio for a document, ZLIB based</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlGetDocEntity' file='entities'>
      <info>Do an entity lookup in the document entity hash table and returns the corresponding entity, otherwise a lookup is done in the predefined entities too.</info>
      <return type='xmlEntityPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetDtdAttrDesc' file='valid'>
      <info>Search the DTD for the description of this attribute on this element.</info>
      <return type='xmlAttributePtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='elem' type='const xmlChar *'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetDtdElementDesc' file='valid'>
      <info>Search the DTD for the description of this element</info>
      <return type='xmlElementPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetDtdEntity' file='entities'>
      <info>Do an entity lookup in the DTD entity hash table and returns the corresponding entity, if found.</info>
      <return type='xmlEntityPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetDtdNotationDesc' file='valid'>
      <info>Search the DTD for the description of this notation</info>
      <return type='xmlNotationPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetDtdQAttrDesc' file='valid'>
      <info>Search the DTD for the description of this qualified attribute on this element.</info>
      <return type='xmlAttributePtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='elem' type='const xmlChar *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='prefix' type='const xmlChar *'/>
    </function>
    <function name='xmlGetDtdQElementDesc' file='valid'>
      <info>Search the DTD for the description of this element</info>
      <return type='xmlElementPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='prefix' type='const xmlChar *'/>
    </function>
    <function name='xmlGetEncodingAlias' file='encoding'>
      <info>Lookup an encoding name for the given alias.</info>
      <return type='const char *'/>
      <arg name='alias' type='const char *'/>
    </function>
    <function name='xmlGetExternalEntityLoader' file='parser'>
      <info>Get the default external entity resolver function for the application</info>
      <return type='xmlExternalEntityLoader'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlGetFeature' file='parser'>
      <info>Read the current value of one feature of this parser instance</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='name' type='const char *'/>
      <arg name='result' type='void *'/>
    </function>
    <function name='xmlGetFeaturesList' file='parser'>
      <info>Copy at most *len feature names into the result array</info>
      <return type='int'/>
      <arg name='len' type='int *'/>
      <arg name='result' type='const char **'/>
    </function>
    <function name='xmlGetGlobalState' file='threads'>
      <info>xmlGetGlobalState() is called to retrieve the global state for a thread.</info>
      <return type='xmlGlobalStatePtr'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlGetID' file='valid'>
      <info>Search the attribute declaring the given ID</info>
      <return type='xmlAttrPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='ID' type='const xmlChar *'/>
    </function>
    <function name='xmlGetIntSubset' file='tree'>
      <info>Get the internal subset of a document</info>
      <return type='xmlDtdPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlGetLastChild' file='tree'>
      <info>Search the last child of a node.</info>
      <return type='xmlNodePtr'/>
      <arg name='parent' type='xmlNodePtr'/>
    </function>
    <function name='xmlGetLineNo' file='tree'>
      <info>Get line number of node. this requires activation of this option before invoking the parser by calling xmlLineNumbersDefault(1)</info>
      <return type='long'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlGetNodePath' file='tree'>
      <info>Build a structure based Path for the given node</info>
      <return type='xmlChar *'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlGetNsList' file='tree'>
      <info>Search all the namespace applying to a given element.</info>
      <return type='xmlNsPtr *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlGetNsProp' file='tree'>
      <info>Search and get the value of an attribute associated to a node This attribute has to be anchored in the namespace specified. This does the entity substitution. This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlChar *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='nameSpace' type='const xmlChar *'/>
    </function>
    <function name='xmlGetParameterEntity' file='entities'>
      <info>Do an entity lookup in the internal and external subsets and returns the corresponding parameter entity, if found.</info>
      <return type='xmlEntityPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetPredefinedEntity' file='entities'>
      <info>Check whether this name is an predefined entity.</info>
      <return type='xmlEntityPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetProp' file='tree'>
      <info>Search and get the value of an attribute associated to a node This does the entity substitution. This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlChar *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlGetRefs' file='valid'>
      <info>Find the set of references for the supplied ID.</info>
      <return type='xmlListPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='ID' type='const xmlChar *'/>
    </function>
    <function name='xmlGetThreadId' file='threads'>
      <info>xmlGetThreadId() find the current thread ID number</info>
      <return type='int'/>
      <arg name='void' type=''/>
    </function>
    <macro name='xmlGetWarningsDefaultValue' file='globals'/>
    <struct name='xmlGlobalState' file='globals'/>
    <typedef name='xmlGlobalStatePtr' file='globals'/>
    <function name='xmlHandleEntity' file='parserInternals'>
      <info>Default handling of defined entities, when should we define a new input stream ? When do we just handle that as a set of chars ? </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='entity' type='xmlEntityPtr'/>
    </function>
    <function name='xmlHasNsProp' file='tree'>
      <info>Search for an attribute associated to a node This attribute has to be anchored in the namespace specified. This does the entity substitution. This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlAttrPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='nameSpace' type='const xmlChar *'/>
    </function>
    <function name='xmlHasProp' file='tree'>
      <info>Search an attribute associated to a node This function also looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlAttrPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlHashAddEntry' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the name. Duplicate names generate errors.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='userdata' type='void *'/>
    </function>
    <function name='xmlHashAddEntry2' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the (name, name2) tuple. Duplicate tuples generate errors.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='userdata' type='void *'/>
    </function>
    <function name='xmlHashAddEntry3' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the tuple (name, name2, name3). Duplicate entries generate errors.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='name3' type='const xmlChar *'/>
      <arg name='userdata' type='void *'/>
    </function>
    <functype name='xmlHashCopier' file='hash'/>
    <function name='xmlHashCopy' file='hash'>
      <info>Scan the hash table and applied f to each value.</info>
      <return type='xmlHashTablePtr'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='f' type='xmlHashCopier'/>
    </function>
    <function name='xmlHashCreate' file='hash'>
      <info>Create a new xmlHashTablePtr.</info>
      <return type='xmlHashTablePtr'/>
      <arg name='size' type='int'/>
    </function>
    <functype name='xmlHashDeallocator' file='hash'/>
    <function name='xmlHashFree' file='hash'>
      <info>Free the hash table and its contents. The userdata is deallocated with f if provided.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='f' type='xmlHashDeallocator'/>
    </function>
    <function name='xmlHashLookup' file='hash'>
      <info>Find the userdata specified by the name.</info>
      <return type='void *'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlHashLookup2' file='hash'>
      <info>Find the userdata specified by the (name, name2) tuple.</info>
      <return type='void *'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
    </function>
    <function name='xmlHashLookup3' file='hash'>
      <info>Find the userdata specified by the (name, name2, name3) tuple.</info>
      <return type='void *'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='name3' type='const xmlChar *'/>
    </function>
    <function name='xmlHashRemoveEntry' file='hash'>
      <info>Find the userdata specified by the name and remove it from the hash table. Existing userdata for this tuple will be removed and freed with f.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='f' type='xmlHashDeallocator'/>
    </function>
    <function name='xmlHashRemoveEntry2' file='hash'>
      <info>Find the userdata specified by the (name, name2) tuple and remove it from the hash table. Existing userdata for this tuple will be removed and freed with f.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='f' type='xmlHashDeallocator'/>
    </function>
    <function name='xmlHashRemoveEntry3' file='hash'>
      <info>Find the userdata specified by the (name, name2, name3) tuple and remove it from the hash table. Existing userdata for this tuple will be removed and freed with f.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='name3' type='const xmlChar *'/>
      <arg name='f' type='xmlHashDeallocator'/>
    </function>
    <function name='xmlHashScan' file='hash'>
      <info>Scan the hash table and applied f to each value.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='f' type='xmlHashScanner'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlHashScan3' file='hash'>
      <info>Scan the hash table and applied f to each value matching (name, name2, name3) tuple. If one of the names is null, the comparison is considered to match.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='name3' type='const xmlChar *'/>
      <arg name='f' type='xmlHashScanner'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlHashScanFull' file='hash'>
      <info>Scan the hash table and applied f to each value.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='f' type='xmlHashScannerFull'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlHashScanFull3' file='hash'>
      <info>Scan the hash table and applied f to each value matching (name, name2, name3) tuple. If one of the names is null, the comparison is considered to match.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='name3' type='const xmlChar *'/>
      <arg name='f' type='xmlHashScannerFull'/>
      <arg name='data' type='void *'/>
    </function>
    <functype name='xmlHashScanner' file='hash'/>
    <functype name='xmlHashScannerFull' file='hash'/>
    <function name='xmlHashSize' file='hash'>
      <info>Query the number of elements installed in the hash table.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
    </function>
    <struct name='xmlHashTable' file='hash'/>
    <typedef name='xmlHashTablePtr' file='hash'/>
    <function name='xmlHashUpdateEntry' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the name. Existing entry for this name will be removed and freed with f if found.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='userdata' type='void *'/>
      <arg name='f' type='xmlHashDeallocator'/>
    </function>
    <function name='xmlHashUpdateEntry2' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the (name, name2) tuple. Existing entry for this tuple will be removed and freed with f if found.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='userdata' type='void *'/>
      <arg name='f' type='xmlHashDeallocator'/>
    </function>
    <function name='xmlHashUpdateEntry3' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the tuple (name, name2, name3). Existing entry for this tuple will be removed and freed with f if found.</info>
      <return type='int'/>
      <arg name='table' type='xmlHashTablePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='name2' type='const xmlChar *'/>
      <arg name='name3' type='const xmlChar *'/>
      <arg name='userdata' type='void *'/>
      <arg name='f' type='xmlHashDeallocator'/>
    </function>
    <struct name='xmlID' file='tree' info='An XML ID instance.'/>
    <typedef name='xmlIDPtr' file='tree'/>
    <typedef name='xmlIDTablePtr' file='valid'/>
    <function name='xmlIOHTTPOpenW' file='xmlIO'>
      <info>Open a temporary buffer to collect the document for a subsequent HTTP POST request. Non-static as is called from the output buffer creation routine.</info>
      <return type='void *'/>
      <arg name='uri' type='const char * post_'/>
      <arg name='compression' type='int'/>
    </function>
    <function name='xmlIOParseDTD' file='parser'>
      <info>Load and parse a DTD</info>
      <return type='xmlDtdPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='input' type='xmlParserInputBufferPtr'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <macro name='xmlIndentTreeOutput' file='globals'/>
    <function name='xmlInitCharEncodingHandlers' file='encoding'>
      <info>Initialize the char encoding support, it registers the default encoding supported. NOTE: while public, this function usually doesn't need to be called in normal processing.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlInitMemory' file='xmlmemory'>
      <info>Initialize the memory layer.</info>
      <return type='int'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlInitNodeInfoSeq' file='parser'>
      <info>-- Initialize (set to initial state) node info sequence</info>
      <return type='void'/>
      <arg name='seq' type='xmlParserNodeInfoSeqPtr'/>
    </function>
    <function name='xmlInitParser' file='parser'>
      <info>Initialization function for the XML parser. This is not reentrant. Call once before processing in case of use in multithreaded programs.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlInitParserCtxt' file='parser'>
      <info>Initialize a parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlInitThreads' file='threads'>
      <info>xmlInitThreads() is used to to initialize all the thread related data of the libxml2 library.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlInitializeCatalog' file='catalog'>
      <info>Do the catalog initialization. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlInitializeGlobalState' file='globals'>
      <info>xmlInitializeGlobalState() initialize a global state with all the default values of the library.</info>
      <return type='void'/>
      <arg name='gs' type='xmlGlobalStatePtr'/>
    </function>
    <function name='xmlInitializePredefinedEntities' file='entities'>
      <info>Set up the predefined entities.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <functype name='xmlInputCloseCallback' file='xmlIO'/>
    <functype name='xmlInputMatchCallback' file='xmlIO'/>
    <functype name='xmlInputOpenCallback' file='xmlIO'/>
    <functype name='xmlInputReadCallback' file='xmlIO'/>
    <function name='xmlIsBaseChar' file='parserInternals'>
      <info>Check whether the character is allowed by the production [85] BaseChar ::= ... long list see REC ... </info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsBlank' file='parserInternals'>
      <info>Check whether the character is allowed by the production [3] S ::= (x20 | x9 | xD | xA)+ Also available as a macro IS_BLANK()</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsBlankNode' file='tree'>
      <info>Checks whether this node is an empty or whitespace only (and possibly ignorable) text-node.</info>
      <return type='int'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlIsChar' file='parserInternals'>
      <info>Check whether the character is allowed by the production [2] Char ::= x9 | xA | xD | [x20-xD7FF] | [xE000-xFFFD] | [x10000-x10FFFF] any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. Also available as a macro IS_CHAR()</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsCombining' file='parserInternals'>
      <info>Check whether the character is allowed by the production [87] CombiningChar ::= ... long list see REC ...</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsDigit' file='parserInternals'>
      <info>Check whether the character is allowed by the production [88] Digit ::= ... long list see REC ...</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsExtender' file='parserInternals'>
      <info>Check whether the character is allowed by the production [89] Extender ::= x00B7 | x02D0 | x02D1 | x0387 | x0640 |  x0E46 | x0EC6 | x3005 | [x3031-x3035] |  [x309D-x309E] | [x30FC-x30FE]</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsID' file='valid'>
      <info>Determine whether an attribute is of type ID. In case we have DTD(s) then this is simple, otherwise we use an heuristic: name ID (upper or lowercase).</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlNodePtr'/>
      <arg name='attr' type='xmlAttrPtr'/>
    </function>
    <function name='xmlIsIdeographic' file='parserInternals'>
      <info>Check whether the character is allowed by the production [86] Ideographic ::= [x4E00-x9FA5] | x3007 | [x3021-x3029]</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsLetter' file='parserInternals'>
      <info>Check whether the character is allowed by the production [84] Letter ::= BaseChar | Ideographic</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsMainThread' file='threads'>
      <info>xmlIsMainThread() check whether the current thread is the main thread.</info>
      <return type='int'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlIsMixedElement' file='valid'>
      <info>Search in the DtDs whether an element accept Mixed content (or ANY) basically if it is supposed to accept text childs</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlIsPubidChar' file='parserInternals'>
      <info>Check whether the character is allowed by the production [13] PubidChar ::= x20 | xD | xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]</info>
      <return type='int'/>
      <arg name='c' type='int'/>
    </function>
    <function name='xmlIsRef' file='valid'>
      <info>Determine whether an attribute is of type Ref. In case we have DTD(s) then this is simple, otherwise we use an heuristic: name Ref (upper or lowercase).</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlNodePtr'/>
      <arg name='attr' type='xmlAttrPtr'/>
    </function>
    <function name='xmlKeepBlanksDefault' file='parser'>
      <info>Set and return the previous value for default blanks text nodes support. The 1.x version of the parser used an heuristic to try to detect ignorable white spaces. As a result the SAX callback was generating ignorableWhitespace() callbacks instead of characters() one, and when using the DOM output text nodes containing those blanks were not generated. The 2.x and later version will switch to the XML standard way and ignorableWhitespace() are only generated when running the parser in validating mode and when the current element doesn't allow CDATA or mixed content. This function is provided as a way to force the standard behavior on 1.X libs and to switch back to the old mode for compatibility when running 1.X client code on 2.X . Upgrade of 1.X code should be done by using xmlIsBlankNode() commodity function to detect the "empty" nodes generated. This value also affect autogeneration of indentation when saving code if blanks sections are kept, indentation is not generated.</info>
      <return type='int'/>
      <arg name='val' type='int'/>
    </function>
    <macro name='xmlKeepBlanksDefaultValue' file='globals'/>
    <function name='xmlLineNumbersDefault' file='parser'>
      <info>Set and return the previous value for enabling line numbers in elements contents. This may break on old application and is turned off by default.</info>
      <return type='int'/>
      <arg name='val' type='int'/>
    </function>
    <macro name='xmlLineNumbersDefaultValue' file='globals'/>
    <struct name='xmlLink' file='list'/>
    <function name='xmlLinkGetData' file='list'>
      <info>See Returns.</info>
      <return type='void *'/>
      <arg name='lk' type='xmlLinkPtr'/>
    </function>
    <typedef name='xmlLinkPtr' file='list'/>
    <struct name='xmlList' file='list'/>
    <function name='xmlListAppend' file='list'>
      <info>Insert data in the ordered list at the end for this value</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListClear' file='list'>
      <info>Remove the all data in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListCopy' file='list'>
      <info>Move all the element from the old list in the new list</info>
      <return type='int'/>
      <arg name='cur' type='xmlListPtr'/>
      <arg name='old' type='const xmlListPtr'/>
    </function>
    <function name='xmlListCreate' file='list'>
      <info>Create a new list</info>
      <return type='xmlListPtr'/>
      <arg name='deallocator' type='xmlListDeallocator'/>
      <arg name='compare' type='xmlListDataCompare'/>
    </function>
    <functype name='xmlListDataCompare' file='list'/>
    <functype name='xmlListDeallocator' file='list'/>
    <function name='xmlListDelete' file='list'>
      <info>Deletes the list and its associated data</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListDup' file='list'>
      <info>Duplicate the list</info>
      <return type='xmlListPtr'/>
      <arg name='old' type='const xmlListPtr'/>
    </function>
    <function name='xmlListEmpty' file='list'>
      <info>Is the list empty ?</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListEnd' file='list'>
      <info>Get the last element in the list</info>
      <return type='xmlLinkPtr'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListFront' file='list'>
      <info>Get the first element in the list</info>
      <return type='xmlLinkPtr'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListInsert' file='list'>
      <info>Insert data in the ordered list at the beginning for this value</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListMerge' file='list'>
      <info>include all the elements of the second list in the first one and clear the second list</info>
      <return type='void'/>
      <arg name='l1' type='xmlListPtr'/>
      <arg name='l2' type='xmlListPtr'/>
    </function>
    <function name='xmlListPopBack' file='list'>
      <info>Removes the last element in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListPopFront' file='list'>
      <info>Removes the first element in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <typedef name='xmlListPtr' file='list'/>
    <function name='xmlListPushBack' file='list'>
      <info>add the new data at the end of the list</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListPushFront' file='list'>
      <info>add the new data at the beginning of the list</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListRemoveAll' file='list'>
      <info>Remove the all instance associated to data in the list</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListRemoveFirst' file='list'>
      <info>Remove the first instance associated to data in the list</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListRemoveLast' file='list'>
      <info>Remove the last instance associated to data in the list</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListReverse' file='list'>
      <info>Reverse the order of the elements in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListReverseSearch' file='list'>
      <info>Search the list in reverse order for an existing value of data</info>
      <return type='void *'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListReverseWalk' file='list'>
      <info>Walk all the element of the list in reverse order and apply the walker function to it</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='walker' type='xmlListWalker'/>
      <arg name='user' type='const void *'/>
    </function>
    <function name='xmlListSearch' file='list'>
      <info>Search the list for an existing value of data</info>
      <return type='void *'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlListSize' file='list'>
      <info>Get the number of elements in the list</info>
      <return type='int'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListSort' file='list'>
      <info>Sort all the elements in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
    </function>
    <function name='xmlListWalk' file='list'>
      <info>Walk all the element of the first from first to last and apply the walker function to it</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr'/>
      <arg name='walker' type='xmlListWalker'/>
      <arg name='user' type='const void *'/>
    </function>
    <functype name='xmlListWalker' file='list'/>
    <function name='xmlLoadACatalog' file='catalog'>
      <info>Load the catalog and build the associated data structures. This can be either an XML Catalog or an SGML Catalog It will recurse in SGML CATALOG entries. On the other hand XML Catalogs are not handled recursively.</info>
      <return type='xmlCatalogPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlLoadCatalog' file='catalog'>
      <info>Load the catalog and makes its definitions effective for the default external entity loader. It will recurse in SGML CATALOG entries. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlLoadCatalogs' file='catalog'>
      <info>Load the catalogs and makes their definitions effective for the default external entity loader. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='void'/>
      <arg name='paths' type='const char *'/>
    </function>
    <macro name='xmlLoadExtDtdDefaultValue' file='globals'/>
    <function name='xmlLoadExternalEntity' file='parser'>
      <info>Load an external entity, note that the use of this function for unparsed entities may generate problems TODO: a more generic External entity API must be designed</info>
      <return type='xmlParserInputPtr'/>
      <arg name='URL' type='const char *'/>
      <arg name='ID' type='const char *'/>
      <arg name='context' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlLoadSGMLSuperCatalog' file='catalog'>
      <info>Load an SGML super catalog. It won't expand CATALOG or DELEGATE references. This is only needed for manipulating SGML Super Catalogs like adding and removing CATALOG or DELEGATE entries.</info>
      <return type='xmlCatalogPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <struct name='xmlLocationSet' file='xpointer'/>
    <typedef name='xmlLocationSetPtr' file='xpointer'/>
    <function name='xmlLockLibrary' file='threads'>
      <info>xmlLockLibrary() is used to take out a re-entrant lock on the libxml2 library.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlLsCountNode' file='debugXML'>
      <info>Count the children of node.</info>
      <return type='int'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlLsOneNode' file='debugXML'>
      <info>Dump to output the type and name of node.</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <macro name='xmlMalloc' file='globals' info='Wrapper for the malloc() function used in the XML library'/>
    <functype name='xmlMallocFunc' file='xmlmemory'/>
    <function name='xmlMallocLoc' file='xmlmemory'>
      <info>a malloc() equivalent, with logging of the allocation info.</info>
      <return type='void *'/>
      <arg name='size' type='size_t'/>
      <arg name='file' type='const char *'/>
      <arg name='line' type='int'/>
    </function>
    <function name='xmlMemDisplay' file='xmlmemory'>
      <info>show in-extenso the memory blocks allocated</info>
      <return type='void'/>
      <arg name='fp' type='FILE *'/>
    </function>
    <function name='xmlMemGet' file='xmlmemory'>
      <info>Return the memory access functions set currently in use</info>
      <return type='int'/>
      <arg name='freeFunc' type='xmlFreeFunc *'/>
      <arg name='mallocFunc' type='xmlMallocFunc *'/>
      <arg name='reallocFunc' type='xmlReallocFunc *'/>
      <arg name='strdupFunc' type='xmlStrdupFunc *'/>
    </function>
    <function name='xmlMemSetup' file='xmlmemory'>
      <info>Override the default memory access functions with a new set This has to be called before any other libxml routines ! </info>
      <return type='int'/>
      <arg name='freeFunc' type='xmlFreeFunc'/>
      <arg name='mallocFunc' type='xmlMallocFunc'/>
      <arg name='reallocFunc' type='xmlReallocFunc'/>
      <arg name='strdupFunc' type='xmlStrdupFunc'/>
    </function>
    <function name='xmlMemShow' file='xmlmemory'>
      <info>show a show display of the memory allocated, and dump the nr last allocated areas which were not freed</info>
      <return type='void'/>
      <arg name='fp' type='FILE *'/>
      <arg name='nr' type='int'/>
    </function>
    <macro name='xmlMemStrdup' file='globals' info='Wrapper for the strdup() function, xmlStrdup() is usually preferred'/>
    <function name='xmlMemStrdupLoc' file='xmlmemory'>
      <info>a strdup() equivalent, with logging of the allocation info.</info>
      <return type='char *'/>
      <arg name='str' type='const char *'/>
      <arg name='file' type='const char *'/>
      <arg name='line' type='int'/>
    </function>
    <function name='xmlMemUsed' file='xmlmemory'>
      <info>returns the amount of memory currently allocated</info>
      <return type='int'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlMemoryDump' file='xmlmemory'>
      <info>Dump in-extenso the memory blocks allocated to the file .memorylist</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <struct name='xmlMutex' file='threads'/>
    <function name='xmlMutexLock' file='threads'>
      <info>xmlMutexLock() is used to lock a libxml2 token.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr'/>
    </function>
    <typedef name='xmlMutexPtr' file='threads' info='xmlNewMutex() is used to allocate a libxml2 token struct for use in synchronizing access to data.'/>
    <function name='xmlMutexUnlock' file='threads'>
      <info>xmlMutexUnlock() is used to unlock a libxml2 token.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr'/>
    </function>
    <function name='xmlNamespaceParseNCName' file='parserInternals'>
      <info>parse an XML namespace name. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlNamespaceParseNSDef' file='parserInternals'>
      <info>parse a namespace prefix declaration </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlNamespaceParseQName' file='parserInternals'>
      <info>TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='prefix' type='xmlChar **'/>
    </function>
    <function name='xmlNanoFTPCheckResponse' file='nanoftp'>
      <info>Check if there is a response from the FTP server after a command.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPCleanup' file='nanoftp'>
      <info>Cleanup the FTP protocol layer. This cleanup proxy informations.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlNanoFTPClose' file='nanoftp'>
      <info>Close the connection and both control and transport</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPCloseConnection' file='nanoftp'>
      <info>Close the data connection from the server</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPConnect' file='nanoftp'>
      <info>Tries to open a control connection</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPConnectTo' file='nanoftp'>
      <info>Tries to open a control connection to the given server/port</info>
      <return type='void *'/>
      <arg name='server' type='const char *'/>
      <arg name='port' type='int'/>
    </function>
    <function name='xmlNanoFTPCwd' file='nanoftp'>
      <info>Tries to change the remote directory</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='directory' type='char *'/>
    </function>
    <function name='xmlNanoFTPFreeCtxt' file='nanoftp'>
      <info>Frees the context after closing the connection.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPGet' file='nanoftp'>
      <info>Fetch the given file from the server. All data are passed back in the callbacks. The last callback has a size of 0 block.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='callback' type='ftpDataCallback'/>
      <arg name='userData' type='void *'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlNanoFTPGetConnection' file='nanoftp'>
      <info>Try to open a data connection to the server. Currently only passive mode is supported.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPGetResponse' file='nanoftp'>
      <info>Get the response from the FTP server after a command.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPGetSocket' file='nanoftp'>
      <info>Initiate fetch of the given file from the server.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlNanoFTPInit' file='nanoftp'>
      <info>Initialize the FTP protocol layer. Currently it just checks for proxy informations, and get the hostname</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlNanoFTPList' file='nanoftp'>
      <info>Do a listing on the server. All files info are passed back in the callbacks.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='callback' type='ftpListCallback'/>
      <arg name='userData' type='void *'/>
      <arg name='filename' type='char *'/>
    </function>
    <function name='xmlNanoFTPNewCtxt' file='nanoftp'>
      <info>Allocate and initialize a new FTP context.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *'/>
    </function>
    <function name='xmlNanoFTPOpen' file='nanoftp'>
      <info>Start to fetch the given ftp:// resource</info>
      <return type='void *'/>
      <arg name='URL' type='const char *'/>
    </function>
    <function name='xmlNanoFTPProxy' file='nanoftp'>
      <info>Setup the FTP proxy informations. This can also be done by using ftp_proxy ftp_proxy_user and ftp_proxy_password environment variables.</info>
      <return type='void'/>
      <arg name='host' type='const char *'/>
      <arg name='port' type='int'/>
      <arg name='user' type='const char *'/>
      <arg name='passwd' type='const char *'/>
      <arg name='type' type='int'/>
    </function>
    <function name='xmlNanoFTPQuit' file='nanoftp'>
      <info>Send a QUIT command to the server</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoFTPRead' file='nanoftp'>
      <info>This function tries to read len bytes from the existing FTP connection and saves them in dest. This is a blocking call.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='dest' type='void *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlNanoFTPScanProxy' file='nanoftp'>
      <info>(Re)Initialize the FTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like ftp://myproxy/ or ftp://myproxy:3128/ A NULL URL cleans up proxy informations.</info>
      <return type='void'/>
      <arg name='URL' type='const char *'/>
    </function>
    <function name='xmlNanoFTPUpdateURL' file='nanoftp'>
      <info>Update an FTP context by parsing the URL and finding new path it indicates. If there is an error in the protocol, hostname, port or other information, the error is raised. It indicates a new connection has to be established.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='URL' type='const char *'/>
    </function>
    <function name='xmlNanoHTTPAuthHeader' file='nanohttp'>
      <info>Get the authentication header of an HTTP context</info>
      <return type='const char *'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoHTTPCleanup' file='nanohttp'>
      <info>Cleanup the HTTP protocol layer.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlNanoHTTPClose' file='nanohttp'>
      <info>This function closes an HTTP context, it ends up the connection and free all data related to it.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoHTTPFetch' file='nanohttp'>
      <info>This function try to fetch the indicated resource via HTTP GET and save it's content in the file.</info>
      <return type='int'/>
      <arg name='URL' type='const char *'/>
      <arg name='filename' type='const char *'/>
      <arg name='contentType' type='char **'/>
    </function>
    <function name='xmlNanoHTTPInit' file='nanohttp'>
      <info>Initialize the HTTP protocol layer. Currently it just checks for proxy informations</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlNanoHTTPMethod' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP using the given method, adding the given extra headers and the input buffer for the request content.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *'/>
      <arg name='method' type='const char *'/>
      <arg name='input' type='const char *'/>
      <arg name='contentType' type='char **'/>
      <arg name='headers' type='const char *'/>
      <arg name='ilen' type='int'/>
    </function>
    <function name='xmlNanoHTTPMethodRedir' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP using the given method, adding the given extra headers and the input buffer for the request content.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *'/>
      <arg name='method' type='const char *'/>
      <arg name='input' type='const char *'/>
      <arg name='contentType' type='char **'/>
      <arg name='redir' type='char **'/>
      <arg name='headers' type='const char *'/>
      <arg name='ilen' type='int'/>
    </function>
    <function name='xmlNanoHTTPOpen' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP GET.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *'/>
      <arg name='contentType' type='char **'/>
    </function>
    <function name='xmlNanoHTTPOpenRedir' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP GET.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *'/>
      <arg name='contentType' type='char **'/>
      <arg name='redir' type='char **'/>
    </function>
    <function name='xmlNanoHTTPRead' file='nanohttp'>
      <info>This function tries to read len bytes from the existing HTTP connection and saves them in dest. This is a blocking call.</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
      <arg name='dest' type='void *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlNanoHTTPReturnCode' file='nanohttp'>
      <info>Get the latest HTTP return code received</info>
      <return type='int'/>
      <arg name='ctx' type='void *'/>
    </function>
    <function name='xmlNanoHTTPSave' file='nanohttp'>
      <info>This function saves the output of the HTTP transaction to a file It closes and free the context at the end</info>
      <return type='int'/>
      <arg name='ctxt' type='void *'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlNanoHTTPScanProxy' file='nanohttp'>
      <info>(Re)Initialize the HTTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like http://myproxy/ or http://myproxy:3128/ A NULL URL cleans up proxy informations.</info>
      <return type='void'/>
      <arg name='URL' type='const char *'/>
    </function>
    <function name='xmlNewCDataBlock' file='tree'>
      <info>Creation of a new node containing a CDATA block.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='content' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlNewCatalog' file='catalog'>
      <info>create a new Catalog.</info>
      <return type='xmlCatalogPtr'/>
      <arg name='sgml' type='int'/>
    </function>
    <function name='xmlNewCharRef' file='tree'>
      <info>Creation of a new character reference node.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlNewChild' file='tree'>
      <info>Creation of a new child element, added at the end of parent children list. ns and content parameters are optional (NULL). If content is non NULL, a child list containing the TEXTs and ENTITY_REFs node will be created. NOTE: content is supposed to be a piece of XML CDATA, so it allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewTextChild() if entities support is not needed.</info>
      <return type='xmlNodePtr'/>
      <arg name='parent' type='xmlNodePtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewComment' file='tree'>
      <info>Creation of a new node containing a comment.</info>
      <return type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewDoc' file='tree'>
      <info>Creates a new XML document</info>
      <return type='xmlDocPtr'/>
      <arg name='version' type='const xmlChar *'/>
    </function>
    <function name='xmlNewDocComment' file='tree'>
      <info>Creation of a new node containing a comment within a document.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewDocFragment' file='tree'>
      <info>Creation of a new Fragment node.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlNewDocNode' file='tree'>
      <info>Creation of a new node element within a document. ns and content are optional (NULL). NOTE: content is supposed to be a piece of XML CDATA, so it allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewDocRawNode() if you don't need entities support.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewDocProp' file='tree'>
      <info>Create a new property carried by a document.</info>
      <return type='xmlAttrPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlNewDocRawNode' file='tree'>
      <info>Creation of a new node element within a document. ns and content are optional (NULL).</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewDocText' file='tree'>
      <info>Creation of a new text node within a document.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewDocTextLen' file='tree'>
      <info>Creation of a new text node with an extra content length parameter. The text node pertain to a given document.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='content' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlNewDtd' file='tree'>
      <info>Creation of a new DTD for the external subset. To create an internal subset, use xmlCreateIntSubset().</info>
      <return type='xmlDtdPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <function name='xmlNewElementContent' file='valid'>
      <info>Allocate an element content structure.</info>
      <return type='xmlElementContentPtr'/>
      <arg name='name' type='xmlChar *'/>
      <arg name='type' type='xmlElementContentType'/>
    </function>
    <function name='xmlNewEntityInputStream' file='parserInternals'>
      <info>Create a new input stream based on an xmlEntityPtr</info>
      <return type='xmlParserInputPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='entity' type='xmlEntityPtr'/>
    </function>
    <function name='xmlNewGlobalNs' file='tree'>
      <info>Creation of a Namespace, the old way using PI and without scoping DEPRECATED !!! It now create a namespace on the root element of the document if found.</info>
      <return type='xmlNsPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='href' type='const xmlChar *'/>
      <arg name='prefix' type='const xmlChar *'/>
    </function>
    <function name='xmlNewIOInputStream' file='parser'>
      <info>Create a new input stream structure encapsulating the input into a stream suitable for the parser.</info>
      <return type='xmlParserInputPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='input' type='xmlParserInputBufferPtr'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlNewInputFromFile' file='parserInternals'>
      <info>Create a new input stream based on a file.</info>
      <return type='xmlParserInputPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlNewInputStream' file='parserInternals'>
      <info>Create a new input stream structure</info>
      <return type='xmlParserInputPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlNewMutex' file='threads'>
      <return type='xmlMutexPtr'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlNewNode' file='tree'>
      <info>Creation of a new node element. ns is optional (NULL).</info>
      <return type='xmlNodePtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlNewNs' file='tree'>
      <info>Creation of a new Namespace. This function will refuse to create a namespace with a similar prefix than an existing one present on this node. We use href==NULL in the case of an element creation where the namespace was not defined.</info>
      <return type='xmlNsPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='href' type='const xmlChar *'/>
      <arg name='prefix' type='const xmlChar *'/>
    </function>
    <function name='xmlNewNsProp' file='tree'>
      <info>Create a new property tagged with a namespace and carried by a node.</info>
      <return type='xmlAttrPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlNewPI' file='tree'>
      <info>Creation of a processing instruction element.</info>
      <return type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewParserCtxt' file='parserInternals'>
      <info>Allocate and initialize a new parser context.</info>
      <return type='xmlParserCtxtPtr'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlNewProp' file='tree'>
      <info>Create a new property carried by a node.</info>
      <return type='xmlAttrPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlNewRMutex' file='threads'>
      <return type='xmlRMutexPtr'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlNewReference' file='tree'>
      <info>Creation of a new reference node.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlNewStringInputStream' file='parserInternals'>
      <info>Create a new input stream based on a memory buffer.</info>
      <return type='xmlParserInputPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='buffer' type='const xmlChar *'/>
    </function>
    <function name='xmlNewText' file='tree'>
      <info>Creation of a new text node.</info>
      <return type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewTextChild' file='tree'>
      <info>Creation of a new child element, added at the end of parent children list. ns and content parameters are optional (NULL). If content is non NULL, a child TEXT node will be created containing the string content.</info>
      <return type='xmlNodePtr'/>
      <arg name='parent' type='xmlNodePtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNewTextLen' file='tree'>
      <info>Creation of a new text node with an extra parameter for the content's length</info>
      <return type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlNextChar' file='parserInternals'>
      <info>Skip to the next char input char.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlNoNetExternalEntityLoader' file='xmlIO'>
      <info>A specific entity loader disabling network accesses, though still allowing local catalog accesses for resolution.</info>
      <return type='xmlParserInputPtr'/>
      <arg name='URL' type='const char *'/>
      <arg name='ID' type='const char *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <struct name='xmlNode' file='tree' info='A node in an XML tree.'/>
    <function name='xmlNodeAddContent' file='tree'>
      <info>Append the extra substring to the node content.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNodeAddContentLen' file='tree'>
      <info>Append the extra substring to the node content.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlNodeDump' file='tree'>
      <info>Dump an XML node, recursive behaviour,children are printed too.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='level' type='int'/>
      <arg name='format' type='int'/>
    </function>
    <function name='xmlNodeDumpOutput' file='tree'>
      <info>Dump an XML node, recursive behaviour, children are printed too.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='level' type='int'/>
      <arg name='format' type='int'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='xmlNodeGetBase' file='tree'>
      <info>Searches for the BASE URL. The code should work on both XML and HTML document even if base mechanisms are completely different. It returns the base as defined in RFC 2396 sections 5.1.1. Base URI within Document Content and 5.1.2. Base URI from the Encapsulating Entity However it does not return the document base (5.1.3), use xmlDocumentGetBase() for this</info>
      <return type='xmlChar *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlNodeGetContent' file='tree'>
      <info>Read the value of a node, this can be either the text carried directly by this node if it's a TEXT node or the aggregate string of the values carried by this node child's (TEXT and ENTITY_REF). Entity references are substituted.</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlNodeGetLang' file='tree'>
      <info>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlNodeGetSpacePreserve' file='tree'>
      <info>Searches the space preserving behaviour of a node, i.e. the values of the xml:space attribute or the one carried by the nearest ancestor.</info>
      <return type='int'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlNodeIsText' file='tree'>
      <info>Is this node a Text node ?</info>
      <return type='int'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlNodeListGetRawString' file='tree'>
      <info>Returns the string equivalent to the text contained in the Node list made of TEXTs and ENTITY_REFs, contrary to xmlNodeListGetString() this function doesn't do any character encoding handling.</info>
      <return type='xmlChar *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='list' type='xmlNodePtr'/>
      <arg name='inLine' type='int'/>
    </function>
    <function name='xmlNodeListGetString' file='tree'>
      <info>Returns the string equivalent to the text contained in the Node list made of TEXTs and ENTITY_REFs</info>
      <return type='xmlChar *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='list' type='xmlNodePtr'/>
      <arg name='inLine' type='int'/>
    </function>
    <typedef name='xmlNodePtr' file='tree'/>
    <struct name='xmlNodeSet' file='xpath'/>
    <function name='xmlNodeSetBase' file='tree'>
      <info>Set (or reset) the base URI of a node, i.e. the value of the xml:base attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='uri' type='xmlChar *'/>
    </function>
    <function name='xmlNodeSetContent' file='tree'>
      <info>Replace the content of a node.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
    </function>
    <function name='xmlNodeSetContentLen' file='tree'>
      <info>Replace the content of a node.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlNodeSetLang' file='tree'>
      <info>Set the language of a node, i.e. the values of the xml:lang attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='lang' type='const xmlChar *'/>
    </function>
    <function name='xmlNodeSetName' file='tree'>
      <info>Set (or reset) the name of a node.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <typedef name='xmlNodeSetPtr' file='xpath'/>
    <function name='xmlNodeSetSpacePreserve' file='tree'>
      <info>Set (or reset) the space preserving behaviour of a node, i.e. the value of the xml:space attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlNormalizeURIPath' file='uri'>
      <info>Applies the 5 normalization steps to a path string--that is, RFC 2396 Section 5.2, steps 6.c through 6.g. </info>
      <return type='int'/>
      <arg name='path' type='char *'/>
    </function>
    <struct name='xmlNotation' file='tree' info='a DTD Notation definition'/>
    <typedef name='xmlNotationPtr' file='tree'/>
    <typedef name='xmlNotationTablePtr' file='valid'/>
    <struct name='xmlNs' file='tree' info='An XML namespace. Note that prefix == NULL is valid, it defines the default namespace within the subtree (until overridden). '/>
    <typedef name='xmlNsPtr' file='tree'/>
    <typedef name='xmlNsType' file='tree'/>
    <struct name='xmlOutputBuffer' file='xmlIO'/>
    <function name='xmlOutputBufferClose' file='xmlIO'>
      <info>flushes and close the output I/O channel and free up all the associated resources</info>
      <return type='int'/>
      <arg name='out' type='xmlOutputBufferPtr'/>
    </function>
    <function name='xmlOutputBufferCreateFd' file='xmlIO'>
      <info>Create a buffered output for the progressive saving to a file descriptor</info>
      <return type='xmlOutputBufferPtr'/>
      <arg name='fd' type='int'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr'/>
    </function>
    <function name='xmlOutputBufferCreateFile' file='xmlIO'>
      <info>Create a buffered output for the progressive saving to a FILE * buffered C I/O</info>
      <return type='xmlOutputBufferPtr'/>
      <arg name='file' type='FILE *'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr'/>
    </function>
    <function name='xmlOutputBufferCreateFilename' file='xmlIO'>
      <info>Create a buffered output for the progressive saving of a file If filename is "-' then we use stdout as the output. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. TODO: currently if compression is set, the library only support writing to a local file.</info>
      <return type='xmlOutputBufferPtr'/>
      <arg name='URI' type='const char *'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr'/>
      <arg name='compression' type='int'/>
    </function>
    <function name='xmlOutputBufferCreateIO' file='xmlIO'>
      <info>Create a buffered output for the progressive saving to an I/O handler</info>
      <return type='xmlOutputBufferPtr'/>
      <arg name='iowrite' type='xmlOutputWriteCallback'/>
      <arg name='ioclose' type='xmlOutputCloseCallback'/>
      <arg name='ioctx' type='void *'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr'/>
    </function>
    <function name='xmlOutputBufferFlush' file='xmlIO'>
      <info>flushes the output I/O channel</info>
      <return type='int'/>
      <arg name='out' type='xmlOutputBufferPtr'/>
    </function>
    <typedef name='xmlOutputBufferPtr' file='tree'/>
    <function name='xmlOutputBufferWrite' file='xmlIO'>
      <info>Write the content of the array in the output I/O buffer This routine handle the I18N transcoding from internal UTF-8 The buffer is lossless, i.e. will store in case of partial or delayed writes.</info>
      <return type='int'/>
      <arg name='out' type='xmlOutputBufferPtr'/>
      <arg name='len' type='int'/>
      <arg name='buf' type='const char *'/>
    </function>
    <function name='xmlOutputBufferWriteString' file='xmlIO'>
      <info>Write the content of the string in the output I/O buffer This routine handle the I18N transcoding from internal UTF-8 The buffer is lossless, i.e. will store in case of partial or delayed writes.</info>
      <return type='int'/>
      <arg name='out' type='xmlOutputBufferPtr'/>
      <arg name='str' type='const char *'/>
    </function>
    <functype name='xmlOutputCloseCallback' file='xmlIO'/>
    <functype name='xmlOutputMatchCallback' file='xmlIO'/>
    <functype name='xmlOutputOpenCallback' file='xmlIO'/>
    <functype name='xmlOutputWriteCallback' file='xmlIO'/>
    <function name='xmlParseAttValue' file='parserInternals'>
      <info>parse a value for an attribute Note: the parser won't do substitution of entities here, this will be handled later in xmlStringGetNodeList </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseAttribute' file='parserInternals'>
      <info>parse an attribute </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='value' type='xmlChar **'/>
    </function>
    <function name='xmlParseAttributeListDecl' file='parserInternals'>
      <info>: parse the Attribute list def for an element </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseAttributeType' file='parserInternals'>
      <info>parse the Attribute list def for an element </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='tree' type='xmlEnumerationPtr *'/>
    </function>
    <function name='xmlParseBalancedChunkMemory' file='parser'>
      <info>Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: </info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='depth' type='int'/>
      <arg name='string' type='const xmlChar *'/>
      <arg name='lst' type='xmlNodePtr *'/>
    </function>
    <function name='xmlParseCDSect' file='parserInternals'>
      <info>Parse escaped pure raw content. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseCatalogFile' file='catalog'>
      <info>parse an XML file and build a tree. It's like xmlParseFile() except it bypass all catalog lookups.</info>
      <return type='xmlDocPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlParseCharData' file='parserInternals'>
      <info>parse a CharData section. if we are within a CDATA section ']]&gt;' marks an end of section. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='cdata' type='int'/>
    </function>
    <function name='xmlParseCharEncoding' file='encoding'>
      <info>Compare the string to the known encoding schemes already known. Note that the comparison is case insensitive accordingly to the section [XML] 4.3.3 Character Encoding in Entities.</info>
      <return type='xmlCharEncoding'/>
      <arg name='name' type='const char *'/>
    </function>
    <function name='xmlParseCharRef' file='parserInternals'>
      <info>parse Reference declarations </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseChunk' file='parser'>
      <info>Parse a Chunk of memory</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='chunk' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='terminate' type='int'/>
    </function>
    <function name='xmlParseComment' file='parserInternals'>
      <info>Skip an XML (SGML) comment &lt;!-- .... --&gt; The spec says that "For compatibility, the string "--" (double-hyphen) must not occur within comments. " </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseContent' file='parserInternals'>
      <info>Parse a content: </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseCtxtExternalEntity' file='parser'>
      <info>Parse an external general entity within an existing parsing context An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. </info>
      <return type='int'/>
      <arg name='ctx' type='xmlParserCtxtPtr'/>
      <arg name='URL' type='const xmlChar *'/>
      <arg name='ID' type='const xmlChar *'/>
      <arg name='lst' type='xmlNodePtr *'/>
    </function>
    <function name='xmlParseDTD' file='parser'>
      <info>Load and parse an external subset.</info>
      <return type='xmlDtdPtr'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <function name='xmlParseDefaultDecl' file='parserInternals'>
      <info>Parse an attribute default declaration </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='value' type='xmlChar **'/>
    </function>
    <function name='xmlParseDoc' file='parser'>
      <info>parse an XML in-memory document and build a tree.</info>
      <return type='xmlDocPtr'/>
      <arg name='cur' type='xmlChar *'/>
    </function>
    <function name='xmlParseDocTypeDecl' file='parserInternals'>
      <info>parse a DOCTYPE declaration </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseDocument' file='parser'>
      <info>parse an XML document (and build a tree if using the standard SAX interface). </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseElement' file='parserInternals'>
      <info>parse an XML element, this is highly recursive </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseElementChildrenContentD' file='parserInternals'>
      <info>VMS version of xmlParseElementChildrenContentDecl()</info>
      <return type='xmlElementContentPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseElementChildrenContentDecl' file='parserInternals'>
      <info>parse the declaration for a Mixed Element content The leading '(' and spaces have been skipped in xmlParseElementContentDecl </info>
      <return type='xmlElementContentPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseElementContentDecl' file='parserInternals'>
      <info>parse the declaration for an Element content either Mixed or Children, the cases EMPTY and ANY are handled directly in xmlParseElementDecl </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='name' type='xmlChar *'/>
      <arg name='result' type='xmlElementContentPtr *'/>
    </function>
    <function name='xmlParseElementDecl' file='parserInternals'>
      <info>parse an Element declaration. </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseElementMixedContentDecl' file='parserInternals'>
      <info>parse the declaration for a Mixed Element content The leading '(' and spaces have been skipped in xmlParseElementContentDecl </info>
      <return type='xmlElementContentPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseEncName' file='parserInternals'>
      <info>parse the XML encoding name </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseEncodingDecl' file='parserInternals'>
      <info>parse the XML encoding declaration </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseEndTag' file='parserInternals'>
      <info>parse an end of tag </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseEntity' file='parser'>
      <info>parse an XML external entity out of context and build a tree. </info>
      <return type='xmlDocPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlParseEntityDecl' file='parserInternals'>
      <info>parse &lt;!ENTITY declarations </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseEntityRef' file='parserInternals'>
      <info>parse ENTITY references declarations </info>
      <return type='xmlEntityPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseEntityValue' file='parserInternals'>
      <info>parse a value for ENTITY declarations </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='orig' type='xmlChar **'/>
    </function>
    <function name='xmlParseEnumeratedType' file='parserInternals'>
      <info>parse an Enumerated attribute type. </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='tree' type='xmlEnumerationPtr *'/>
    </function>
    <function name='xmlParseEnumerationType' file='parserInternals'>
      <info>parse an Enumeration attribute type. </info>
      <return type='xmlEnumerationPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseExtParsedEnt' file='parser'>
      <info>parse a general parsed entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseExternalEntity' file='parser'>
      <info>Parse an external general entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. </info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='depth' type='int'/>
      <arg name='URL' type='const xmlChar *'/>
      <arg name='ID' type='const xmlChar *'/>
      <arg name='lst' type='xmlNodePtr *'/>
    </function>
    <function name='xmlParseExternalID' file='parserInternals'>
      <info>Parse an External ID or a Public ID </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='publicID' type='xmlChar **'/>
      <arg name='strict' type='int'/>
    </function>
    <function name='xmlParseExternalSubset' file='parserInternals'>
      <info>parse Markup declarations from an external subset </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <function name='xmlParseFile' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlDocPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlParseMarkupDecl' file='parserInternals'>
      <info>parse Markup declarations </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseMemory' file='parser'>
      <info>parse an XML in-memory block and build a tree.</info>
      <return type='xmlDocPtr'/>
      <arg name='buffer' type='const char *'/>
      <arg name='size' type='int'/>
    </function>
    <function name='xmlParseMisc' file='parserInternals'>
      <info>parse an XML Misc* optional field. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseName' file='parserInternals'>
      <info>parse an XML name. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseNamespace' file='parserInternals'>
      <info>xmlParseNamespace: parse specific PI '&lt;?namespace ...' constructs. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseNmtoken' file='parserInternals'>
      <info>parse an XML Nmtoken. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseNotationDecl' file='parserInternals'>
      <info>parse a notation declaration </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseNotationType' file='parserInternals'>
      <info>parse an Notation attribute type. </info>
      <return type='xmlEnumerationPtr'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParsePEReference' file='parserInternals'>
      <info>parse PEReference declarations The entity content is handled directly by pushing it's content as a new input stream. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParsePI' file='parserInternals'>
      <info>parse an XML Processing Instruction. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParsePITarget' file='parserInternals'>
      <info>parse the name of a PI </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParsePubidLiteral' file='parserInternals'>
      <info>parse an XML public literal </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseQuotedString' file='parserInternals'>
      <info>Parse and return a string between quotes or doublequotes </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseReference' file='parserInternals'>
      <info>parse and handle entity references in content, depending on the SAX interface, this may end-up in a call to character() if this is a CharRef, a predefined entity, if there is no reference() callback. or if the parser was asked to switch to that mode. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseSDDecl' file='parserInternals'>
      <info>parse the XML standalone declaration </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseStartTag' file='parserInternals'>
      <info>parse a start of tag either for rule element or EmptyElement. In both case we don't parse the tag closing chars. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseSystemLiteral' file='parserInternals'>
      <info>parse an XML Literal </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseTextDecl' file='parserInternals'>
      <info>parse an XML declaration header for external entities </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseURI' file='uri'>
      <info>Parse an URI </info>
      <return type='xmlURIPtr'/>
      <arg name='str' type='const char *'/>
    </function>
    <function name='xmlParseURIReference' file='uri'>
      <info>Parse an URI reference string and fills in the appropriate fields of the uri structure </info>
      <return type='int'/>
      <arg name='uri' type='xmlURIPtr'/>
      <arg name='str' type='const char *'/>
    </function>
    <function name='xmlParseVersionInfo' file='parserInternals'>
      <info>parse the XML version. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseVersionNum' file='parserInternals'>
      <info>parse the XML version value. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParseXMLDecl' file='parserInternals'>
      <info>parse an XML declaration header </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParserAddNodeInfo' file='parser'>
      <info>Insert node info record into the sorted sequence</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='info' type='const xmlParserNodeInfoPtr'/>
    </function>
    <struct name='xmlParserCtxt' file='tree' info='The parser context. NOTE This doesn't completely defines the parser state, the (current ?) design of the parser uses recursive function calls since this allow and easy mapping from the production rules of the specification to the actual code. The drawback is that the actual function call also reflect the parser state. However most of the parsing routines takes as the only argument the parser context pointer, so migrating to a state based parser for progressive parsing shouldn't be too hard.'/>
    <typedef name='xmlParserCtxtPtr' file='tree'/>
    <macro name='xmlParserDebugEntities' file='globals'/>
    <function name='xmlParserError' file='xmlerror'>
      <info>Display and format an error messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='msg' type='const char *'/>
      <arg name='' type='...'/>
    </function>
    <enum name='xmlParserErrors' file='xmlerror'/>
    <function name='xmlParserFindNodeInfo' file='parser'>
      <info>Find the parser node info struct for a given node</info>
      <return type='const xmlParserNodeInfo *'/>
      <arg name='ctxt' type='const xmlParserCtxtPtr'/>
      <arg name='node' type='const xmlNodePtr'/>
    </function>
    <function name='xmlParserFindNodeInfoIndex' file='parser'>
      <info>xmlParserFindNodeInfoIndex : Find the index that the info record for the given node is or should be at in a sorted sequence</info>
      <return type='unsigned long'/>
      <arg name='seq' type='const xmlParserNodeInfoSeqPtr'/>
      <arg name='node' type='const xmlNodePtr'/>
    </function>
    <function name='xmlParserGetDirectory' file='xmlIO'>
      <info>lookup the directory for that file</info>
      <return type='char *'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlParserHandlePEReference' file='parserInternals'>
      <info>[69] PEReference ::= '%' Name ';' </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlParserHandleReference' file='parserInternals'>
      <info>TODO: Remove, now deprecated ... the test is done directly in the content parsing routines. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <struct name='xmlParserInput' file='tree' info='an xmlParserInput is an input flow for the XML processor. Each entity parsed is associated an xmlParserInput (except the few predefined ones). This is the case both for internal entities - in which case the flow is already completely in memory - or external entities - in which case we use the buf structure for progressive reading and I18N conversions to the internal UTF-8 format.'/>
    <struct name='xmlParserInputBuffer' file='xmlIO'/>
    <function name='xmlParserInputBufferCreateFd' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from a file descriptor</info>
      <return type='xmlParserInputBufferPtr'/>
      <arg name='fd' type='int'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlParserInputBufferCreateFile' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing of a FILE * buffered C I/O</info>
      <return type='xmlParserInputBufferPtr'/>
      <arg name='file' type='FILE *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlParserInputBufferCreateFilename' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing of a file If filename is "-' then we use stdin as the input. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Do an encoding check if enc == XML_CHAR_ENCODING_NONE</info>
      <return type='xmlParserInputBufferPtr'/>
      <arg name='URI' type='const char *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlParserInputBufferCreateFname' file='xmlIO'>
      <info>VMS version of xmlParserInputBufferCreateFilename()</info>
      <return type='xmlParserInputBufferPtr'/>
      <arg name='URI' type='const char *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlParserInputBufferCreateIO' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from an I/O handler</info>
      <return type='xmlParserInputBufferPtr'/>
      <arg name='ioread' type='xmlInputReadCallback'/>
      <arg name='ioclose' type='xmlInputCloseCallback'/>
      <arg name='ioctx' type='void *'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlParserInputBufferCreateMem' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from a memory area.</info>
      <return type='xmlParserInputBufferPtr'/>
      <arg name='mem' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlParserInputBufferGrow' file='xmlIO'>
      <info>Grow up the content of the input buffer, the old data are preserved This routine handle the I18N transcoding to internal UTF-8 This routine is used when operating the parser in normal (pull) mode </info>
      <return type='int'/>
      <arg name='in' type='xmlParserInputBufferPtr'/>
      <arg name='len' type='int'/>
    </function>
    <typedef name='xmlParserInputBufferPtr' file='tree'/>
    <function name='xmlParserInputBufferPush' file='xmlIO'>
      <info>Push the content of the arry in the input buffer This routine handle the I18N transcoding to internal UTF-8 This is used when operating the parser in progressive (push) mode.</info>
      <return type='int'/>
      <arg name='in' type='xmlParserInputBufferPtr'/>
      <arg name='len' type='int'/>
      <arg name='buf' type='const char *'/>
    </function>
    <function name='xmlParserInputBufferRead' file='xmlIO'>
      <info>Refresh the content of the input buffer, the old data are considered consumed This routine handle the I18N transcoding to internal UTF-8</info>
      <return type='int'/>
      <arg name='in' type='xmlParserInputBufferPtr'/>
      <arg name='len' type='int'/>
    </function>
    <functype name='xmlParserInputDeallocate' file='parser'/>
    <function name='xmlParserInputGrow' file='parser'>
      <info>This function increase the input for the parser. It tries to preserve pointers to the input buffer, and keep already read data</info>
      <return type='int'/>
      <arg name='in' type='xmlParserInputPtr'/>
      <arg name='len' type='int'/>
    </function>
    <typedef name='xmlParserInputPtr' file='tree'/>
    <function name='xmlParserInputRead' file='parser'>
      <info>This function refresh the input for the parser. It doesn't try to preserve pointers to the input buffer, and discard already read data</info>
      <return type='int'/>
      <arg name='in' type='xmlParserInputPtr'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlParserInputShrink' file='parserInternals'>
      <info>This function removes used input for the parser.</info>
      <return type='void'/>
      <arg name='in' type='xmlParserInputPtr'/>
    </function>
    <enum name='xmlParserInputState' file='parser'/>
    <struct name='xmlParserNodeInfo' file='parser' info='the parser can be asked to collect Node informations, i.e. at what place in the file they were detected. NOTE: This is off by default and not very well tested.'/>
    <typedef name='xmlParserNodeInfoPtr' file='parser'/>
    <struct name='xmlParserNodeInfoSeq' file='parser'/>
    <typedef name='xmlParserNodeInfoSeqPtr' file='parser'/>
    <function name='xmlParserPrintFileContext' file='xmlerror'>
      <info>Displays current context within the input content for error tracking</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr'/>
    </function>
    <function name='xmlParserPrintFileInfo' file='xmlerror'>
      <info>Displays the associated file and line informations for the current input</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr'/>
    </function>
    <function name='xmlParserValidityError' file='xmlerror'>
      <info>Display and format an validity error messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='msg' type='const char *'/>
      <arg name='' type='...'/>
    </function>
    <function name='xmlParserValidityWarning' file='xmlerror'>
      <info>Display and format a validity warning messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='msg' type='const char *'/>
      <arg name='' type='...'/>
    </function>
    <macro name='xmlParserVersion' file='globals'/>
    <function name='xmlParserWarning' file='xmlerror'>
      <info>Display and format a warning messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='msg' type='const char *'/>
      <arg name='' type='...'/>
    </function>
    <function name='xmlPedanticParserDefault' file='parser'>
      <info>Set and return the previous value for enabling pedantic warnings.</info>
      <return type='int'/>
      <arg name='val' type='int'/>
    </function>
    <macro name='xmlPedanticParserDefaultValue' file='globals'/>
    <function name='xmlPopInput' file='parserInternals'>
      <info>xmlPopInput: the current input pointed by ctxt-&gt;input came to an end pop it and return the next char.</info>
      <return type='xmlChar'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlPrintURI' file='uri'>
      <info>Prints the URI in the stream steam.</info>
      <return type='void'/>
      <arg name='stream' type='FILE *'/>
      <arg name='uri' type='xmlURIPtr'/>
    </function>
    <function name='xmlPushInput' file='parserInternals'>
      <info>xmlPushInput: switch to a new input stream which is stacked on top of the previous one(s).</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='input' type='xmlParserInputPtr'/>
    </function>
    <struct name='xmlRMutex' file='threads'/>
    <function name='xmlRMutexLock' file='threads'>
      <info>xmlRMutexLock() is used to lock a libxml2 token_r.</info>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr'/>
    </function>
    <typedef name='xmlRMutexPtr' file='threads'/>
    <function name='xmlRMutexUnlock' file='threads'>
      <info>xmlRMutexUnlock() is used to unlock a libxml2 token_r.</info>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr'/>
    </function>
    <macro name='xmlRealloc' file='globals' info='Wrapper for the realloc() function used in the XML library'/>
    <functype name='xmlReallocFunc' file='xmlmemory'/>
    <function name='xmlReallocLoc' file='xmlmemory'>
      <info>a realloc() equivalent, with logging of the allocation info.</info>
      <return type='void *'/>
      <arg name='ptr' type='void *'/>
      <arg name='size' type='size_t'/>
      <arg name='file' type='const char *'/>
      <arg name='line' type='int'/>
    </function>
    <function name='xmlReconciliateNs' file='tree'>
      <info>This function checks that all the namespaces declared within the given tree are properly declared. This is needed for example after Copy or Cut and then paste operations. The subtree may still hold pointers to namespace declarations outside the subtree or invalid/masked. As much as possible the function try to reuse the existing namespaces found in the new environment. If not possible the new namespaces are redeclared on tree at the top of the given subtree.</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='tree' type='xmlNodePtr'/>
    </function>
    <function name='xmlRecoverDoc' file='parser'>
      <info>parse an XML in-memory document and build a tree. In the case the document is not Well Formed, a tree is built anyway</info>
      <return type='xmlDocPtr'/>
      <arg name='cur' type='xmlChar *'/>
    </function>
    <function name='xmlRecoverFile' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. In the case the document is not Well Formed, a tree is built anyway</info>
      <return type='xmlDocPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlRecoverMemory' file='parser'>
      <info>parse an XML in-memory block and build a tree. In the case the document is not Well Formed, a tree is built anyway</info>
      <return type='xmlDocPtr'/>
      <arg name='buffer' type='const char *'/>
      <arg name='size' type='int'/>
    </function>
    <struct name='xmlRef' file='tree' info='An XML IDREF instance.'/>
    <typedef name='xmlRefPtr' file='tree'/>
    <typedef name='xmlRefTablePtr' file='valid'/>
    <function name='xmlRegisterCharEncodingHandler' file='encoding'>
      <info>Register the char encoding handler, surprising, isn't it ?</info>
      <return type='void'/>
      <arg name='handler' type='xmlCharEncodingHandlerPtr'/>
    </function>
    <function name='xmlRegisterDefaultInputCallbacks' file='xmlIO'>
      <info>Registers the default compiled-in I/O handlers.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlRegisterDefaultOutputCallbacks' file='xmlIO'>
      <info>Registers the default compiled-in I/O handlers.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlRegisterHTTPPostCallbacks' file='xmlIO'>
      <info>By default, libxml submits HTTP output requests using the "PUT" method. Calling this method changes the HTTP output method to use the "POST" method instead.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlRegisterInputCallbacks' file='xmlIO'>
      <info>Register a new set of I/O callback for handling parser input.</info>
      <return type='int'/>
      <arg name='matchFunc' type='xmlInputMatchCallback'/>
      <arg name='openFunc' type='xmlInputOpenCallback'/>
      <arg name='readFunc' type='xmlInputReadCallback'/>
      <arg name='closeFunc' type='xmlInputCloseCallback'/>
    </function>
    <function name='xmlRegisterOutputCallbacks' file='xmlIO'>
      <info>Register a new set of I/O callback for handling output.</info>
      <return type='int'/>
      <arg name='matchFunc' type='xmlOutputMatchCallback'/>
      <arg name='openFunc' type='xmlOutputOpenCallback'/>
      <arg name='writeFunc' type='xmlOutputWriteCallback'/>
      <arg name='closeFunc' type='xmlOutputCloseCallback'/>
    </function>
    <function name='xmlRemoveID' file='valid'>
      <info>Remove the given attribute from the ID table maintained internally.</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='attr' type='xmlAttrPtr'/>
    </function>
    <function name='xmlRemoveProp' file='tree'>
      <info>Unlink and free one attribute, all the content is freed too Note this doesn't work for namespace definition attributes</info>
      <return type='int'/>
      <arg name='cur' type='xmlAttrPtr'/>
    </function>
    <function name='xmlRemoveRef' file='valid'>
      <info>Remove the given attribute from the Ref table maintained internally.</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='attr' type='xmlAttrPtr'/>
    </function>
    <function name='xmlReplaceNode' file='tree'>
      <info>Unlink the old node from it's current context, prune the new one at the same place. If cur was already inserted in a document it is first unlinked from its existing context.</info>
      <return type='xmlNodePtr'/>
      <arg name='old' type='xmlNodePtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <macro name='xmlRootNode' file='tree' info='Macro for compatibility naming layer with libxml1'/>
    <struct name='xmlSAXHandler' file='parser' info='a SAX handler is bunch of callbacks called by the parser when processing of the input generate data or structure informations.'/>
    <typedef name='xmlSAXHandlerPtr' file='parser'/>
    <struct name='xmlSAXLocator' file='parser' info='a SAX Locator.'/>
    <typedef name='xmlSAXLocatorPtr' file='parser'/>
    <function name='xmlSAXParseDTD' file='parser'>
      <info>Load and parse an external subset.</info>
      <return type='xmlDtdPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='ExternalID' type='const xmlChar *'/>
      <arg name='SystemID' type='const xmlChar *'/>
    </function>
    <function name='xmlSAXParseDoc' file='parser'>
      <info>parse an XML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='cur' type='xmlChar *'/>
      <arg name='recovery' type='int'/>
    </function>
    <function name='xmlSAXParseEntity' file='parser'>
      <info>parse an XML external entity out of context and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. </info>
      <return type='xmlDocPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlSAXParseFile' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='recovery' type='int'/>
    </function>
    <function name='xmlSAXParseFileWithData' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. </info>
      <return type='xmlDocPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='filename' type='const char *'/>
      <arg name='recovery' type='int'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlSAXParseMemory' file='parser'>
      <info>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='buffer' type='const char *'/>
      <arg name='size' type='int'/>
      <arg name='recovery' type='int'/>
    </function>
    <function name='xmlSAXUserParseFile' file='parser'>
      <info>parse an XML file and call the given SAX handler routines. Automatic support for ZLIB/Compress compressed document is provided</info>
      <return type='int'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlSAXUserParseMemory' file='parser'>
      <info>A better SAX parsing routine. parse an XML in-memory buffer and call the given SAX handler routines.</info>
      <return type='int'/>
      <arg name='sax' type='xmlSAXHandlerPtr'/>
      <arg name='data' type='void *user_'/>
      <arg name='buffer' type='const char *'/>
      <arg name='size' type='int'/>
    </function>
    <function name='xmlSaveFile' file='tree'>
      <info>Dump an XML document to a file. Will use compression if compiled in and enabled. If filename is "-" the stdout file is used.</info>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='cur' type='xmlDocPtr'/>
    </function>
    <function name='xmlSaveFileEnc' file='tree'>
      <info>Dump an XML document, converting it to the given encoding</info>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='xmlSaveFileTo' file='tree'>
      <info>Dump an XML document to an I/O buffer.</info>
      <return type='int'/>
      <arg name='buf' type='xmlOutputBufferPtr'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
    </function>
    <function name='xmlSaveFormatFile' file='tree'>
      <info>Dump an XML document to a file. Will use compression if compiled in and enabled. If filename is "-" the stdout file is used. If format is set then the document will be indented on output.</info>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='format' type='int'/>
    </function>
    <function name='xmlSaveFormatFileEnc' file='tree'>
      <return type='int'/>
      <arg name='filename' type='const char *'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
      <arg name='format' type='int'/>
    </function>
    <function name='xmlSaveFormatFileTo' file='tree'>
      <info>Dump an XML document to an I/O buffer.</info>
      <return type='int'/>
      <arg name='buf' type='xmlOutputBufferPtr'/>
      <arg name='cur' type='xmlDocPtr'/>
      <arg name='encoding' type='const char *'/>
      <arg name='format' type='int'/>
    </function>
    <macro name='xmlSaveNoEmptyTags' file='globals'/>
    <function name='xmlSaveUri' file='uri'>
      <info>Save the URI as an escaped string</info>
      <return type='xmlChar *'/>
      <arg name='uri' type='xmlURIPtr'/>
    </function>
    <function name='xmlScanName' file='parserInternals'>
      <info>Trickery: parse an XML name but without consuming the input flow Needed for rollback cases. Used only when parsing entities references. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlSearchNs' file='tree'>
      <info>Search a Ns registered under a given name space for a document. recurse on the parents until it finds the defined namespace or return NULL otherwise. nameSpace can be NULL, this is a search for the default namespace. We don't allow to cross entities boundaries. If you don't declare the namespace within those you will be in troubles !!! A warning is generated to cover this case.</info>
      <return type='xmlNsPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='nameSpace' type='const xmlChar *'/>
    </function>
    <function name='xmlSearchNsByHref' file='tree'>
      <info>Search a Ns aliasing a given URI. Recurse on the parents until it finds the defined namespace or return NULL otherwise.</info>
      <return type='xmlNsPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='href' type='const xmlChar *'/>
    </function>
    <function name='xmlSetBufferAllocationScheme' file='tree'>
      <info>Set the buffer allocation method. Types are XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,  improves performance</info>
      <return type='void'/>
      <arg name='scheme' type='xmlBufferAllocationScheme'/>
    </function>
    <function name='xmlSetCompressMode' file='tree'>
      <info>set the default compression mode used, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)</info>
      <return type='void'/>
      <arg name='mode' type='int'/>
    </function>
    <function name='xmlSetDocCompressMode' file='tree'>
      <info>set the compression ratio for a document, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='mode' type='int'/>
    </function>
    <function name='xmlSetEntityReferenceFunc' file='parserInternals'>
      <info>Set the function to call call back when a xml reference has been made</info>
      <return type='void'/>
      <arg name='func' type='xmlEntityReferenceFunc'/>
    </function>
    <function name='xmlSetExternalEntityLoader' file='parser'>
      <info>Changes the defaultexternal entity resolver function for the application</info>
      <return type='void'/>
      <arg name='f' type='xmlExternalEntityLoader'/>
    </function>
    <function name='xmlSetFeature' file='parser'>
      <info>Change the current value of one feature of this parser instance</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='name' type='const char *'/>
      <arg name='value' type='void *'/>
    </function>
    <function name='xmlSetGenericErrorFunc' file='xmlerror'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that handler will be called for subsequent error messages while not parsing nor validating. And ctx will be passed as first argument to handler One can simply force messages to be emitted to another FILE * than stderr by setting ctx to this file handle and handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *'/>
      <arg name='handler' type='xmlGenericErrorFunc'/>
    </function>
    <function name='xmlSetListDoc' file='tree'>
      <info>update all nodes in the list to point to the right document</info>
      <return type='void'/>
      <arg name='list' type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlSetNs' file='tree'>
      <info>Associate a namespace to a node, a posteriori.</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='ns' type='xmlNsPtr'/>
    </function>
    <function name='xmlSetNsProp' file='tree'>
      <info>Set (or reset) an attribute carried by a node. The ns structure must be in scope, this is not checked.</info>
      <return type='xmlAttrPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlSetProp' file='tree'>
      <info>Set (or reset) an attribute carried by a node.</info>
      <return type='xmlAttrPtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlSetTreeDoc' file='tree'>
      <info>update all nodes under the tree to point to the right document</info>
      <return type='void'/>
      <arg name='tree' type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlSetupParserForBuffer' file='parser'>
      <info>Setup the parser context to parse a new buffer; Clears any prior contents from the parser context. The buffer parameter must not be NULL, but the filename parameter can be</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='buffer' type='const xmlChar*'/>
      <arg name='filename' type='const char *'/>
    </function>
    <function name='xmlShell' file='debugXML'>
      <info>Implements the XML shell This allow to load, validate, view, modify and save a document using a environment similar to a UNIX commandline.</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='filename' type='char *'/>
      <arg name='input' type='xmlShellReadlineFunc'/>
      <arg name='output' type='FILE *'/>
    </function>
    <function name='xmlShellBase' file='debugXML'>
      <info>Implements the XML shell function "base" dumps the current XML base of the node</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='arg' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellCat' file='debugXML'>
      <info>Implements the XML shell function "cat" dumps the serialization node content (XML or HTML).</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='arg' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <functype name='xmlShellCmd' file='debugXML' info='This is a generic signature for the XML shell functions'/>
    <struct name='xmlShellCtxt' file='debugXML' info='A debugging shell context TODO: add the defined function tables.'/>
    <typedef name='xmlShellCtxtPtr' file='debugXML'/>
    <function name='xmlShellDir' file='debugXML'>
      <info>Implements the XML shell function "dir" dumps informations about the node (namespace, attributes, content).</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='arg' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellDu' file='debugXML'>
      <info>Implements the XML shell function "du" show the structure of the subtree under node tree If tree is null, the command works on the current node.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='arg' type='char *'/>
      <arg name='tree' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellList' file='debugXML'>
      <info>Implements the XML shell function "ls" Does an Unix like listing of the given node (like a directory)</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='arg' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellLoad' file='debugXML'>
      <info>Implements the XML shell function "load" loads a new document specified by the filename</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='filename' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellPrintNode' file='debugXML'>
      <info>Print node to stdout</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellPrintXPathError' file='debugXML'>
      <info>Print the xpath error to libxml default error channel</info>
      <return type='void'/>
      <arg name='errorType' type='int'/>
      <arg name='arg' type='const char *'/>
    </function>
    <function name='xmlShellPrintXPathResult' file='debugXML'>
      <info>Prints result to stdout</info>
      <return type='void'/>
      <arg name='list' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlShellPwd' file='debugXML'>
      <info>Implements the XML shell function "pwd" Show the full path from the root to the node, if needed building thumblers when similar elements exists at a given ancestor level. The output is compatible with XPath commands.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='buffer' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <functype name='xmlShellReadlineFunc' file='debugXML' info='This is a generic signature for the XML shell input function'/>
    <function name='xmlShellSave' file='debugXML'>
      <info>Implements the XML shell function "save" Write the current document to the filename, or it's original name</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='filename' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellValidate' file='debugXML'>
      <info>Implements the XML shell function "validate" Validate the document, if a DTD path is provided, then the validation is done against the given DTD.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='dtd' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlShellWrite' file='debugXML'>
      <info>Implements the XML shell function "write" Write the current node to the filename, it saves the serialization of the subtree under the node specified</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlShellCtxtPtr'/>
      <arg name='filename' type='char *'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <function name='xmlSkipBlankChars' file='parserInternals'>
      <info>skip all blanks character found at that point in the input streams. It pops up finished entities in the process if allowable at that point.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlSnprintfElementContent' file='valid'>
      <info>This will dump the content of the element content definition Intended just for the debug routine</info>
      <return type='void'/>
      <arg name='buf' type='char *'/>
      <arg name='size' type='int'/>
      <arg name='content' type='xmlElementContentPtr'/>
      <arg name='glob' type='int'/>
    </function>
    <function name='xmlSplitQName' file='parserInternals'>
      <info>parse an UTF8 encoded XML qualified name string </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='prefix' type='xmlChar **'/>
    </function>
    <function name='xmlSplitQName2' file='valid'>
      <info>parse an XML qualified name string </info>
      <return type='xmlChar *'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='prefix' type='xmlChar **'/>
    </function>
    <function name='xmlSprintfElementContent' file='valid'>
      <info>Deprecated, unsafe, use xmlSnprintfElementContent</info>
      <return type='void'/>
      <arg name='buf' type='char *'/>
      <arg name='content' type='xmlElementContentPtr'/>
      <arg name='glob' type='int'/>
    </function>
    <function name='xmlStopParser' file='parser'>
      <info>Blocks further parser processing</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
    </function>
    <function name='xmlStrEqual' file='parser'>
      <info>Check if both string are equal of have same content Should be a bit more readable and faster than xmlStrEqual()</info>
      <return type='int'/>
      <arg name='str1' type='const xmlChar *'/>
      <arg name='str2' type='const xmlChar *'/>
    </function>
    <function name='xmlStrcasecmp' file='parser'>
      <info>a strcasecmp for xmlChar's</info>
      <return type='int'/>
      <arg name='str1' type='const xmlChar *'/>
      <arg name='str2' type='const xmlChar *'/>
    </function>
    <function name='xmlStrcasestr' file='parser'>
      <info>a case-ignoring strstr for xmlChar's</info>
      <return type='const xmlChar *'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='val' type='xmlChar *'/>
    </function>
    <function name='xmlStrcat' file='parser'>
      <info>a strcat for array of xmlChar's. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of '0'.</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='xmlChar *'/>
      <arg name='add' type='const xmlChar *'/>
    </function>
    <function name='xmlStrchr' file='parser'>
      <info>a strchr for xmlChar's</info>
      <return type='const xmlChar *'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='val' type='xmlChar'/>
    </function>
    <function name='xmlStrcmp' file='parser'>
      <info>a strcmp for xmlChar's</info>
      <return type='int'/>
      <arg name='str1' type='const xmlChar *'/>
      <arg name='str2' type='const xmlChar *'/>
    </function>
    <function name='xmlStrdup' file='parser'>
      <info>a strdup for array of xmlChar's. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of '0'.</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='const xmlChar *'/>
    </function>
    <functype name='xmlStrdupFunc' file='xmlmemory'/>
    <function name='xmlStringCurrentChar' file='parserInternals'>
      <info>The current char value, if using UTF-8 this may actually span multiple bytes in the input buffer.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='cur' type='const xmlChar *'/>
      <arg name='len' type='int *'/>
    </function>
    <function name='xmlStringDecodeEntities' file='parserInternals'>
      <info>Takes a entity string content and process to do the adequate substitutions. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='what' type='int'/>
      <arg name='end' type='xmlChar'/>
      <arg name='end2' type='xmlChar'/>
      <arg name='end3' type='xmlChar'/>
    </function>
    <function name='xmlStringGetNodeList' file='tree'>
      <info>Parse the value string and build the node list associated. Should produce a flat tree with only TEXTs and ENTITY_REFs.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlStringLenGetNodeList' file='tree'>
      <info>Parse the value string and build the node list associated. Should produce a flat tree with only TEXTs and ENTITY_REFs.</info>
      <return type='xmlNodePtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='value' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlStrlen' file='parser'>
      <info>length of a xmlChar's string</info>
      <return type='int'/>
      <arg name='str' type='const xmlChar *'/>
    </function>
    <function name='xmlStrncasecmp' file='parser'>
      <info>a strncasecmp for xmlChar's</info>
      <return type='int'/>
      <arg name='str1' type='const xmlChar *'/>
      <arg name='str2' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlStrncat' file='parser'>
      <info>a strncat for array of xmlChar's, it will extend cur with the len first bytes of add.</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='xmlChar *'/>
      <arg name='add' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlStrncmp' file='parser'>
      <info>a strncmp for xmlChar's</info>
      <return type='int'/>
      <arg name='str1' type='const xmlChar *'/>
      <arg name='str2' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlStrndup' file='parser'>
      <info>a strndup for array of xmlChar's</info>
      <return type='xmlChar *'/>
      <arg name='cur' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlStrstr' file='parser'>
      <info>a strstr for xmlChar's</info>
      <return type='const xmlChar *'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='val' type='const xmlChar *'/>
    </function>
    <function name='xmlStrsub' file='parser'>
      <info>Extract a substring of a given string</info>
      <return type='xmlChar *'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='start' type='int'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlSubstituteEntitiesDefault' file='parser'>
      <info>Set and return the previous value for default entity support. Initially the parser always keep entity references instead of substituting entity values in the output. This function has to be used to change the default parser behavior SAX::substituteEntities() has to be used for changing that on a file by file basis.</info>
      <return type='int'/>
      <arg name='val' type='int'/>
    </function>
    <macro name='xmlSubstituteEntitiesDefaultValue' file='globals' info='global variable controlling the entity substitution default behavior'/>
    <function name='xmlSwitchEncoding' file='parserInternals'>
      <info>change the input functions when discovering the character encoding of a given entity.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='enc' type='xmlCharEncoding'/>
    </function>
    <function name='xmlSwitchToEncoding' file='parserInternals'>
      <info>change the input functions when discovering the character encoding of a given entity.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlParserCtxtPtr'/>
      <arg name='handler' type='xmlCharEncodingHandlerPtr'/>
    </function>
    <function name='xmlTextConcat' file='tree'>
      <info>Concat the given string at the end of the existing node content</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='content' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlTextMerge' file='tree'>
      <info>Merge two text nodes into one</info>
      <return type='xmlNodePtr'/>
      <arg name='first' type='xmlNodePtr'/>
      <arg name='second' type='xmlNodePtr'/>
    </function>
    <struct name='xmlURI' file='uri' info='A parsed URI reference. This is a struct containing the various fields as described in RFC 2396 but separated for further processing'/>
    <function name='xmlURIEscape' file='uri'>
      <info>Escaping routine, does not do validity checks ! It will try to escape the chars needing this, but this is heuristic based it's impossible to be sure.</info>
      <return type='xmlChar *'/>
      <arg name='str' type='const xmlChar *'/>
    </function>
    <function name='xmlURIEscapeStr' file='uri'>
      <info>This routine escapes a string to hex, ignoring reserved characters (a-z) and the characters in the exception list.</info>
      <return type='xmlChar *'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='list' type='const xmlChar *'/>
    </function>
    <typedef name='xmlURIPtr' file='uri'/>
    <function name='xmlURIUnescapeString' file='uri'>
      <info>Unescaping routine, does not do validity checks ! Output is direct unsigned char translation of XX values (no encoding)</info>
      <return type='char *'/>
      <arg name='str' type='const char *'/>
      <arg name='len' type='int'/>
      <arg name='target' type='char *'/>
    </function>
    <function name='xmlUTF8Strlen' file='encoding'>
      <info>compute the length of an UTF8 string, it doesn't do a full UTF8 checking of the content of the string.</info>
      <return type='int'/>
      <arg name='utf' type='const xmlChar *'/>
    </function>
    <function name='xmlUTF8Strloc' file='encoding'>
      <info>a function to provide relative location of a UTF8 char</info>
      <return type='int'/>
      <arg name='utf' type='const xmlChar *'/>
      <arg name='utfchar' type='const xmlChar *'/>
    </function>
    <function name='xmlUTF8Strndup' file='encoding'>
      <info>a strndup for array of UTF8's</info>
      <return type='xmlChar *'/>
      <arg name='utf' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlUTF8Strpos' file='encoding'>
      <info>a function to provide the equivalent of fetching a character from a string array</info>
      <return type='xmlChar *'/>
      <arg name='utf' type='const xmlChar *'/>
      <arg name='pos' type='int'/>
    </function>
    <function name='xmlUTF8Strsize' file='encoding'>
      <info>storage size of an UTF8 string</info>
      <return type='int'/>
      <arg name='utf' type='const xmlChar *'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlUTF8Strsub' file='encoding'>
      <info>Note: positions are given in units of UTF-8 chars</info>
      <return type='xmlChar *'/>
      <arg name='utf' type='const xmlChar *'/>
      <arg name='start' type='int'/>
      <arg name='len' type='int'/>
    </function>
    <function name='xmlUnlinkNode' file='tree'>
      <info>Unlink a node from it's current context, the node is not freed</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlUnlockLibrary' file='threads'>
      <info>xmlUnlockLibrary() is used to release a re-entrant lock on the libxml2 library.</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlUnsetNsProp' file='tree'>
      <info>Remove an attribute carried by a node.</info>
      <return type='int'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlUnsetProp' file='tree'>
      <info>Remove an attribute carried by a node.</info>
      <return type='int'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <struct name='xmlValidCtxt' file='valid'/>
    <typedef name='xmlValidCtxtPtr' file='valid'/>
    <function name='xmlValidGetPotentialChildren' file='valid'>
      <info>Build/extend a list of potential children allowed by the content tree</info>
      <return type='int'/>
      <arg name='ctree' type='xmlElementContent *'/>
      <arg name='list' type='const xmlChar **'/>
      <arg name='len' type='int *'/>
      <arg name='max' type='int'/>
    </function>
    <function name='xmlValidGetValidElements' file='valid'>
      <info>This function returns the list of authorized children to insert within an existing tree while respecting the validity constraints forced by the Dtd. The insertion point is defined using prev and next in the following ways: to insert before 'node': xmlValidGetValidElements(node-&gt;prev, node, ... to insert next 'node': xmlValidGetValidElements(node, node-&gt;next, ... to replace 'node': xmlValidGetValidElements(node-&gt;prev, node-&gt;next, ... to prepend a child to 'node': xmlValidGetValidElements(NULL, node-&gt;childs, to append a child to 'node': xmlValidGetValidElements(node-&gt;last, NULL, ... </info>
      <return type='int'/>
      <arg name='prev' type='xmlNode *'/>
      <arg name='next' type='xmlNode *'/>
      <arg name='list' type='const xmlChar **'/>
      <arg name='max' type='int'/>
    </function>
    <function name='xmlValidNormalizeAttributeValue' file='valid'>
      <info>Does the validation related extra step of the normalization of attribute values: </info>
      <return type='xmlChar *'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlNodePtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <struct name='xmlValidState' file='valid'/>
    <typedef name='xmlValidStatePtr' file='valid'/>
    <function name='xmlValidateAttributeDecl' file='valid'>
      <info>Try to validate a single attribute definition basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Attribute Default Legal ] - [ VC: Enumeration ] - [ VC: ID Attribute Default ] </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='attr' type='xmlAttributePtr'/>
    </function>
    <function name='xmlValidateAttributeValue' file='valid'>
      <info>Validate that the given attribute value match the proper production </info>
      <return type='int'/>
      <arg name='type' type='xmlAttributeType'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlValidateDocument' file='valid'>
      <info>Try to validate the document instance </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlValidateDocumentFinal' file='valid'>
      <info>Does the final step for the document validation once all the incremental validation steps have been completed </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlValidateDtd' file='valid'>
      <info>Try to validate the document against the dtd instance </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='dtd' type='xmlDtdPtr'/>
    </function>
    <function name='xmlValidateDtdFinal' file='valid'>
      <info>Does the final step for the dtds validation once all the subsets have been parsed </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlValidateElement' file='valid'>
      <info>Try to validate the subtree under an element</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlNodePtr'/>
    </function>
    <function name='xmlValidateElementDecl' file='valid'>
      <info>Try to validate a single element definition basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: One ID per Element Type ] - [ VC: No Duplicate Types ] - [ VC: Unique Element Type Declaration ]</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlElementPtr'/>
    </function>
    <function name='xmlValidateNotationDecl' file='valid'>
      <info>Try to validate a single notation definition basically it does the following checks as described by the XML-1.0 recommendation: - it seems that no validity constraint exists on notation declarations But this function get called anyway ...</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='nota' type='xmlNotationPtr'/>
    </function>
    <function name='xmlValidateNotationUse' file='valid'>
      <info>Validate that the given name match a notation declaration. - [ VC: Notation Declared ]</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='notationName' type='const xmlChar *'/>
    </function>
    <function name='xmlValidateOneAttribute' file='valid'>
      <info>Try to validate a single attribute for an element basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Attribute Value Type ] - [ VC: Fixed Attribute Default ] - [ VC: Entity Name ] - [ VC: Name Token ] - [ VC: ID ] - [ VC: IDREF ] - [ VC: Entity Name ] - [ VC: Notation Attributes ] </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlNodePtr'/>
      <arg name='attr' type='xmlAttrPtr'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlValidateOneElement' file='valid'>
      <info>Try to validate a single element and it's attributes, basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Element Valid ] - [ VC: Required Attribute ] Then call xmlValidateOneAttribute() for each attribute present. </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlNodePtr'/>
    </function>
    <function name='xmlValidateRoot' file='valid'>
      <info>Try to validate a the root element basically it does the following check as described by the XML-1.0 recommendation: - [ VC: Root Element Type ] it doesn't try to recurse or apply other check to the element</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <functype name='xmlValidityErrorFunc' file='valid'/>
    <functype name='xmlValidityWarningFunc' file='valid'/>
    <function name='xmlXIncludeProcess' file='xinclude'>
      <info>Implement the XInclude substitution on the XML document doc</info>
      <return type='int'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlXPathAddValues' file='xpathInternals'>
      <info>Implement the add operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <struct name='xmlXPathAxis' file='xpath'/>
    <functype name='xmlXPathAxisFunc' file='xpath'/>
    <typedef name='xmlXPathAxisPtr' file='xpath'/>
    <function name='xmlXPathBooleanFunction' file='xpathInternals'>
      <info>Implement the boolean() XPath function boolean boolean(object) he boolean function converts its argument to a boolean as follows: - a number is true if and only if it is neither positive or negative zero nor NaN - a node-set is true if and only if it is non-empty - a string is true if and only if its length is non-zero</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathCastBooleanToNumber' file='xpath'>
      <info>Converts a boolean to its number value</info>
      <return type='double'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlXPathCastBooleanToString' file='xpath'>
      <info>Converts a boolean to its string value.</info>
      <return type='xmlChar *'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlXPathCastNodeSetToBoolean' file='xpath'>
      <info>Converts a node-set to its boolean value</info>
      <return type='int'/>
      <arg name='ns' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathCastNodeSetToNumber' file='xpath'>
      <info>Converts a node-set to its number value</info>
      <return type='double'/>
      <arg name='ns' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathCastNodeSetToString' file='xpath'>
      <info>Converts a node-set to its string value.</info>
      <return type='xmlChar *'/>
      <arg name='ns' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathCastNodeToNumber' file='xpath'>
      <info>Converts a node to its number value</info>
      <return type='double'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathCastNodeToString' file='xpath'>
      <info>Converts a node to its string value.</info>
      <return type='xmlChar *'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathCastNumberToBoolean' file='xpath'>
      <info>Converts a number to its boolean value</info>
      <return type='int'/>
      <arg name='val' type='double'/>
    </function>
    <function name='xmlXPathCastNumberToString' file='xpath'>
      <info>Converts a number to its string value.</info>
      <return type='xmlChar *'/>
      <arg name='val' type='double'/>
    </function>
    <function name='xmlXPathCastStringToBoolean' file='xpath'>
      <info>Converts a string to its boolean value</info>
      <return type='int'/>
      <arg name='val' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathCastStringToNumber' file='xpath'>
      <info>Converts a string to its number value</info>
      <return type='double'/>
      <arg name='val' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathCastToBoolean' file='xpath'>
      <info>Converts an XPath object to its boolean value</info>
      <return type='int'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathCastToNumber' file='xpath'>
      <info>Converts an XPath object to its number value</info>
      <return type='double'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathCastToString' file='xpath'>
      <info>Converts an existing object to its string() equivalent</info>
      <return type='xmlChar *'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathCeilingFunction' file='xpathInternals'>
      <info>Implement the ceiling() XPath function number ceiling(number) The ceiling function returns the smallest (closest to negative infinity) number that is not less than the argument and that is an integer.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <macro name='xmlXPathCheckError' file='xpathInternals' info='Check if an XPath error was raised'/>
    <function name='xmlXPathCmpNodes' file='xpath'>
      <info>Compare two nodes w.r.t document order</info>
      <return type='int'/>
      <arg name='node1' type='xmlNodePtr'/>
      <arg name='node2' type='xmlNodePtr'/>
    </function>
    <struct name='xmlXPathCompExpr' file='xpath' info='[14] Expr ::= OrExpr [21] OrExpr ::= AndExpr | OrExpr 'or' AndExpr '/>
    <typedef name='xmlXPathCompExprPtr' file='xpath'/>
    <function name='xmlXPathCompareValues' file='xpathInternals'>
      <info>Implement the compare operation on XPath objects: arg1 &lt; arg2 (1, 1, ... arg1 &lt;= arg2 (1, 0, ... arg1 &gt; arg2 (0, 1, ... arg1 &gt;= arg2 (0, 0, ... </info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='inf' type='int'/>
      <arg name='strict' type='int'/>
    </function>
    <function name='xmlXPathCompile' file='xpath'>
      <info>Compile an XPath expression</info>
      <return type='xmlXPathCompExprPtr'/>
      <arg name='str' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathCompiledEval' file='xpath'>
      <info>Evaluate the Precompiled XPath expression in the given context.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='comp' type='xmlXPathCompExprPtr'/>
      <arg name='ctx' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPathConcatFunction' file='xpathInternals'>
      <info>Implement the concat() XPath function string concat(string, string, string*) The concat function returns the concatenation of its arguments.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathContainsFunction' file='xpathInternals'>
      <info>Implement the contains() XPath function boolean contains(string, string) The contains function returns true if the first argument string contains the second argument string, and otherwise returns false.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <struct name='xmlXPathContext' file='xpath' info='Expression evaluation occurs with respect to a context. he context consists of: - a node (the context node) - a node list (the context node list) - a set of variable bindings - a function library - the set of namespace declarations in scope for the expression Following the switch to hash tables, this need to be trimmed up at the next binary incompatible release.'/>
    <typedef name='xmlXPathContextPtr' file='xpath'/>
    <function name='xmlXPathConvertBoolean' file='xpath'>
      <info>Converts an existing object to its boolean() equivalent</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <functype name='xmlXPathConvertFunc' file='xpath'/>
    <function name='xmlXPathConvertNumber' file='xpath'>
      <info>Converts an existing object to its number() equivalent</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathConvertString' file='xpath'>
      <info>Converts an existing object to its string() equivalent</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathCountFunction' file='xpathInternals'>
      <info>Implement the count() XPath function number count(node-set)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathDebugDumpCompExpr' file='xpathInternals'>
      <info>Dumps the tree of the compiled XPath expression.</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='comp' type='xmlXPathCompExprPtr'/>
      <arg name='depth' type='int'/>
    </function>
    <function name='xmlXPathDebugDumpObject' file='xpathInternals'>
      <info>Dump the content of the object for debugging purposes</info>
      <return type='void'/>
      <arg name='output' type='FILE *'/>
      <arg name='cur' type='xmlXPathObjectPtr'/>
      <arg name='depth' type='int'/>
    </function>
    <function name='xmlXPathDifference' file='xpathInternals'>
      <info>Implements the EXSLT - Sets difference() function: node-set set:difference (node-set, node-set)</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes1' type='xmlNodeSetPtr'/>
      <arg name='nodes2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathDistinct' file='xpathInternals'>
      <info>Implements the EXSLT - Sets distinct() function: node-set set:distinct (node-set) nodes is sorted by document order, then exslSetsDistinctSorted is called with the sorted node-set</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathDistinctSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets distinct() function: node-set set:distinct (node-set)</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathDivValues' file='xpathInternals'>
      <info>Implement the div operation on XPath objects arg1 / arg2: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <macro name='xmlXPathEmptyNodeSet' file='xpathInternals' info='Empties a node-set'/>
    <function name='xmlXPathEqualValues' file='xpathInternals'>
      <info>Implement the equal operation on XPath objects content: arg1 == arg2</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <enum name='xmlXPathError' file='xpath'/>
    <function name='xmlXPathEval' file='xpath'>
      <info>Evaluate the XPath Location Path in the given context.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='ctx' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPathEvalExpr' file='xpathInternals'>
      <info>Parse and evaluate an XPath expression in the given context, then push the result on the context stack</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathEvalExpression' file='xpath'>
      <info>Evaluate the XPath expression in the given context.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
    </function>
    <functype name='xmlXPathEvalFunc' file='xpath' info='an XPath evaluation function, the parameters are on the XPath context stack'/>
    <function name='xmlXPathEvalPredicate' file='xpath'>
      <info>Evaluate a predicate result for the current node. A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the position of the context node in the context node list (as returned by the position function) and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='res' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathEvaluatePredicateResult' file='xpathInternals'>
      <info>Evaluate a predicate result for the current node. A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the position of the context node in the context node list (as returned by the position function) and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='res' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathFalseFunction' file='xpathInternals'>
      <info>Implement the false() XPath function boolean false()</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathFloorFunction' file='xpathInternals'>
      <info>Implement the floor() XPath function number floor(number) The floor function returns the largest (closest to positive infinity) number that is not greater than the argument and that is an integer.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathFreeCompExpr' file='xpath'>
      <info>Free up the memory allocated by comp</info>
      <return type='void'/>
      <arg name='comp' type='xmlXPathCompExprPtr'/>
    </function>
    <function name='xmlXPathFreeContext' file='xpathInternals'>
      <info>Free up an xmlXPathContext</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPathFreeNodeSet' file='xpathInternals'>
      <info>Free the NodeSet compound (not the actual nodes !).</info>
      <return type='void'/>
      <arg name='obj' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathFreeNodeSetList' file='xpathInternals'>
      <info>Free up the xmlXPathObjectPtr obj but don't deallocate the objects in the list contrary to xmlXPathFreeObject().</info>
      <return type='void'/>
      <arg name='obj' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathFreeObject' file='xpathInternals'>
      <info>Free up an xmlXPathObjectPtr object.</info>
      <return type='void'/>
      <arg name='obj' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathFreeParserContext' file='xpathInternals'>
      <info>Free up an xmlXPathParserContext</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <functype name='xmlXPathFuncLookupFunc' file='xpathInternals'/>
    <typedef name='xmlXPathFuncPtr' file='xpath'/>
    <struct name='xmlXPathFunct' file='xpath'/>
    <functype name='xmlXPathFunction' file='xpath' info='An XPath function The arguments (if any) are popped out of the context stack and the result is pushed on the stack.'/>
    <function name='xmlXPathFunctionLookup' file='xpathInternals'>
      <info>Search in the Function array of the context for the given function.</info>
      <return type='xmlXPathFunction'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathFunctionLookupNS' file='xpathInternals'>
      <info>Search in the Function array of the context for the given function.</info>
      <return type='xmlXPathFunction'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='uri' type='const xmlChar *ns_'/>
    </function>
    <macro name='xmlXPathGetContextNode' file='xpathInternals' info='Get the context node of an XPath context'/>
    <macro name='xmlXPathGetDocument' file='xpathInternals' info='Get the document of an XPath context'/>
    <macro name='xmlXPathGetError' file='xpathInternals' info='Get the error code of an XPath context'/>
    <function name='xmlXPathHasSameNodes' file='xpathInternals'>
      <info>Implements the EXSLT - Sets has-same-nodes function: boolean set:has-same-node(node-set, node-set)</info>
      <return type='int'/>
      <arg name='nodes1' type='xmlNodeSetPtr'/>
      <arg name='nodes2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathIdFunction' file='xpathInternals'>
      <info>Implement the id() XPath function node-set id(object) The id function selects elements by their unique ID (see [5.2.1 Unique IDs]). When the argument to id is of type node-set, then the result is the union of the result of applying id to the string value of each of the nodes in the argument node-set. When the argument to id is of any other type, the argument is converted to a string as if by a call to the string function; the string is split into a whitespace-separated list of tokens (whitespace is any sequence of characters matching the production S); the result is a node-set containing the elements in the same document as the context node that have a unique ID equal to any of the tokens in the list.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathInit' file='xpathInternals'>
      <info>Initialize the XPath environment</info>
      <return type='void'/>
      <arg name='void' type=''/>
    </function>
    <function name='xmlXPathIntersection' file='xpathInternals'>
      <info>Implements the EXSLT - Sets intersection() function: node-set set:intersection (node-set, node-set)</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes1' type='xmlNodeSetPtr'/>
      <arg name='nodes2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathIsInf' file='xpath'>
      <info>Provides a portable isinf() function to detect whether a double is a +Infinite or -Infinite. Based on trio code http://sourceforge.net/projects/ctrio/</info>
      <return type='int'/>
      <arg name='val' type='double'/>
    </function>
    <function name='xmlXPathIsNaN' file='xpath'>
      <info>Provides a portable isnan() function to detect whether a double is a NotaNumber. Based on trio code http://sourceforge.net/projects/ctrio/</info>
      <return type='int'/>
      <arg name='val' type='double'/>
    </function>
    <function name='xmlXPathIsNodeType' file='xpathInternals'>
      <info>Is the name given a NodeType one. </info>
      <return type='int'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathLangFunction' file='xpathInternals'>
      <info>Implement the lang() XPath function boolean lang(string) The lang function returns true or false depending on whether the language of the context node as specified by xml:lang attributes is the same as or is a sublanguage of the language specified by the argument string. The language of the context node is determined by the value of the xml:lang attribute on the context node, or, if the context node has no xml:lang attribute, by the value of the xml:lang attribute on the nearest ancestor of the context node that has an xml:lang attribute. If there is no such attribute, then lang</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathLastFunction' file='xpathInternals'>
      <info>Implement the last() XPath function number last() The last function returns the number of nodes in the context node list.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathLeading' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set) nodes1 and nodes2 are sorted by document order, then exslSetsLeadingSorted is called.</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes1' type='xmlNodeSetPtr'/>
      <arg name='nodes2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathLeadingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set)</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes1' type='xmlNodeSetPtr'/>
      <arg name='nodes2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathLocalNameFunction' file='xpathInternals'>
      <info>Implement the local-name() XPath function string local-name(node-set?) The local-name function returns a string containing the local part of the name of the node in the argument node-set that is first in document order. If the node-set is empty or the first node has no name, an empty string is returned. If the argument is omitted it defaults to the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathModValues' file='xpathInternals'>
      <info>Implement the mod operation on XPath objects: arg1 / arg2 The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathMultValues' file='xpathInternals'>
      <info>Implement the multiply operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathNamespaceURIFunction' file='xpathInternals'>
      <info>Implement the namespace-uri() XPath function string namespace-uri(node-set?) The namespace-uri function returns a string containing the namespace URI of the expanded name of the node in the argument node-set that is first in document order. If the node-set is empty, the first node has no name, or the expanded name has no namespace URI, an empty string is returned. If the argument is omitted it defaults to the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathNewBoolean' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type boolean and of value val</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlXPathNewCString' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type string and of value val</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='const char *'/>
    </function>
    <function name='xmlXPathNewContext' file='xpathInternals'>
      <info>Create a new xmlXPathContext</info>
      <return type='xmlXPathContextPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xmlXPathNewFloat' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type double and of value val</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='double'/>
    </function>
    <function name='xmlXPathNewNodeSet' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type NodeSet and initialize it with the single Node val</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNewNodeSetList' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type NodeSet and initialize it with the Nodeset val</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathNewParserContext' file='xpathInternals'>
      <info>Create a new xmlXPathParserContext</info>
      <return type='xmlXPathParserContextPtr'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPathNewString' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type string and of value val</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathNewValueTree' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type Value Tree (XSLT) and initialize it with the tree root val</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextAncestor' file='xpathInternals'>
      <info>Traversal function for the "ancestor" direction the ancestor axis contains the ancestors of the context node; the ancestors of the context node consist of the parent of context node and the parent's parent and so on; the nodes are ordered in reverse document order; thus the parent is the first node on the axis, and the parent's parent is the second node on the axis</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextAncestorOrSelf' file='xpathInternals'>
      <info>Traversal function for the "ancestor-or-self" direction he ancestor-or-self axis contains the context node and ancestors of the context node in reverse document order; thus the context node is the first node on the axis, and the context node's parent the second; parent here is defined the same as with the parent axis.</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextAttribute' file='xpathInternals'>
      <info>Traversal function for the "attribute" direction TODO: support DTD inherited default attributes</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextChild' file='xpathInternals'>
      <info>Traversal function for the "child" direction The child axis contains the children of the context node in document order.</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextDescendant' file='xpathInternals'>
      <info>Traversal function for the "descendant" direction the descendant axis contains the descendants of the context node in document order; a descendant is a child or a child of a child and so on.</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextDescendantOrSelf' file='xpathInternals'>
      <info>Traversal function for the "descendant-or-self" direction the descendant-or-self axis contains the context node and the descendants of the context node in document order; thus the context node is the first node on the axis, and the first child of the context node is the second node on the axis</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextFollowing' file='xpathInternals'>
      <info>Traversal function for the "following" direction The following axis contains all nodes in the same document as the context node that are after the context node in document order, excluding any descendants and excluding attribute nodes and namespace nodes; the nodes are ordered in document order</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextFollowingSibling' file='xpathInternals'>
      <info>Traversal function for the "following-sibling" direction The following-sibling axis contains the following siblings of the context node in document order.</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextNamespace' file='xpathInternals'>
      <info>Traversal function for the "namespace" direction the namespace axis contains the namespace nodes of the context node; the order of nodes on this axis is implementation-defined; the axis will be empty unless the context node is an element </info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextParent' file='xpathInternals'>
      <info>Traversal function for the "parent" direction The parent axis contains the parent of the context node, if there is one.</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextPreceding' file='xpathInternals'>
      <info>Traversal function for the "preceding" direction the preceding axis contains all nodes in the same document as the context node that are before the context node in document order, excluding any ancestors and excluding attribute nodes and namespace nodes; the nodes are ordered in reverse document order</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextPrecedingSibling' file='xpathInternals'>
      <info>Traversal function for the "preceding-sibling" direction The preceding-sibling axis contains the preceding siblings of the context node in reverse document order; the first preceding sibling is first on the axis; the sibling preceding that node is the second on the axis and so on.</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNextSelf' file='xpathInternals'>
      <info>Traversal function for the "self" direction The self axis contains just the context node itself</info>
      <return type='xmlNodePtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeLeading' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set) nodes is sorted by document order, then exslSetsNodeLeadingSorted is called.</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes' type='xmlNodeSetPtr'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeLeadingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set)</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes' type='xmlNodeSetPtr'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetAdd' file='xpathInternals'>
      <info>add a new xmlNodePtr to an existing NodeSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr'/>
      <arg name='val' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetAddUnique' file='xpathInternals'>
      <info>add a new xmlNodePtr to an existing NodeSet, optimized version when we are sure the node is not already in the set.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr'/>
      <arg name='val' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetContains' file='xpathInternals'>
      <info>checks whether cur contains val</info>
      <return type='int'/>
      <arg name='cur' type='xmlNodeSetPtr'/>
      <arg name='val' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetCreate' file='xpathInternals'>
      <info>Create a new xmlNodeSetPtr of type double and of value val</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='val' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetDel' file='xpathInternals'>
      <info>Removes an xmlNodePtr from an existing NodeSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr'/>
      <arg name='val' type='xmlNodePtr'/>
    </function>
    <macro name='xmlXPathNodeSetGetLength' file='xpath' info='Implement a functionality similar to the DOM NodeList.length'/>
    <macro name='xmlXPathNodeSetIsEmpty' file='xpath' info='Checks whether ns is empty or not'/>
    <macro name='xmlXPathNodeSetItem' file='xpath' info='Implements a functionality similar to the DOM NodeList.item()'/>
    <function name='xmlXPathNodeSetMerge' file='xpathInternals'>
      <info>Merges two nodesets, all nodes from val2 are added to val1 if val1 is NULL, a new set is created and copied from val2</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='val1' type='xmlNodeSetPtr'/>
      <arg name='val2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathNodeSetRemove' file='xpathInternals'>
      <info>Removes an entry from an existing NodeSet list.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlXPathNodeSetSort' file='xpathInternals'>
      <info>Sort the node set in document order</info>
      <return type='void'/>
      <arg name='set' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathNodeTrailing' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set) nodes is sorted by document order, then xmlXPathNodeTrailingSorted is called.</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes' type='xmlNodeSetPtr'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeTrailingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set)</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes' type='xmlNodeSetPtr'/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPathNormalizeFunction' file='xpathInternals'>
      <info>Implement the normalize-space() XPath function string normalize-space(string?) The normalize-space function returns the argument string with white space normalized by stripping leading and trailing whitespace and replacing sequences of whitespace characters by a single space. Whitespace characters are the same allowed by the S production in XML. If the argument is omitted, it defaults to the context node converted to a string, in other words the value of the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathNotFunction' file='xpathInternals'>
      <info>Implement the not() XPath function boolean not(boolean) The not function returns true if its argument is false, and false otherwise.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathNsLookup' file='xpathInternals'>
      <info>Search in the namespace declaration array of the context for the given namespace name associated to the given prefix</info>
      <return type='const xmlChar *'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='prefix' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathNumberFunction' file='xpathInternals'>
      <info>Implement the number() XPath function number number(object?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <struct name='xmlXPathObject' file='xpath'/>
    <function name='xmlXPathObjectCopy' file='xpath'>
      <info>allocate a new copy of a given object</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <typedef name='xmlXPathObjectPtr' file='xpath'/>
    <enum name='xmlXPathObjectType' file='xpath'/>
    <function name='xmlXPathParseNCName' file='xpathInternals'>
      <info>parse an XML namespace non qualified name. </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathParseName' file='xpathInternals'>
      <info>parse an XML name </info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <struct name='xmlXPathParserContext' file='xpath' info='An XPath parser context, it contains pure parsing informations, an xmlXPathContext, and the stack of objects.'/>
    <typedef name='xmlXPathParserContextPtr' file='xpath'/>
    <function name='xmlXPathPopBoolean' file='xpathInternals'>
      <info>Pops a boolean from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathPopExternal' file='xpathInternals'>
      <info>Pops an external object from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='void *'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathPopNodeSet' file='xpathInternals'>
      <info>Pops a node-set from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathPopNumber' file='xpathInternals'>
      <info>Pops a number from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='double'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathPopString' file='xpathInternals'>
      <info>Pops a string from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='xmlChar *'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathPositionFunction' file='xpathInternals'>
      <info>Implement the position() XPath function number position() The position function returns the position of the context node in the context node list. The first position is 1, and so the last position will be equal to last().</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathRegisterAllFunctions' file='xpathInternals'>
      <info>Registers all default XPath functions in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPathRegisterFunc' file='xpathInternals'>
      <info>Register a new function. If f is NULL it unregisters the function</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='f' type='xmlXPathFunction'/>
    </function>
    <function name='xmlXPathRegisterFuncLookup' file='xpathInternals'>
      <info>Registers an external mechanism to do function lookup.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='f' type='xmlXPathFuncLookupFunc'/>
      <arg name='funcCtxt' type='void *'/>
    </function>
    <function name='xmlXPathRegisterFuncNS' file='xpathInternals'>
      <info>Register a new function. If f is NULL it unregisters the function</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='uri' type='const xmlChar *ns_'/>
      <arg name='f' type='xmlXPathFunction'/>
    </function>
    <function name='xmlXPathRegisterNs' file='xpathInternals'>
      <info>Register a new namespace. If ns_uri is NULL it unregisters the namespace</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='prefix' type='const xmlChar *'/>
      <arg name='uri' type='const xmlChar *ns_'/>
    </function>
    <function name='xmlXPathRegisterVariable' file='xpathInternals'>
      <info>Register a new variable value. If value is NULL it unregisters the variable</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathRegisterVariableLookup' file='xpathInternals'>
      <info>register an external mechanism to do variable lookup</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='f' type='xmlXPathVariableLookupFunc'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlXPathRegisterVariableNS' file='xpathInternals'>
      <info>Register a new variable value. If value is NULL it unregisters the variable</info>
      <return type='int'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='uri' type='const xmlChar *ns_'/>
      <arg name='value' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPathRegisteredFuncsCleanup' file='xpathInternals'>
      <info>Cleanup the XPath context data associated to registered functions</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPathRegisteredNsCleanup' file='xpathInternals'>
      <info>Cleanup the XPath context data associated to registered variables</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPathRegisteredVariablesCleanup' file='xpathInternals'>
      <info>Cleanup the XPath context data associated to registered variables</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
    </function>
    <macro name='xmlXPathReturnBoolean' file='xpathInternals' info='Pushes the boolean val on the context stack'/>
    <macro name='xmlXPathReturnEmptyNodeSet' file='xpathInternals' info='Pushes an empty node-set on the context stack'/>
    <macro name='xmlXPathReturnEmptyString' file='xpathInternals' info='Pushes an empty string on the stack'/>
    <macro name='xmlXPathReturnExternal' file='xpathInternals' info='Pushes user data on the context stack'/>
    <macro name='xmlXPathReturnFalse' file='xpathInternals' info='Pushes false on the context stack'/>
    <macro name='xmlXPathReturnNodeSet' file='xpathInternals' info='Pushes the node-set ns on the context stack'/>
    <macro name='xmlXPathReturnNumber' file='xpathInternals' info='Pushes the double val on the context stack'/>
    <macro name='xmlXPathReturnString' file='xpathInternals' info='Pushes the string str on the context stack'/>
    <macro name='xmlXPathReturnTrue' file='xpathInternals' info='Pushes true on the context stack'/>
    <function name='xmlXPathRoot' file='xpathInternals'>
      <info>Initialize the context to the root of the document</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathRoundFunction' file='xpathInternals'>
      <info>Implement the round() XPath function number round(number) The round function returns the number that is closest to the argument and that is an integer. If there are two such numbers, then the one that is even is returned.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <macro name='xmlXPathSetArityError' file='xpathInternals' info='Raises an XPATH_INVALID_ARITY error'/>
    <macro name='xmlXPathSetError' file='xpathInternals' info='Raises an error.'/>
    <macro name='xmlXPathSetTypeError' file='xpathInternals' info='Raises an XPATH_INVALID_TYPE error'/>
    <macro name='xmlXPathStackIsExternal' file='xpathInternals' info='Checks if the current value on the XPath stack is an external object.'/>
    <macro name='xmlXPathStackIsNodeSet' file='xpathInternals' info='Check if the current value on the XPath stack is a node set or an XSLT value tree'/>
    <function name='xmlXPathStartsWithFunction' file='xpathInternals'>
      <info>Implement the starts-with() XPath function boolean starts-with(string, string) The starts-with function returns true if the first argument string starts with the second argument string, and otherwise returns false.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathStringEvalNumber' file='xpathInternals'>
      <info>[30a] Float ::= Number ('e' Digits?)? </info>
      <return type='double'/>
      <arg name='str' type='const xmlChar *'/>
    </function>
    <function name='xmlXPathStringFunction' file='xpathInternals'>
      <info>Implement the string() XPath function string string(object?) he string function converts an object to a string as follows: - A node-set is converted to a string by returning the value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned. - A number is converted to a string as follows + NaN is converted to the string NaN + positive zero is converted to the string 0 + negative zero is converted to the string 0 + positive infinity is converted to the string Infinity + negative infinity is converted to the string -Infinity + if the number is an integer, the number is represented in decimal form as a Number with no decimal point and no leading zeros, preceded by a minus sign (-) if the number is negative + otherwise, the number is represented in decimal form as a Number including a decimal point with at least one digit before the decimal point and at least one digit after the decimal point, preceded by a minus sign (-) if the number is negative; there must be no leading zeros before the decimal point apart possibly from the one required digit immediately before the decimal point; beyond the one required digit after the decimal point there must be as many, but only as many, more digits as are needed to uniquely distinguish the number from all other IEEE 754 numeric values. - The boolean false value is converted to the string false. The boolean true value is converted to the string true. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathStringLengthFunction' file='xpathInternals'>
      <info>Implement the string-length() XPath function number string-length(string?) The string-length returns the number of characters in the string (see [3.6 Strings]). If the argument is omitted, it defaults to the context node converted to a string, in other words the value of the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathSubValues' file='xpathInternals'>
      <info>Implement the subtraction operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPathSubstringAfterFunction' file='xpathInternals'>
      <info>Implement the substring-after() XPath function string substring-after(string, string) The substring-after function returns the substring of the first argument string that follows the first occurrence of the second argument string in the first argument string, or the empty stringi if the first argument string does not contain the second argument string. For example, substring-after("1999/04/01","/") returns 04/01, and substring-after("1999/04/01","19") returns 99/04/01.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathSubstringBeforeFunction' file='xpathInternals'>
      <info>Implement the substring-before() XPath function string substring-before(string, string) The substring-before function returns the substring of the first argument string that precedes the first occurrence of the second argument string in the first argument string, or the empty string if the first argument string does not contain the second argument string. For example, substring-before("1999/04/01","/") returns 1999.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathSubstringFunction' file='xpathInternals'>
      <info>Implement the substring() XPath function string substring(string, number, number?) The substring function returns the substring of the first argument starting at the position specified in the second argument with length specified in the third argument. For example, substring("12345",2,3) returns "234". If the third argument is not specified, it returns the substring starting at the position specified in the second argument and continuing to the end of the string. For example, substring("12345",2) returns "2345". More precisely, each character in the string (see [3.6 Strings]) is considered to have a numeric position: the position of the first character is 1, the position of the second character is 2 and so on. The returned substring contains those characters for which the position of the character is greater than or equal to the second argument and, if the third argument is specified, less than the sum of the second and third arguments; the comparisons and addition used for the above follow the standard IEEE 754 rules. Thus: - substring("12345", 1.5, 2.6) returns "234" - substring("12345", 0, 3) returns "12" - substring("12345", 0 div 0, 3) returns "" - substring("12345", 1, 0 div 0) returns "" - substring("12345", -42, 1 div 0) returns "12345" - substring("12345", -1 div 0, 1 div 0) returns ""</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathSumFunction' file='xpathInternals'>
      <info>Implement the sum() XPath function number sum(node-set) The sum function returns the sum of the values of the nodes in the argument node-set.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathTrailing' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set) nodes1 and nodes2 are sorted by document order, then xmlXPathTrailingSorted is called.</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes1' type='xmlNodeSetPtr'/>
      <arg name='nodes2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathTrailingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set)</info>
      <return type='xmlNodeSetPtr'/>
      <arg name='nodes1' type='xmlNodeSetPtr'/>
      <arg name='nodes2' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathTranslateFunction' file='xpathInternals'>
      <info>Implement the translate() XPath function string translate(string, string, string) The translate function returns the first argument string with occurrences of characters in the second argument string replaced by the character at the corresponding position in the third argument string. For example, translate("bar","abc","ABC") returns the string BAr. If there is a character in the second argument string with no character at a corresponding position in the third argument string (because the second argument string is longer than the third argument string), then occurrences of that character in the first argument string are removed. For example, translate("--aaa--","abc-","ABC")</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPathTrueFunction' file='xpathInternals'>
      <info>Implement the true() XPath function boolean true()</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <struct name='xmlXPathType' file='xpath'/>
    <typedef name='xmlXPathTypePtr' file='xpath'/>
    <function name='xmlXPathValueFlipSign' file='xpathInternals'>
      <info>Implement the unary - operation on an XPath object The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <struct name='xmlXPathVariable' file='xpath'/>
    <function name='xmlXPathVariableLookup' file='xpathInternals'>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
    </function>
    <functype name='xmlXPathVariableLookupFunc' file='xpathInternals'/>
    <function name='xmlXPathVariableLookupNS' file='xpathInternals'>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='ctxt' type='xmlXPathContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='uri' type='const xmlChar *ns_'/>
    </function>
    <typedef name='xmlXPathVariablePtr' file='xpath'/>
    <function name='xmlXPathWrapCString' file='xpathInternals'>
      <info>Wraps a string into an XPath object.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='char *'/>
    </function>
    <function name='xmlXPathWrapExternal' file='xpathInternals'>
      <info>Wraps the val data into an XPath object.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='void *'/>
    </function>
    <function name='xmlXPathWrapNodeSet' file='xpathInternals'>
      <info>Wrap the Nodeset val in a new xmlXPathObjectPtr</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPathWrapString' file='xpathInternals'>
      <info>Wraps the val string into an XPath object.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlChar *'/>
    </function>
    <function name='xmlXPatherror' file='xpathInternals'>
      <info>Formats an error message.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='file' type='const char *'/>
      <arg name='line' type='int'/>
      <arg name='no' type='int'/>
    </function>
    <function name='xmlXPtrBuildNodeList' file='xpointer'>
      <info>Build a node list tree copy of the XPointer result. This will drop Attributes and Namespace declarations.</info>
      <return type='xmlNodePtr'/>
      <arg name='obj' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrEval' file='xpointer'>
      <info>Evaluate the XPath Location Path in the given context.</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='str' type='const xmlChar *'/>
      <arg name='ctx' type='xmlXPathContextPtr'/>
    </function>
    <function name='xmlXPtrEvalRangePredicate' file='xpointer'>
      <info>[8] Predicate ::= '[' PredicateExpr ']' [9] PredicateExpr ::= Expr </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
    </function>
    <function name='xmlXPtrFreeLocationSet' file='xpointer'>
      <info>Free the LocationSet compound (not the actual ranges !).</info>
      <return type='void'/>
      <arg name='obj' type='xmlLocationSetPtr'/>
    </function>
    <function name='xmlXPtrLocationSetAdd' file='xpointer'>
      <info>add a new xmlXPathObjectPtr to an existing LocationSet If the location already exist in the set val is freed.</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrLocationSetCreate' file='xpointer'>
      <info>Create a new xmlLocationSetPtr of type double and of value val</info>
      <return type='xmlLocationSetPtr'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrLocationSetDel' file='xpointer'>
      <info>Removes an xmlXPathObjectPtr from an existing LocationSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr'/>
      <arg name='val' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrLocationSetMerge' file='xpointer'>
      <info>Merges two rangesets, all ranges from val2 are added to val1</info>
      <return type='xmlLocationSetPtr'/>
      <arg name='val1' type='xmlLocationSetPtr'/>
      <arg name='val2' type='xmlLocationSetPtr'/>
    </function>
    <function name='xmlXPtrLocationSetRemove' file='xpointer'>
      <info>Removes an entry from an existing LocationSet list.</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr'/>
      <arg name='val' type='int'/>
    </function>
    <function name='xmlXPtrNewCollapsedRange' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range using a single nodes</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPtrNewContext' file='xpointer'>
      <info>Create a new XPointer context</info>
      <return type='xmlXPathContextPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='here' type='xmlNodePtr'/>
      <arg name='origin' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPtrNewLocationSetNodeSet' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with all the nodes from set</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='set' type='xmlNodeSetPtr'/>
    </function>
    <function name='xmlXPtrNewLocationSetNodes' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with the single range made of the two nodes start and end</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlNodePtr'/>
      <arg name='end' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPtrNewRange' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlNodePtr'/>
      <arg name='startindex' type='int'/>
      <arg name='end' type='xmlNodePtr'/>
      <arg name='endindex' type='int'/>
    </function>
    <function name='xmlXPtrNewRangeNodeObject' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range from a not to an object</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlNodePtr'/>
      <arg name='end' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrNewRangeNodePoint' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range from a node to a point</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlNodePtr'/>
      <arg name='end' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrNewRangeNodes' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range using 2 nodes</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlNodePtr'/>
      <arg name='end' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPtrNewRangePointNode' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range from a point to a node</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlXPathObjectPtr'/>
      <arg name='end' type='xmlNodePtr'/>
    </function>
    <function name='xmlXPtrNewRangePoints' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range using 2 Points</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='start' type='xmlXPathObjectPtr'/>
      <arg name='end' type='xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrRangeToFunction' file='xpointer'>
      <info>Implement the range-to() XPointer function</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr'/>
      <arg name='nargs' type='int'/>
    </function>
    <function name='xmlXPtrWrapLocationSet' file='xpointer'>
      <info>Wrap the LocationSet val in a new xmlXPathObjectPtr</info>
      <return type='xmlXPathObjectPtr'/>
      <arg name='val' type='xmlLocationSetPtr'/>
    </function>
  </symbols>
</api>
